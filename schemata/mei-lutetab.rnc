default namespace = "http://www.music-encoding.org/ns/mei"
namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"
namespace rng = "http://relaxng.org/ns/structure/1.0"
namespace sch = "http://purl.oclc.org/dsdl/schematron"
namespace xlink = "http://www.w3.org/1999/xlink"

# Schema generated from ODD source 2015-05-14T17:38:44Z. .
# TEI Edition: 2013 Release
# TEI Edition Location: http://www.tei-c.org/Vault/P5//
#

#

sch:ns [ prefix = "tei" uri = "http://www.tei-c.org/ns/1.0" ]
data.ACCIDENTAL.EXPLICIT =
  
  ## sharp
  "s"
  | 
    ## flat
    "f"
  | 
    ## double sharp (written as 2 sharps)
    "ss"
  | 
    ## double sharp (written using croix)
    "x"
  | 
    ## double flat
    "ff"
  | 
    ## triple sharp (written as croix and 2 sharps)
    "xs"
  | 
    ## triple sharp (written as 3 sharps)
    "ts"
  | 
    ## triple flat
    "tf"
  | 
    ## natural
    "n"
  | 
    ## natural + flat; used to cancel preceding double flat
    "nf"
  | 
    ## natural + sharp; used to cancel preceding double sharp
    "ns"
  | 
    ## sharp note raised by quarter tone
    "su"
  | 
    ## sharp note lowered by quarter tone
    "sd"
  | 
    ## flat note raised by quarter tone
    "fu"
  | 
    ## flat note lowered by quarter tone
    "fd"
  | 
    ## natural note raised by quarter tone
    "nu"
  | 
    ## natural note lowered by quarter tone
    "nd"
data.ACCIDENTAL.IMPLICIT =
  
  ## sharp
  "s"
  | 
    ## flat
    "f"
  | 
    ## double sharp
    "ss"
  | 
    ## double flat
    "ff"
  | 
    ## natural
    "n"
  | 
    ## three quarter-tones sharp
    "su"
  | 
    ## quarter-tone sharp
    "sd"
  | 
    ## quarter-tone flat
    "fu"
  | 
    ## three quarter-tones flat
    "fd"
data.ARTICULATION =
  
  ## accent (Unicode 1D17B)
  "acc"
  | 
    ## staccato (Unicode 1D17C)
    "stacc"
  | 
    ## tenuto (Unicode 1D17D)
    "ten"
  | 
    ## staccatissimo (Unicode 1D17E)
    "stacciss"
  | 
    ## marcato (Unicode 1D17F)
    "marc"
  | 
    ## marcato + staccato (Unicode 1D180)
    "marc-stacc"
  | 
    ## spiccato
    "spicc"
  | 
    ## main note followed by short slide to higher, indeterminate pitch (Unicode
    ##             1D185)
    "doit"
  | 
    ## main note preceded by short slide from lower, indeterminate pitch
    ##             (Unicode 1D186)
    "rip"
  | 
    ## main note preceded by "slide" from higher, indeterminate
    ##             pitch
    "plop"
  | 
    ## main note followed by long "slide" to lower, indeterminate
    ##             pitch
    "fall"
  | 
    ## "lip slur" to lower pitch, then return to written pitch
    "bend"
  | 
    ## main note followed by quick upward rise, then descent in pitch (Unicode
    ##             1D187)
    "flip"
  | 
    ## (Unicode 1D188)
    "smear"
  | 
    ## down bow (Unicode 1D1AA)
    "dnbow"
  | 
    ## up bow (Unicode 1D1AB)
    "upbow"
  | 
    ## harmonic (Unicode 1D1AC)
    "harm"
  | 
    ## snap pizzicato (Unicode 1D1AD)
    "snap"
  | 
    ## fingernail (Unicode 1D1B3)
    "fingernail"
  | 
    ## tenuto + staccato (Unicode 1D182)
    "ten-stacc"
  | 
    ## dampen harp string (Unicode 1D1B4)
    "damp"
  | 
    ## dampen all harp strings (Unicode 1D1B5)
    "dampall"
  | 
    ## full (as opposed to stopped) tone
    "open"
  | 
    ## "muffled" tone
    "stop"
  | 
    ## double tongue (Unicode 1D18A)
    "dbltongue"
  | 
    ## triple tongue (Unicode 1D18B)
    "trpltongue"
  | 
    ## use heel (organ pedal)
    "heel"
  | 
    ## use toe (organ pedal)
    "toe"
  | 
    ## percussive effect on guitar string(s)
    "tap"
  | 
    ## left-hand pizzicato
    "lhpizz"
  | 
    ## uninterpreted dot
    "dot"
  | 
    ## uninterpreted stroke
    "stroke"
data.ARTICULATIONS = list { data.ARTICULATION+ }
data.AUGMENTDOT = xsd:nonNegativeInteger { maxInclusive = "4" }
data.BARPLACE =
  
  ## between staves only
  "mensur"
  | 
    ## between and across staves as necessary
    "staff"
  | 
    ## short line above staff or through top line
    "takt"
data.BARRENDITION =
  
  ## dashed line (Unicode 1D104)
  "dashed"
  | 
    ## dotted line
    "dotted"
  | 
    ## (Unicode 1D101)
    "dbl"
  | 
    ## double dashed line
    "dbldashed"
  | 
    ## double dotted line
    "dbldotted"
  | 
    ## (Unicode 1D102)
    "end"
  | 
    ## bar line not rendered
    "invis"
  | 
    ## repeat start (Unicode 1D106)
    "rptstart"
  | 
    ## repeat start and end
    "rptboth"
  | 
    ## repeat end (Unicode 1D107)
    "rptend"
  | 
    ## (Unicode 1D100)
    "single"
data.BEAM = xsd:token { pattern = "[i|m|t][1-6]" }
data.BEAMS = list { data.BEAM+ }
data.BEAT = xsd:decimal { minInclusive = "0" }
data.BEATRPT.REND =
  xsd:positiveInteger { pattern = "4|8|16|32|64|128" }
  | xsd:token { pattern = "mixed" }
data.BEND.AMOUNT =
  xsd:decimal { pattern = "1|\.25|\.5|\.75" }
  | xsd:token { pattern = "full" }
data.BOOLEAN = "true" | "false"
data.CERTAINTY = "high" | "medium" | "low" | "unknown"
data.CLEFLINE = xsd:positiveInteger
data.CLEFSHAPE =
  
  ## G clef (Unicode 1D11E)
  "G"
  | 
    ## Double G clef
    "GG"
  | 
    ## F clef (Unicode 1D122)
    "F"
  | 
    ## C clef (Unicode 1D121)
    "C"
  | 
    ## Drum clef (Unicode 1D125 or Unicode 1D126)
    "perc"
  | 
    ## tablature "clef"; i.e. usually "TAB" rendered
    ##             vertically
    "TAB"
data.CLUSTER =
  
  ## unfilled box
  "whbox"
  | 
    ## filled box
    "blbox"
data.COLOR =
  xsd:token { pattern = "#[0-9A-Fa-f]{6,6}" }
  | xsd:token { pattern = "#[0-9A-Fa-f]{8,8}" }
  | xsd:token {
      pattern =
        "rgb\((\s*(([01]?[0-9]?[0-9])|2[0-4][0-9]|25[0-5])\s*,\s*){2}([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\s*\)"
    }
  | xsd:token {
      pattern =
        "rgba\(\s*(([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\s*,\s*){3}(0(\.\d+)?|1(\.0+)?)\s*\)|rgba\(\s*(((\d{1,2})?%|100%)\s*,\s*){2}(\d{1,2}%|100%)\s*,\s*(0(\.\d+)?|1(\.0+)?)\s*\)"
    }
  | xsd:token {
      pattern =
        "hsl\(\s*((\d{1,2})|[12]\d{2}|3[0-5]\d|360)\s*,\s*(\d{1,2}%|100%)\s*,\s*(\d{1,2}%|100%)\s*\)"
    }
  | xsd:token {
      pattern =
        "hsla\(\s*(\d{1,2}|[12]\d{2}|3[0-5]\d|360)\s*,\s*(\d{1,2}%|100%)\s*,\s*(\d{1,2}%|100%)\s*,\s*(0(\.\d+)?|1(\.0+)?)\s*\)"
    }
  | "aqua"
  | "black"
  | "blue"
  | "fuchsia"
  | "gray"
  | "green"
  | "lime"
  | "maroon"
  | "navy"
  | "olive"
  | "purple"
  | "red"
  | "silver"
  | "teal"
  | "white"
  | "yellow"
data.COLORS = list { data.COLOR+ }
data.CURVERENDITION =
  
  ## default line width
  "narrow"
  | 
    ## twice as wide as normal
    "medium"
  | 
    ## twice as wide as medium
    "wide"
  | 
    ## dashed
    "dashed"
  | 
    ## dotted
    "dotted"
data.DEGREES =
  xsd:decimal { maxInclusive = "360.0" minInclusive = "-360.0" }
data.DURATION = data.DURATION.cmn | data.DURATION.mensural
data.DURATION.additive =
  list {
    xsd:token {
      pattern = "(long|breve|1|2|4|8|16|32|64|128|256|1024|2048)(\.)*"
    }+
  }
data.DURATION.gestural =
  list {
    xsd:token { pattern = "[0-9]+(\.)*r" }+
  }
  | xsd:token { pattern = "[0-9]+((\.)*p|(\.[0-9]+)?(b|s))" }
  | data.DURATION.mensural
data.ENCLOSURE =
  
  ## parentheses
  "paren"
  | 
    ## square brackets
    "brack"
data.FINGER.FRET =
  xsd:positiveInteger { minInclusive = "1" maxInclusive = "4" }
  | xsd:token { pattern = "x|o|t" }
data.FONTFAMILY = xsd:token
data.FONTNAME = xsd:token
data.FONTSIZE = xsd:token { pattern = "\d+(\.\d+)?(pt)?" }
data.FONTSTYLE =
  
  ## text slants to right
  "italic"
  | 
    ## unadorned
    "normal"
  | 
    ## text slants to the left
    "oblique"
data.FONTWEIGHT = "bold" | "normal"
data.FRET =
  xsd:positiveInteger { minInclusive = "1" maxInclusive = "5" }
data.FRETNUMBER =
  xsd:nonNegativeInteger { minInclusive = "1" maxInclusive = "9" }
  | xsd:token { pattern = "o" }
data.GLISSANDO =
  
  ## first note/chord in glissando
  "i"
  | 
    ## note/chord that's neither first nor last in glissando
    "m"
  | 
    ## last note in glissando
    "t"
data.GRACE =
  
  ## time "stolen" from following note
  "acc"
  | 
    ## time "stolen" from previous note
    "unacc"
  | 
    ## no interpretation regarding performed value of grace
    ##             note
    "unknown"
data.HEADSHAPE =
  
  ## filled oval (Unicode 1D158)
  "quarter"
  | 
    ## open oval (Unicode 1D157)
    "half"
  | 
    ## open oval (Unicode 1D15D)
    "whole"
  | 
    ## modern breve (Unicode 1D15C)
    "dblwhole"
  | 
    ## filled diamond (Unicode 1D1BA)
    "filldiamond"
  | 
    ## open diamond (Unicode 1D1B9)
    "diamond"
  | 
    ## double whole diamond (Mup)
    "dwdiamond"
  | 
    ## filled isosceles triangle (Unicode 1D149)
    "fillisotriangle"
  | 
    ## open isosceles triangle (Unicode 1D148)
    "isotriangle"
  | 
    ## double whole open isosceles triangle (Unicode 1D14E)
    "dwhisotriangle"
  | 
    ## filled downward-pointing wedge (Unicode 1D155)
    "fillpiewedge"
  | 
    ## downward-pointing wedge (Unicode 1D154)
    "piewedge"
  | 
    ## double whole downward-pointing wedge (Mup)
    "dwhpiewedge"
  | 
    ## filled rectangle (Unicode 1D147)
    "fillrectangle"
  | 
    ## open rectangle (Unicode 1D146)
    "rectangle"
  | 
    ## double whole open rectangle (Mup)
    "dwhrectangle"
  | 
    ## filled right triangle (Unicode 1D14B)
    "fillrtriangle"
  | 
    ## open right triangle (Unicode 1D14A)
    "rtriangle"
  | 
    ## double whole right triangle (Mup)
    "dwrtriangle"
  | 
    ## filled upper right triangle (Unicode 1D151)
    "fillurtriangle"
  | 
    ## open upper right triangle (Unicode 1D150)
    "urtriangle"
  | 
    ## double whole upper right triangle
    "dwurtriangle"
  | 
    ## filled semi-circle (Unicode 1D153)
    "fillsemicircle"
  | 
    ## open semi-circle (Unicode 1D152)
    "semicircle"
  | 
    ## double whole open semi-circle (Mup)
    "dwsemicircle"
  | 
    ## filled slash (Mup)
    "fillslash"
  | 
    ## open slash (Mup)
    "slash"
  | 
    ## double whole open slash (Mup)
    "dwslash"
  | 
    ## X (Unicode 1D143)
    "x"
  | 
    ## note head not rendered (Unicode 1D159)
    "blank"
  | 
    ## X within circle (Unicode 1D145)
    "circlex"
  | 
    ## plus sign (Unicode 1D144)
    "cross"
  | 
    ## added diagonal slash (/) through default note head
    "addslash"
  | 
    ## added diagonal backslash (\) through default note head
    ##             (MusicXML)
    "addbackslash (MusicXML)"
data.INEUMEFORM =
  
  ##
  "liquescent1"
  | 
    ##
    "liquescent2"
  | 
    ##
    "tied"
  | 
    ##
    "tiedliquescent1"
  | 
    ##
    "tiedliquescent2"
data.INEUMENAME =
  
  ##
  "pessubpunctis"
  | 
    ##
    "climacus"
  | 
    ##
    "scandicus"
  | 
    ##
    "bistropha"
  | 
    ##
    "tristropha"
  | 
    ##
    "pressusminor"
  | 
    ##
    "pressusmaior"
data.INTERVAL.AMOUNT =
  xsd:decimal
  | xsd:token { pattern = "u|d|s" }
  | xsd:token { pattern = "(\+|\-)?[AdMmP][0-9]+" }
data.ISODATE =
  xsd:date
  | xsd:gYear
  | xsd:gMonth
  | xsd:gDay
  | xsd:gYearMonth
  | xsd:gMonthDay
  | xsd:time
  | xsd:dateTime
  | xsd:token { pattern = "[0-9.,DHMPRSTWYZ/:+\-]+" }
data.ISOTIME = xsd:time
data.KEYSIGNATURE = xsd:token { pattern = "mixed|0|[1-7][f|s]" }
data.LAYERSCHEME =
  
  ## single layer
  "1"
  | 
    ## two layers with opposing stems
    "2o"
  | 
    ## two layers with 'floating' stems
    "2f"
  | 
    ##
    "3o"
  | 
    ##
    "3f"
data.LIGATUREFORM =
  
  ## notes are "squeezed" together
  "recta"
  | 
    ## individual notes are replaced by an oblique figure
    "obliqua"
data.LINERENDITION =
  
  ## default line width
  "narrow"
  | 
    ## twice as wide as narrow
    "medium"
  | 
    ## twice as wide as medium
    "wide"
  | 
    ## dashed line
    "dashed"
  | 
    ## dotted line
    "dotted"
  | 
    ## undulating line
    "wavy"
data.MEASUREBEAT =
  xsd:token { pattern = "([0-9]+m\s*\+\s*)?[0-9]+(\.?[0-9]*)?" }
data.MEASUREMENT =
  xsd:token { pattern = "(\+|-)?\d+(\.\d+)?(cm|mm|in|pt|pc|vu)?" }
data.MELODICFUNCTION =
  
  ## accented lower neighbor
  "aln"
  | 
    ## anticipation
    "ant"
  | 
    ## appogiatura
    "app"
  | 
    ## accented passing tone
    "apt"
  | 
    ## arpeggio tone (chordal tone)
    "arp"
  | 
    ## arpeggio tone (7th added to the chord)
    "arp7"
  | 
    ## accented upper neighbor
    "aun"
  | 
    ## changing tone
    "chg"
  | 
    ## chromatic lower neighbor
    "cln"
  | 
    ## chord tone (i.e., not an embellishment)
    "ct"
  | 
    ## chord tone (7th added to the chord)
    "ct7"
  | 
    ## chromatic upper neighbor
    "cun"
  | 
    ## chromatic unaccented passing tone
    "cup"
  | 
    ## escape tone
    "et"
  | 
    ## lower neighbor
    "ln"
  | 
    ## pedal tone
    "ped"
  | 
    ## repeated tone
    "rep"
  | 
    ## retardation
    "ret"
  | 
    ## 2-3 retardation
    "23ret"
  | 
    ## 7-8 retardation
    "78ret"
  | 
    ## suspension
    "sus"
  | 
    ## 4-3 suspension
    "43sus"
  | 
    ## 9-8 suspension
    "98sus"
  | 
    ## 7-6 suspension
    "76sus"
  | 
    ## upper neighbor
    "un"
  | 
    ## upper neighbor (7th added to the chord)
    "un7"
  | 
    ## unaccented passing tone
    "upt"
  | 
    ## unaccented passing tone (7th added to the chord)
    "upt7"
data.MENSURATIONSIGN =
  
  ## tempus imperfectum
  "C"
  | 
    ## tempus perfectum
    "O"
data.METERSIGN =
  
  ## common time; i.e. 4/4
  "common"
  | 
    ## cut time; i.e. 2/2
    "cut"
data.MIDICHANNEL = xsd:positiveInteger { maxInclusive = "16" }
data.MIDINAMES =
  
  ## Program #0
  "Acoustic_Grand_Piano"
  | 
    ## Program #1
    "Bright_Acoustic_Piano"
  | 
    ## Program #2
    "Electric_Grand_Piano"
  | 
    ## Program #3
    "Honky-tonk_Piano"
  | 
    ## Program #4
    "Electric_Piano_1"
  | 
    ## Program #5
    "Electric_Piano_2"
  | 
    ## Program #6
    "Harpsichord"
  | 
    ## Program #7
    "Clavi"
  | 
    ## Program #8
    "Celesta"
  | 
    ## Program #9
    "Glockenspiel"
  | 
    ## Program #10
    "Music_Box"
  | 
    ## Program #11
    "Vibraphone"
  | 
    ## Program #12
    "Marimba"
  | 
    ## Program #13
    "Xylophone"
  | 
    ## Program #14
    "Tubular_Bells"
  | 
    ## Program #15
    "Dulcimer"
  | 
    ## Program #16
    "Drawbar_Organ"
  | 
    ## Program #17
    "Percussive_Organ"
  | 
    ## Program #18
    "Rock_Organ"
  | 
    ## Program #19
    "Church_Organ"
  | 
    ## Program #20
    "Reed_Organ"
  | 
    ## Program #21
    "Accordion"
  | 
    ## Program #22
    "Harmonica"
  | 
    ## Program #23
    "Tango_Accordion"
  | 
    ## Program #24
    "Acoustic_Guitar_nylon"
  | 
    ## Program #25
    "Acoustic_Guitar_steel"
  | 
    ## Program #26
    "Electric_Guitar_jazz"
  | 
    ## Program #27
    "Electric_Guitar_clean"
  | 
    ## Program #28
    "Electric_Guitar_muted"
  | 
    ## Program #29
    "Overdriven_Guitar"
  | 
    ## Program #30
    "Distortion_Guitar"
  | 
    ## Program #31
    "Guitar_harmonics"
  | 
    ## Program #32
    "Acoustic_Bass"
  | 
    ## Program #33
    "Electric_Bass_finger"
  | 
    ## Program #34
    "Electric_Bass_pick"
  | 
    ## Program #35
    "Fretless_Bass"
  | 
    ## Program #36
    "Slap_Bass_1"
  | 
    ## Program #37
    "Slap_Bass_2"
  | 
    ## Program #38
    "Synth_Bass_1"
  | 
    ## Program #39
    "Synth_Bass_2"
  | 
    ## Program #40
    "Violin"
  | 
    ## Program #41
    "Viola"
  | 
    ## Program #42
    "Cello"
  | 
    ## Program #43
    "Contrabass"
  | 
    ## Program #44
    "Tremolo_Strings"
  | 
    ## Program #45
    "Pizzicato_Strings"
  | 
    ## Program #46
    "Orchestral_Harp"
  | 
    ## Program #47
    "Timpani"
  | 
    ## Program #48
    "String_Ensemble_1"
  | 
    ## Program #49
    "String_Ensemble_2"
  | 
    ## Program #50
    "SynthStrings_1"
  | 
    ## Program #51
    "SynthStrings_2"
  | 
    ## Program #52
    "Choir_Aahs"
  | 
    ## Program #53
    "Voice_Oohs"
  | 
    ## Program #54
    "Synth_Voice"
  | 
    ## Program #55
    "Orchestra_Hit"
  | 
    ## Program #56
    "Trumpet"
  | 
    ## Program #57
    "Trombone"
  | 
    ## Program #58
    "Tuba"
  | 
    ## Program #59
    "Muted_Trumpet"
  | 
    ## Program #60
    "French_Horn"
  | 
    ## Program #61
    "Brass_Section"
  | 
    ## Program #62
    "SynthBrass_1"
  | 
    ## Program #63
    "SynthBrass_2"
  | 
    ## Program #64
    "Soprano_Sax"
  | 
    ## Program #65
    "Alto_Sax"
  | 
    ## Program #66
    "Tenor_Sax"
  | 
    ## Program #67
    "Baritone_Sax"
  | 
    ## Program #68
    "Oboe"
  | 
    ## Program #69
    "English_Horn"
  | 
    ## Program #70
    "Bassoon"
  | 
    ## Program #71
    "Clarinet"
  | 
    ## Program #72
    "Piccolo"
  | 
    ## Program #73
    "Flute"
  | 
    ## Program #74
    "Recorder"
  | 
    ## Program #75
    "Pan_Flute"
  | 
    ## Program #76
    "Blown_Bottle"
  | 
    ## Program #77
    "Shakuhachi"
  | 
    ## Program #78
    "Whistle"
  | 
    ## Program #79
    "Ocarina"
  | 
    ## Program #80
    "Lead_1_square"
  | 
    ## Program #81
    "Lead_2_sawtooth"
  | 
    ## Program #82
    "Lead_3_calliope"
  | 
    ## Program #83
    "Lead_4_chiff"
  | 
    ## Program #84
    "Lead_5_charang"
  | 
    ## Program #85
    "Lead_6_voice"
  | 
    ## Program #86
    "Lead_7_fifths"
  | 
    ## Program #87
    "Lead_8_bass_and_lead"
  | 
    ## Program #88
    "Pad_1_new_age"
  | 
    ## Program #89
    "Pad_2_warm"
  | 
    ## Program #90
    "Pad_3_polysynth"
  | 
    ## Program #91
    "Pad_4_choir"
  | 
    ## Program #92
    "Pad_5_bowed"
  | 
    ## Program #93
    "Pad_6_metallic"
  | 
    ## Program #94
    "Pad_7_halo"
  | 
    ## Program #95
    "Pad_8_sweep"
  | 
    ## Program #96
    "FX_1_rain"
  | 
    ## Program #97
    "FX_2_soundtrack"
  | 
    ## Program #98
    "FX_3_crystal"
  | 
    ## Program #99
    "FX_4_atmosphere"
  | 
    ## Program #100
    "FX_5_brightness"
  | 
    ## Program #101
    "FX_6_goblins"
  | 
    ## Program #102
    "FX_7_echoes"
  | 
    ## Program #103
    "FX_8_sci-fi"
  | 
    ## Program #104
    "Sitar"
  | 
    ## Program #105
    "Banjo"
  | 
    ## Program #106
    "Shamisen"
  | 
    ## Program #107
    "Koto"
  | 
    ## Program #108
    "Kalimba"
  | 
    ## Program #109
    "Bagpipe"
  | 
    ## Program #110
    "Fiddle"
  | 
    ## Program #111
    "Shanai"
  | 
    ## Program #112
    "Tinkle_Bell"
  | 
    ## Program #113
    "Agogo"
  | 
    ## Program #114
    "Steel_Drums"
  | 
    ## Program #115
    "Woodblock"
  | 
    ## Program #116
    "Taiko_Drum"
  | 
    ## Program #117
    "Melodic_Tom"
  | 
    ## Program #118
    "Synth_Drum"
  | 
    ## Program #119
    "Reverse_Cymbal"
  | 
    ## Program #120
    "Guitar_Fret_Noise"
  | 
    ## Program #121
    "Breath_Noise"
  | 
    ## Program #122
    "Seashore"
  | 
    ## Program #123
    "Bird_Tweet"
  | 
    ## Program #124
    "Telephone_Ring"
  | 
    ## Program #125
    "Helicopter"
  | 
    ## Program #126
    "Applause"
  | 
    ## Program #127
    "Gunshot"
  | 
    ## Key #35
    "Acoustic_Bass_Drum"
  | 
    ## Key #36
    "Bass_Drum_1"
  | 
    ## Key #37
    "Side_Stick"
  | 
    ## Key #38
    "Acoustic_Snare"
  | 
    ## Key #39
    "Hand_Clap"
  | 
    ## Key #40
    "Electric_Snare"
  | 
    ## Key #41
    "Low_Floor_Tom"
  | 
    ## Key #42
    "Closed_Hi_Hat"
  | 
    ## Key #43
    "High_Floor_Tom"
  | 
    ## Key #44
    "Pedal_Hi-Hat"
  | 
    ## Key #45
    "Low_Tom"
  | 
    ## Key #46
    "Open_Hi-Hat"
  | 
    ## Key #47
    "Low-Mid_Tom"
  | 
    ## Key #48
    "Hi-Mid_Tom"
  | 
    ## Key #49
    "Crash_Cymbal_1"
  | 
    ## Key #50
    "High_Tom"
  | 
    ## Key #51
    "Ride_Cymbal_1"
  | 
    ## Key #52
    "Chinese_Cymbal"
  | 
    ## Key #53
    "Ride_Bell"
  | 
    ## Key #54
    "Tambourine"
  | 
    ## Key #55
    "Splash_Cymbal"
  | 
    ## Key #56
    "Cowbell"
  | 
    ## Key #57
    "Crash_Cymbal_2"
  | 
    ## Key #58
    "Vibraslap"
  | 
    ## Key #59
    "Ride_Cymbal_2"
  | 
    ## Key #60
    "Hi_Bongo"
  | 
    ## Key #61
    "Low_Bongo"
  | 
    ## Key #62
    "Mute_Hi_Conga"
  | 
    ## Key #63
    "Open_Hi_Conga"
  | 
    ## Key #64
    "Low_Conga"
  | 
    ## Key #65
    "High_Timbale"
  | 
    ## Key #66
    "Low_Timbale"
  | 
    ## Key #67
    "High_Agogo"
  | 
    ## Key #68
    "Low_Agogo"
  | 
    ## Key #69
    "Cabasa"
  | 
    ## Key #70
    "Maracas"
  | 
    ## Key #71
    "Short_Whistle"
  | 
    ## Key #72
    "Long_Whistle"
  | 
    ## Key #73
    "Short_Guiro"
  | 
    ## Key #74
    "Long_Guiro"
  | 
    ## Key #75
    "Claves"
  | 
    ## Key #76
    "Hi_Wood_Block"
  | 
    ## Key #77
    "Low_Wood_Block"
  | 
    ## Key #78
    "Mute_Cuica"
  | 
    ## Key #79
    "Open_Cuica"
  | 
    ## Key #80
    "Mute_Triangle"
  | 
    ## Key #81
    "Open_Triangle"
data.MIDITEMPO =
  xsd:positiveInteger { minInclusive = "10" maxInclusive = "1000" }
data.MIDIVALUE = xsd:nonNegativeInteger { maxInclusive = "127" }
data.MODE =
  "major"
  | "minor"
  | "dorian"
  | "phrygian"
  | "lydian"
  | "mixolydian"
  | "aeolian"
  | "locrian"
data.MODUSMAIOR =
  xsd:positiveInteger { minInclusive = "2" maxInclusive = "3" }
data.MODUSMINOR =
  xsd:positiveInteger { minInclusive = "2" maxInclusive = "3" }
data.MUSICFONT = xsd:token
data.OCTAVE = xsd:nonNegativeInteger { maxInclusive = "9" }
data.OCTAVE.DIS = xsd:positiveInteger { pattern = "8|15|22" }
data.ORIENTATION = xsd:token { pattern = "reversed|90CW|90CCW" }
data.OTHERSTAFF = "above" | "below"
data.PAGE.PANELS =
  xsd:positiveInteger { minInclusive = "1" maxInclusive = "2" }
data.PERCENT = xsd:token { pattern = "[0-9]+(\.?[0-9]*)?%" }
data.PGSCALE = data.PERCENT
data.PITCHCLASS = xsd:nonNegativeInteger { maxInclusive = "11" }
data.PITCHNAME = xsd:token { pattern = "[a-g]" }
data.PITCHNAME.GES = xsd:token { pattern = "[a-g]|none" }
data.PITCHNUMBER = xsd:nonNegativeInteger
data.PLACE = "above" | "below"
data.PROLATIO =
  xsd:positiveInteger { minInclusive = "2" maxInclusive = "3" }
data.SCALEDEGREE = xsd:token { pattern = "(\^|v)?[1-7](\+|\-)?" }
data.SIZE =
  
  ## default size
  "normal"
  | 
    ## reduced size
    "cue"
data.SLASH =
  xsd:positiveInteger { minInclusive = "1" maxInclusive = "6" }
data.SLUR = xsd:token { pattern = "[i|m|t][1-6]" }
data.SLURS = list { data.SLUR+ }
data.STAFFLOC = xsd:integer
data.STAFFREL =
  
  ## written above staff
  "above"
  | 
    ## written below staff
    "below"
  | 
    ## written on staff
    "within"
data.STEMDIRECTION =
  
  ## stem points upward
  "up"
  | 
    ## stem points downward
    "down"
data.STEMMODIFIER =
  
  ## 1 slash through stem
  "1slash"
  | 
    ## 2 slashes through stem
    "2slash"
  | 
    ## 3 slashes through stem
    "3slash"
  | 
    ## 4 slashes through stem
    "4slash"
  | 
    ## 5 slashes through stem
    "5slash"
  | 
    ## 6 slashes through stem
    "6slash"
  | 
    ## X placed on stem
    "sprech"
  | 
    ## Z placed on stem
    "z"
data.STEMPOSITION =
  
  ## stem attached to left side of note head
  "left"
  | 
    ## stem attached to right side of note head
    "right"
  | 
    ## stem is originates from center of note head
    "center"
data.STRINGNUMBER = xsd:positiveInteger
data.TEMPERAMENT =
  
  ## equal or 12-tone temperament
  "equal"
  | 
    ## just intonation
    "just"
  | 
    ## meantone intonation
    "mean"
  | 
    ## pythagorean tuning
    "pythagorean"
data.TEMPOVALUE = xsd:positiveInteger
data.TEMPUS =
  xsd:positiveInteger { minInclusive = "2" maxInclusive = "3" }
data.TEXTRENDITION =
  list {
    (
     ## relative font size
     "xx-small"
     | 
       ## relative font size
       "x-small"
     | 
       ## relative font size
       "small"
     | 
       ## relative font size
       "medium"
     | 
       ## relative font size
       "large"
     | 
       ## relative font size
       "x-large"
     | 
       ## relative font size
       "xx-large"
     | 
       ## relative font size
       "smaller"
     | 
       ## relative font size
       "larger"
     | 
       ## italicized (slanted to right)
       "italic"
     | 
       ## oblique (slanted to left)
       "oblique"
     | 
       ## small capitals
       "smcaps"
     | 
       ## relative font weight
       "bold"
     | 
       ## relative font weight
       "bolder"
     | 
       ## relative font weight
       "lighter"
     | 
       ## enclosed in box
       "box"
     | 
       ## enclosed in ellipse/circle
       "circle"
     | 
       ## enclosed in diamond
       "dbox"
     | 
       ## enclosed in triangle
       "tbox"
     | 
       ## struck through by '\' (back slash)
       "bslash"
     | 
       ## struck through by '/' (forward slash)
       "fslash"
     | 
       ## struck through by '-'; may be qualified to indicate multiple lines,
       ##                 e.g. line-through(2)
       "line-through"
     | 
       ## not rendered, invisible
       "none"
     | 
       ## line above the text; may be qualified to indicate multiple lines,
       ##                 e.g. overline(3)
       "overline"
     | 
       ## struck through by '-'; equivalent to line-through; may be qualified
       ##                 to indicate multiple lines, e.g. strike(3)
       "strike"
     | 
       ## subscript
       "sub"
     | 
       ## superscript
       "sup"
     | 
       ## underlined; may be qualified to indicate multiple lines, e.g.
       ##                 underline(2)
       "underline"
     | 
       ## left-to-right (BIDI embed)
       "ltr"
     | 
       ## right-to-left (BIDI embed)
       "rtl"
     | 
       ## eft-to-right (BIDI override)
       "lro"
     | 
       ## right-to-left (BIDI override)
       "rlo"
     | xsd:string {
         pattern =
           "(underline|overline|line-through|strike|letter-spacing|line-height)\(\d+\)"
       }
     | xsd:string {
         pattern = "(letter-spacing|line-height)\((\+|-)?\d+(\.\d+)?\)"
       })+
  }
data.TIE = xsd:token { pattern = "[i|m|t]" }
data.TIES = list { data.TIE+ }
data.TSTAMPOFFSET = xsd:decimal
data.TUPLET = xsd:token { pattern = "[i|m|t][1-6]" }
data.TUPLETS = list { data.TUPLET+ }
data.UNEUMEFORM =
  
  ##
  "liquescent1"
  | 
    ##
    "liquescent2"
  | 
    ##
    "liquescent3"
  | 
    ##
    "quilismatic"
  | 
    ##
    "rectangular"
  | 
    ##
    "rhombic"
  | 
    ##
    "tied"
data.UNEUMENAME =
  
  ##
  "punctum"
  | 
    ##
    "virga"
  | 
    ##
    "pes"
  | 
    ##
    "clivis"
  | 
    ##
    "torculus"
  | 
    ##
    "torculusresupinus"
  | 
    ##
    "porrectus"
  | 
    ##
    "porrectusflexus"
  | 
    ##
    "apostropha"
  | 
    ##
    "oriscus"
  | 
    ##
    "pressusmaior"
  | 
    ##
    "pressusminor"
  | 
    ##
    "virgastrata"
data.URI = xsd:anyURI
data.URIS = list { data.URI* }
macro.metaLike.page = fw*, pgDesc?
macro.musicPart = model.frontLike?, (body | group)?, model.backLike?
macro.availabilityPart =
  (acqSource, (accessRestrict, price?)*)*,
  useRestrict?,
  sysReq?
macro.bibldescPart =
  editionStmt?, pubStmt?, physDesc?, physLoc*, seriesStmt?
data.DURATION.cmn =
  
  ## quadruple whole note
  "long"
  | 
    ## double whole note
    "breve"
  | 
    ## whole note
    "1"
  | 
    ## half note
    "2"
  | 
    ## quarter note
    "4"
  | 
    ## 8th note
    "8"
  | 
    ## 16th note
    "16"
  | 
    ## 32nd note
    "32"
  | 
    ## 64th note
    "64"
  | 
    ## 128th note
    "128"
  | 
    ## 256th note
    "256"
  | 
    ## 512th note
    "512"
  | 
    ## 1024th note
    "1024"
  | 
    ## 2048th note
    "2048"
data.DURATION.mensural =
  "maxima"
  | "longa"
  | "brevis"
  | "semibrevis"
  | "minima"
  | "semiminima"
  | "fusa"
  | "semifusa"
macro.neumeModifierLike = empty
data.ORNAM.cmn =
  xsd:token {
    pattern =
      "[A|a|b|I|i|K|k|M|m|N|n|S|s|T|t|O]|(A|a|S|s|K|k)?(T|t|M|m)(I|i|S|s)?"
  }
data.ORNAMS.cmn = list { data.ORNAM.cmn+ }
data.DURATION.tabcode =
  
  ## Fermata
  "F"
  | 
    ## Breve
    "B"
  | 
    ## Semibreve (whole note)
    "W"
  | 
    ## Minim (half note)
    "H"
  | 
    ## Dotted minim (half note)
    "H."
  | 
    ## Crotchet (quarter note)
    "Q"
  | 
    ## Dotted crotchet (quarter note)
    "Q."
  | 
    ## Quaver (eight note)
    "E"
  | 
    ## Dotted quaver (eight note)
    "E."
  | 
    ## Semiquaver (sixteenth note)
    "S"
  | 
    ## Dotted semiquaver (sixteenth note)
    "S."
  | 
    ## Demisemiquaver (thirtysecond note)
    "T"
  | 
    ## Dotted demisemiquaver (thirtysecond note)
    "T."
  | 
    ## Hemidemisemiquaver (sixtyfourth note)
    "Y"
  | 
    ## Dotted hemidemisemiquaver (sixtyfourth note)
    "Y."
  | 
    ## Semihemidemisemiquaver (one hundred and twentyeighth note)
    "Z"
  | 
    ## Dotted semihemidemisemiquaver (one hundred and twentyeighth note)
    "Z."
att.accid.anl.attributes = att.common.anl.attributes
att.accid.ges.attributes = empty
att.accid.log.attributes =
  att.accidental.attributes,
  att.controlevent.attributes,
  att.accid.log.attribute.func
att.accid.log.attribute.func =
  
  ## records the function of an accidental.
  attribute func {
    
    ## cautionary accidental.
    "caution"
    | 
      ## editorial accidental.
      "edit"
  }?
att.accid.vis.attributes =
  att.color.attributes,
  att.enclosingchars.attributes,
  att.placement.attributes,
  att.staffloc.attributes,
  att.visualoffset.ho.attributes,
  att.visualoffset.vo.attributes,
  att.xy.attributes,
  att.accid.vis.mensural.attributes
att.accidental.attributes = att.accidental.attribute.accid
att.accidental.attribute.accid =
  
  ## captures a written accidental.
  attribute accid { data.ACCIDENTAL.EXPLICIT }?
att.accidental.performed.attributes =
  att.accidental.performed.attribute.accid.ges
att.accidental.performed.attribute.accid.ges =
  
  ## records the performed pitch inflection when it differs from the written accidental.
  attribute accid.ges { data.ACCIDENTAL.IMPLICIT }?
att.altsym.attributes = att.altsym.attribute.altsym
att.altsym.attribute.altsym =
  
  ## provides a way of pointing to a user-defined symbol. It must contain an ID of a <symbolDef> element elsewhere in the document.
  attribute altsym { data.URI }?
att.annot.anl.attributes = att.common.anl.attributes
att.annot.ges.attributes = att.duration.performed.attributes
att.annot.log.attributes =
  att.augmentdots.attributes,
  att.duration.additive.attributes,
  att.layerident.attributes,
  att.staffident.attributes,
  att.startendid.attributes,
  att.timestamp.musical.attributes,
  att.timestamp2.musical.attributes,
  att.timestamp.performed.attributes
att.annot.vis.attributes = empty
att.artic.anl.attributes = att.common.anl.attributes
att.artic.ges.attributes = empty
att.artic.log.attributes =
  att.articulation.attributes, att.controlevent.attributes
att.artic.vis.attributes =
  att.color.attributes,
  att.enclosingchars.attributes,
  att.placement.attributes,
  att.staffloc.attributes,
  att.visualoffset.attributes,
  att.xy.attributes
att.articulation.attributes = att.articulation.attribute.artic
att.articulation.attribute.artic =
  
  ## encodes the written articulation(s). Articulations are normally encoded in order from the note head outward; that is, away from the stem. See additional notes at att.vis.note. Only articulations should be encoded in the artic attribute; fingerings should be encoded using the <dir> element.
  attribute artic { data.ARTICULATIONS }?
att.articulation.performed.attributes =
  att.articulation.performed.attribute.artic.ges
att.articulation.performed.attribute.artic.ges =
  
  ## records performed articulation that differs from the written value.
  attribute artic.ges { data.ARTICULATIONS }?
att.augmentdots.attributes = att.augmentdots.attribute.dots
att.augmentdots.attribute.dots =
  
  ## records the number of augmentation dots required by a dotted duration.
  attribute dots { data.AUGMENTDOT }?
sch:pattern [
  id =
    "mei-att.augmentdots-dots-dots_attribute_requires_dur-constraint-1"
  "\x{a}" ~
  "    "
  sch:rule [
    context = "mei:*[@dots]"
    "\x{a}" ~
    "      "
    sch:assert [
      test = "@dur"
      "An element with a dots attribute must also have a dur\x{a}" ~
      "                  attribute."
    ]
    "\x{a}" ~
    "    "
  ]
  "\x{a}" ~
  "  "
]
att.authorized.attributes =
  att.authorized.attribute.authority, att.authorized.attribute.authURI
att.authorized.attribute.authority =
  
  ## a name or label associated with the controlled vocabulary from which the value is taken.
  attribute authority { text }?
att.authorized.attribute.authURI =
  
  ## the web-accessible location of the controlled vocabulary from which the value is taken.
  attribute authURI { data.URI }?
att.barLine.anl.attributes = att.common.anl.attributes
att.barLine.ges.attributes = att.timestamp.musical.attributes
att.barLine.log.attributes =
  att.meterconformance.bar.attributes, att.barLine.log.attribute.rend
att.barLine.log.attribute.rend =
  
  ## records the appearance and usually the function of the bar line.
  attribute rend { data.BARRENDITION }?
att.barLine.vis.attributes =
  att.barplacement.attributes,
  att.color.attributes,
  att.measurement.attributes,
  att.width.attributes
att.barplacement.attributes =
  att.barplacement.attribute.barplace,
  att.barplacement.attribute.taktplace
att.barplacement.attribute.barplace =
  
  ## records the location of a bar line.
  attribute barplace { data.BARPLACE }?
att.barplacement.attribute.taktplace =
  
  ## If takt bar lines are to be used, then the taktplace attribute may be used to denote the staff location of the shortened bar line. The location may include staff lines, spaces, and the spaces directly above and below the staff. The value ranges between 0 (just below the staff) to 2 * number of staff lines (directly above the staff). For example, on a 5-line staff the lines would be numbered 1,3,5,7, and 9 while the spaces would be numbered 0,2,4,6,8,10. For example, a value of '9' puts the bar line through the top line of a 5-line staff.
  attribute taktplace { data.STAFFLOC }?
att.beaming.vis.attributes =
  att.beaming.vis.attribute.beam.color,
  att.beaming.vis.attribute.beam.rend,
  att.beaming.vis.attribute.beam.slope
att.beaming.vis.attribute.beam.color =
  
  ## Color of beams, including those associated with tuplets.
  attribute beam.color { data.COLOR }?
att.beaming.vis.attribute.beam.rend =
  
  ## encodes whether a beam is "feathered" and in which direction.
  attribute beam.rend {
    
    ## beams lines grow farther apart from left to right.
    "acc"
    | 
      ## beam lines grow closer together from left to right.
      "rit"
    | 
      ## beam lines are equally-spaced over the entire length of the beam.
      "norm"
  }?
att.beaming.vis.attribute.beam.slope =
  
  ## captures beam slope.
  attribute beam.slope { xsd:decimal }?
att.bibl.attributes = att.bibl.attribute.analog
att.bibl.attribute.analog =
  
  ## contains a reference to a field or element in another descriptive encoding system to which this MEI element is comparable. 
  attribute analog { text }?
att.calendared.attributes = att.calendared.attribute.calendar
att.calendared.attribute.calendar =
  
  ## indicates the calendar system to which a date belongs, for example, Gregorian, Julian, Roman, Mosaic, Revolutionary, Islamic, etc.
  attribute calendar { xsd:NMTOKEN }?
att.canonical.attributes = att.canonical.attribute.dbkey
att.canonical.attribute.dbkey =
  
  ## used to record a value which serves as a primary key in an external database.
  attribute dbkey { xsd:NMTOKEN }?
att.chord.anl.attributes = att.common.anl.attributes
att.chord.ges.attributes =
  att.articulation.performed.attributes,
  att.duration.performed.attributes,
  att.instrumentident.attributes,
  att.chord.ges.cmn.attributes
att.chord.log.attributes =
  att.event.attributes,
  att.articulation.attributes,
  att.augmentdots.attributes,
  att.duration.musical.attributes,
  att.fermatapresent.attributes,
  att.syltext.attributes,
  att.slurpresent.attributes,
  att.tiepresent.attributes,
  att.tupletpresent.attributes,
  att.chord.log.cmn.attributes
att.chord.vis.attributes =
  att.altsym.attributes,
  att.color.attributes,
  att.relativesize.attributes,
  att.stemmed.attributes,
  att.visibility.attributes,
  att.visualoffset.ho.attributes,
  att.visualoffset.to.attributes,
  att.xy.attributes,
  att.chord.vis.cmn.attributes,
  att.chord.vis.attribute.cluster
att.chord.vis.attribute.cluster =
  
  ## indicates a single alternative note head should be displayed instead of individual note heads. See Read, p. 320-321, re: tone clusters.
  attribute cluster { data.CLUSTER }?
att.clef.anl.attributes = att.common.anl.attributes
att.clef.ges.attributes = empty
att.clef.log.attributes =
  att.clefshape.attributes,
  att.lineloc.attributes,
  att.octave.attributes,
  att.octavedisplacement.attributes,
  att.clef.log.attribute.cautionary
att.clef.log.attribute.cautionary =
  
  ## records the function of the clef. A "cautionary" clef does not change the following pitches.
  attribute cautionary { data.BOOLEAN }?
att.clef.vis.attributes = att.altsym.attributes, att.color.attributes
att.cleffing.log.attributes =
  att.cleffing.log.attribute.clef.shape,
  att.cleffing.log.attribute.clef.line,
  att.cleffing.log.attribute.clef.dis,
  att.cleffing.log.attribute.clef.dis.place
att.cleffing.log.attribute.clef.shape =
  
  ## encodes a value for the clef symbol.
  attribute clef.shape { data.CLEFSHAPE }?
att.cleffing.log.attribute.clef.line =
  
  ## contains a default value for the position of the clef. The value must be in the range between 1 and the number of lines on the staff. The numbering of lines starts with the lowest line of the staff.
  attribute clef.line { data.CLEFLINE }?
att.cleffing.log.attribute.clef.dis =
  
  ## records the amount of octave displacement to be applied to the clef.
  attribute clef.dis { data.OCTAVE.DIS }?
att.cleffing.log.attribute.clef.dis.place =
  
  ## records the direction of octave displacement to be applied to the clef.
  attribute clef.dis.place { data.PLACE }?
att.cleffing.vis.attributes =
  att.cleffing.vis.attribute.clef.color,
  att.cleffing.vis.attribute.clef.visible
att.cleffing.vis.attribute.clef.color =
  
  ## describes the color of the clef.
  attribute clef.color { data.COLOR }?
att.cleffing.vis.attribute.clef.visible =
  
  ## determines whether the clef is to be displayed.
  attribute clef.visible { data.BOOLEAN }?
att.clefGrp.anl.attributes = att.common.anl.attributes
att.clefGrp.ges.attributes = empty
att.clefGrp.log.attributes = empty
att.clefGrp.vis.attributes = empty
att.clefshape.attributes = att.clefshape.attribute.shape
att.clefshape.attribute.shape =
  
  ## describes a clef's shape.
  attribute shape { data.CLEFSHAPE }?
att.coded.attributes = att.coded.attribute.code
att.coded.attribute.code =
  
  ## captures one or more coded values for the textual content of this element.
  attribute code { xsd:NMTOKENS }?
att.color.attributes = att.color.attribute.color
att.color.attribute.color =
  
  ## used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
  attribute color { data.COLOR }?
att.coloration.attributes = att.coloration.attribute.colored
att.coloration.attribute.colored =
  
  ## indicates this feature is 'colored'; that is, it is a participant in a change in rhythmic values. In mensural notation, coloration is indicated by colored notes (red, black, etc.) where void notes would otherwise occur. In CMN, coloration is indicated by an inverse color; that is, the note head is void when it would otherwise be filled and vice versa.
  attribute colored { data.BOOLEAN }?
att.common.attributes =
  att.id.attributes,
  att.common.attribute.label,
  att.common.attribute.n,
  att.common.attribute.xmlbase
att.common.attribute.label =
  
  ## provides a label for an element. The value may be any string.
  attribute label { text }?
att.common.attribute.n =
  
  ## provides a name or number designation for an element. While the value need not be unique, it is required to be a single token.
  attribute n { xsd:NMTOKEN }?
att.common.attribute.xmlbase =
  
  ## provides a base URI reference with which applications can resolve relative URI references into absolute URI references.
  attribute xml:base { data.URI }?
att.controlevent.attributes =
  att.plist.attributes,
  att.timestamp.musical.attributes,
  att.timestamp.performed.attributes,
  att.staffident.attributes,
  att.layerident.attributes
att.coordinated.attributes =
  att.coordinated.attribute.ulx,
  att.coordinated.attribute.uly,
  att.coordinated.attribute.lrx,
  att.coordinated.attribute.lry
att.coordinated.attribute.ulx =
  
  ## indicates the upper-left corner x coordinate.
  attribute ulx { xsd:nonNegativeInteger }?
att.coordinated.attribute.uly =
  
  ## indicates the upper-left corner y coordinate.
  attribute uly { xsd:nonNegativeInteger }?
att.coordinated.attribute.lrx =
  
  ## indicates the lower-right corner x coordinate.
  attribute lrx { xsd:nonNegativeInteger }?
att.coordinated.attribute.lry =
  
  ## indicates the lower-left corner x coordinate.
  attribute lry { xsd:nonNegativeInteger }?
att.curvature.attributes =
  att.curvature.attribute.bezier,
  att.curvature.attribute.bulge,
  att.curvature.attribute.curvedir
att.curvature.attribute.bezier =
  
  ## records the placement of Bezier control points as a series of space-separated xy coordinates, e.g., 19 45 -32 118.
  attribute bezier { text }?
att.curvature.attribute.bulge =
  
  ## describes a curve as a set of distance values above or below an imaginary line connecting the endpoints of the curve. The bulge attribute must contain one or more decimal values expressed in inter-line units.
  attribute bulge { text }?
att.curvature.attribute.curvedir =
  
  ## describes a curve with a generic term indicating the direction of curvature.
  attribute curvedir {
    
    ## upward curve.
    "above"
    | 
      ## downward curve.
      "below"
  }?
att.curverend.attributes = att.curverend.attribute.rend
att.curverend.attribute.rend =
  
  ## describes the line style of the curve.
  attribute rend { data.CURVERENDITION }?
att.custos.anl.attributes = att.common.anl.attributes
att.custos.ges.attributes = empty
att.custos.log.attributes =
  att.pitched.attributes, att.custos.log.attribute.target
att.custos.log.attribute.target =
  
  ## encodes the target note when its pitch differs from the pitch at which the custos appears.
  attribute target { data.URI }?
att.custos.vis.attributes =
  att.altsym.attributes, att.color.attributes, att.staffloc.attributes
att.datable.attributes =
  att.datable.attribute.enddate,
  att.datable.attribute.isodate,
  att.datable.attribute.notafter,
  att.datable.attribute.notbefore,
  att.datable.attribute.startdate
att.datable.attribute.enddate =
  
  ## contains the end point of a date range in standard ISO form.
  attribute enddate { data.ISODATE }?
att.datable.attribute.isodate =
  
  ## provides the value of a textual date in standard ISO form.
  attribute isodate { data.ISODATE }?
att.datable.attribute.notafter =
  
  ## contains an upper boundary for an uncertain date in standard ISO form.
  attribute notafter { data.ISODATE }?
att.datable.attribute.notbefore =
  
  ## contains a lower boundary, in standard ISO form, for an uncertain date.
  attribute notbefore { data.ISODATE }?
att.datable.attribute.startdate =
  
  ## contains the starting point of a date range in standard ISO form.
  attribute startdate { data.ISODATE }?
att.datapointing.attributes = att.datapointing.attribute.data
att.datapointing.attribute.data =
  
  ## used to link metadata elements to one or more data-containing elements.
  attribute data { data.URIS }?
att.declaring.attributes = att.declaring.attribute.decls
att.declaring.attribute.decls =
  
  ## identifies one or more metadata elements within the header, which are understood to apply to the element bearing this attribute and its content.
  attribute decls { data.URIS }?
att.dir.anl.attributes = att.common.anl.attributes
att.dir.ges.attributes = att.duration.performed.attributes
att.dir.log.attributes =
  att.controlevent.attributes,
  att.augmentdots.attributes,
  att.duration.additive.attributes,
  att.startendid.attributes,
  att.timestamp2.musical.attributes
att.dir.vis.attributes =
  att.placement.attributes,
  att.visualoffset.attributes,
  att.visualoffset2.ho.attributes,
  att.visualoffset2.to.attributes,
  att.xy.attributes
att.distances.attributes =
  att.distances.attribute.dynam.dist,
  att.distances.attribute.harm.dist,
  att.distances.attribute.text.dist
att.distances.attribute.dynam.dist =
  
  ## records the default distance from the staff for dynamic marks.
  attribute dynam.dist { data.MEASUREMENT }?
att.distances.attribute.harm.dist =
  
  ## records the default distance from the staff of harmonic indications, such as guitar chord grids or functional labels.
  attribute harm.dist { data.MEASUREMENT }?
att.distances.attribute.text.dist =
  
  ## determines how far from the staff to render text elements.
  attribute text.dist { data.MEASUREMENT }?
att.dot.anl.attributes = att.common.anl.attributes
att.dot.ges.attributes = empty
att.dot.log.attributes =
  att.controlevent.attributes, att.dot.log.attribute.form
att.dot.log.attribute.form =
  
  ## records the function of the dot.
  attribute form {
    
    ## augmentation dot.
    "aug"
    | 
      ## dot of division.
      "div"
  }?
att.dot.vis.attributes =
  att.color.attributes,
  att.staffloc.attributes,
  att.visualoffset.ho.attributes,
  att.visualoffset.vo.attributes,
  att.xy.attributes,
  att.dot.vis.mensural.attributes
att.duration.additive.attributes = att.duration.additive.attribute.dur
att.duration.additive.attribute.dur =
  
  ## records duration using ident dotted, relative durational values provided by the data.DURATION datatype. When the duration is "irrational", as is sometimes the case with tuplets, multiple space-separated values that add up to the total duration may be used. When dotted values are present, the dots attribute must be ignored.
  attribute dur { data.DURATION.additive }
sch:pattern [
  id =
    "mei-att.duration.additive-dur-ignore_dots_attribute-constraint-2"
  "\x{a}" ~
  "    "
  sch:rule [
    context = "mei:*[contains(@dur, '.')]"
    "\x{a}" ~
    "      "
    sch:assert [
      test = "not(@dots)"
      "An element with a dur attribute that contains dotted\x{a}" ~
      "                  values must not have a dots attribute."
    ]
    "\x{a}" ~
    "    "
  ]
  "\x{a}" ~
  "  "
]
att.duration.default.attributes =
  att.duration.default.attribute.dur.default,
  att.duration.default.attribute.num.default,
  att.duration.default.attribute.numbase.default
att.duration.default.attribute.dur.default =
  
  ## contains a default duration in those situations when the first note, rest, chord, etc. in a measure does not have a duration specified.
  attribute dur.default { data.DURATION }?
att.duration.default.attribute.num.default =
  
  ## along with numbase.default, describes the default duration as a ratio. num.default is the first value in the ratio.
  attribute num.default { xsd:positiveInteger }?
att.duration.default.attribute.numbase.default =
  
  ## along with num.default, describes the default duration as a ratio. numbase.default is the second value in the ratio.
  attribute numbase.default { xsd:positiveInteger }?
att.duration.musical.attributes = att.duration.musical.attribute.dur
att.duration.musical.attribute.dur =
  
  ## records the duration of a feature using the relative durational values provided by the data.DURATION datatype.
  attribute dur { data.DURATION }?
att.duration.performed.attributes =
  att.duration.performed.attribute.dur.ges
att.duration.performed.attribute.dur.ges =
  
  ## records performed duration information that differs from the written duration. Its value may be expressed in several forms; that is, ppq (MIDI clicks and MusicXML 'divisions'), Humdrum **recip values, beats, seconds, or mensural duration values.
  attribute dur.ges { data.DURATION.gestural }?
att.duration.ratio.attributes =
  att.duration.ratio.attribute.num, att.duration.ratio.attribute.numbase
att.duration.ratio.attribute.num =
  
  ## along with numbase, describes duration as a ratio. num is the first value in the ratio, while numbase is the second.
  attribute num { xsd:positiveInteger }?
att.duration.ratio.attribute.numbase =
  
  ## along with num, describes duration as a ratio. num is the first value in the ratio, while numbase is the second.
  attribute numbase { xsd:positiveInteger }?
att.dynam.anl.attributes = att.common.anl.attributes
att.dynam.ges.attributes =
  att.duration.performed.attributes, att.midivalue.attributes
att.dynam.log.attributes =
  att.controlevent.attributes,
  att.augmentdots.attributes,
  att.duration.additive.attributes,
  att.startendid.attributes,
  att.timestamp2.musical.attributes
att.dynam.vis.attributes =
  att.placement.attributes,
  att.visualoffset.attributes,
  att.visualoffset2.ho.attributes,
  att.visualoffset2.to.attributes,
  att.xy.attributes
att.enclosingchars.attributes = att.enclosingchars.attribute.enclose
att.enclosingchars.attribute.enclose =
  
  ## records the characters often used to mark accidentals, articulations, and sometimes notes as having a cautionary or editorial function. For an example of cautionary accidentals enclosed in parentheses, see Read, p. 131, ex. 9-14.
  attribute enclose { data.ENCLOSURE }?
att.ending.anl.attributes = att.common.anl.attributes
att.ending.ges.attributes = empty
att.ending.log.attributes = empty
att.ending.vis.attributes = empty
att.event.attributes =
  att.timestamp.musical.attributes,
  att.timestamp.performed.attributes,
  att.staffident.attributes,
  att.layerident.attributes
att.fermatapresent.attributes = att.fermatapresent.attribute.fermata
att.fermatapresent.attribute.fermata =
  
  ## indicates the attachment of a fermata to this element. If visual information about the fermata needs to be recorded, then a <fermata> element should be employed instead.
  attribute fermata { data.PLACE }?
att.grpSym.anl.attributes = att.common.anl.attributes
att.grpSym.ges.attributes = empty
att.grpSym.log.attributes = att.staffgroupingsym.attributes
att.grpSym.vis.attributes =
  att.visualoffset.attributes, att.xy.attributes
att.handident.attributes = att.handident.attribute.hand
att.handident.attribute.hand =
  
  ## signifies the hand responsible for an action. The value must be the ID of a <hand> element declared in the header.
  attribute hand { data.URI }?
att.horizontalalign.attributes = att.horizontalalign.attribute.halign
att.horizontalalign.attribute.halign =
  
  ## records horizontal alignment.
  attribute halign {
    
    ## left aligned.
    "left"
    | 
      ## right aligned.
      "right"
    | 
      ## centered.
      "center"
    | 
      ## left and right aligned.
      "justify"
  }?
att.id.attributes = att.id.attribute.xmlid
att.id.attribute.xmlid =
  
  ## regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
  attribute xml:id { xsd:ID }?
att.instrumentident.attributes = att.instrumentident.attribute.instr
att.instrumentident.attribute.instr =
  
  ## provides a way of pointing to a MIDI instrument definition. It must contain the ID of an <instrDef> element elsewhere in the document.
  attribute instr { data.URI }?
att.internetmedia.attributes = att.internetmedia.attribute.mimetype
att.internetmedia.attribute.mimetype =
  
  ## specifies the applicable MIME (multimedia internet mail extension) type. The value should be a valid MIME media type defined by the Internet Engineering Task Force in RFC 2046.
  attribute mimetype { text }?
att.joined.attributes = att.joined.attribute.join
att.joined.attribute.join =
  
  ## used for linking visually separate entities that form a single logical entity, for example, multiple slurs broken across a system break that form a single musical phrase. Also used to indicate a measure which metrically completes the current one. Record the identifiers of the separately encoded components, excluding the one carrying the attribute.
  attribute join { data.URIS }?
att.keyAccid.anl.attributes = att.common.anl.attributes
att.keyAccid.ges.attributes = empty
att.keyAccid.log.attributes =
  att.accidental.attributes, att.pitched.attributes
att.keyAccid.vis.attributes =
  att.enclosingchars.attributes,
  att.staffloc.attributes,
  att.xy.attributes
att.keySig.anl.attributes = att.common.anl.attributes
att.keySig.ges.attributes = empty
att.keySig.log.attributes =
  att.accidental.attributes,
  att.pitch.attributes,
  att.keySig.log.attribute.mode
att.keySig.log.attribute.mode =
  
  ## indicates major, minor, or other tonality.
  attribute mode { data.MODE }?
att.keySig.vis.attributes = empty
att.keySigDefault.log.attributes =
  att.keySigDefault.log.attribute.key.accid,
  att.keySigDefault.log.attribute.key.mode,
  att.keySigDefault.log.attribute.key.pname,
  att.keySigDefault.log.attribute.key.sig,
  att.keySigDefault.log.attribute.key.sig.mixed
att.keySigDefault.log.attribute.key.accid =
  
  ## contains an accidental for the tonic key, if one is required, e.g., if key.pname equals 'c' and key.accid equals 's', then a tonic of C# is indicated.
  attribute key.accid { data.ACCIDENTAL.IMPLICIT }?
att.keySigDefault.log.attribute.key.mode =
  
  ## indicates major, minor, or other tonality.
  attribute key.mode { data.MODE }?
att.keySigDefault.log.attribute.key.pname =
  
  ## holds the pitch name of the tonic key, e.g. 'c' for the key of C.
  attribute key.pname { data.PITCHNAME }?
att.keySigDefault.log.attribute.key.sig =
  
  ## indicates where the key lies in the circle of fifths.
  attribute key.sig { data.KEYSIGNATURE }?
att.keySigDefault.log.attribute.key.sig.mixed =
  
  ## Mixed key signatures, e.g. those consisting of a mixture of flats and sharps (Read, p. 143, ex. 9-39), and key signatures with unorthodox placement of the accidentals (Read, p. 141) must be indicated by setting the key.sig attribute to 'mixed' and providing explicit key signature information in the key.sig.mixed attribute or in the <keySig> element. It is intended that key.sig.mixed contain a series of tokens with each token containing pitch name, accidental, and octave, such as 'A4 Cs5 Ef5' that indicate what key accidentals should be rendered and where they should be placed.
  attribute key.sig.mixed {
    list {
      xsd:token {
        pattern = "[a-g][0-9](\-{1,3}|f{1,3}|#{1,3}|s{1,3}|x)"
      }+
    }
  }?
att.keySigDefault.vis.attributes =
  att.keySigDefault.vis.attribute.key.sig.show,
  att.keySigDefault.vis.attribute.key.sig.showchange
att.keySigDefault.vis.attribute.key.sig.show =
  
  ## indicates whether the key signature should be displayed.
  attribute key.sig.show { data.BOOLEAN }?
att.keySigDefault.vis.attribute.key.sig.showchange =
  
  ## determines whether cautionary accidentals should be displayed at a key change.
  attribute key.sig.showchange { data.BOOLEAN }?
att.labels.addl.attributes = att.labels.addl.attribute.label.abbr
att.labels.addl.attribute.label.abbr =
  
  ## provides a label for a group of staves on pages after the first page. Usually, this label takes an abbreviated form.
  attribute label.abbr { text }?
att.lang.attributes = att.lang.attribute.xmllang
att.lang.attribute.xmllang =
  
  ## identifies the language of the element's content. The values for this attribute are language 'tags' as defined in BCP 47. All language tags that make use of private use sub-tags must be documented in a corresponding language element in the MEI header whose id attribute is the same as the language tag's value.
  attribute xml:lang { xsd:language }?
att.layer.anl.attributes = att.common.anl.attributes
att.layer.ges.attributes = empty
att.layer.log.attributes =
  att.meterconformance.attributes, att.layer.log.attribute.def
att.layer.log.attribute.def =
  
  ## provides a mechanism for linking the layer to a layerDef element.
  attribute def { data.URI }?
att.layer.vis.attributes = att.visibility.attributes
att.layerDef.anl.attributes = empty
att.layerDef.ges.attributes = att.instrumentident.attributes
att.layerDef.log.attributes =
  att.duration.default.attributes,
  att.octavedefault.attributes,
  att.layerDef.log.cmn.attributes
att.layerDef.vis.attributes =
  att.labels.addl.attributes,
  att.beaming.vis.attributes,
  att.textstyle.attributes,
  att.visibility.attributes
att.layerident.attributes = att.layerident.attribute.layer
att.layerident.attribute.layer =
  
  ## identifies the layer to which a feature applies.
  attribute layer {
    list { xsd:positiveInteger+ }
  }?
att.lineloc.attributes = att.lineloc.attribute.line
att.lineloc.attribute.line =
  
  ## indicates the line upon which a feature stands. The value must be in the range between 1 and the number of lines on the staff. The numbering of lines starts with the lowest line of the staff.
  attribute line { data.CLEFLINE }?
att.linerend.attributes = att.linerend.attribute.rend
att.linerend.attribute.rend =
  
  ## records the appearance of a line.
  attribute rend { data.LINERENDITION }?
att.lyricstyle.attributes =
  att.lyricstyle.attribute.lyric.align,
  att.lyricstyle.attribute.lyric.fam,
  att.lyricstyle.attribute.lyric.name,
  att.lyricstyle.attribute.lyric.size,
  att.lyricstyle.attribute.lyric.style,
  att.lyricstyle.attribute.lyric.weight
att.lyricstyle.attribute.lyric.align =
  
  ## describes the alignment of lyric syllables associated with a note or chord.
  attribute lyric.align { data.MEASUREMENT }?
att.lyricstyle.attribute.lyric.fam =
  
  ## sets the font family default value for lyrics.
  attribute lyric.fam { data.FONTFAMILY }?
att.lyricstyle.attribute.lyric.name =
  
  ## sets the font name default value for lyrics.
  attribute lyric.name { data.FONTNAME }?
att.lyricstyle.attribute.lyric.size =
  
  ## sets the default font size value for lyrics.
  attribute lyric.size { data.FONTSIZE }?
att.lyricstyle.attribute.lyric.style =
  
  ## sets the default font style value for lyrics.
  attribute lyric.style { data.FONTSTYLE }?
att.lyricstyle.attribute.lyric.weight =
  
  ## sets the default font weight value for lyrics.
  attribute lyric.weight { data.FONTWEIGHT }?
att.measure.anl.attributes =
  att.common.anl.attributes, att.joined.attributes
att.measure.ges.attributes = att.timestamp.performed.attributes
att.measure.log.attributes =
  att.meterconformance.bar.attributes,
  att.measure.log.attribute.left,
  att.measure.log.attribute.right
att.measure.log.attribute.left =
  
  ## indicates the visual rendition of the left bar line. It is present here only for facilitation of translation from legacy encodings which use it. Usually, it can be safely ignored.
  attribute left { data.BARRENDITION }?
att.measure.log.attribute.right =
  
  ## indicates the function of the right bar line and is structurally important.
  attribute right { data.BARRENDITION }?
att.measurement.attributes = att.measurement.attribute.unit
att.measurement.attribute.unit =
  
  ## indicates the unit used for a measurement of size.
  ## Suggested values include: 1] cm; 2] mm; 3] in; 4] issue; 5] page; 6] px; 7] pt; 8] pc; 9] vu; 10] vol
  attribute unit {
    
    ## centimeter.
    "cm"
    | 
      ## millimeter.
      "mm"
    | 
      ## inch.
      "in"
    | 
      ## serial issue.
      "issue"
    | 
      ## page.
      "page"
    | 
      ## pixel.
      "px"
    | 
      ## point.
      "pt"
    | 
      ## pica.
      "pc"
    | 
      ## MEI virtual unit.
      "vu"
    | 
      ## serial volume.
      "vol"
    | xsd:Name
  }?
att.mediabounds.attributes =
  att.mediabounds.attribute.begin,
  att.mediabounds.attribute.end,
  att.mediabounds.attribute.betype
att.mediabounds.attribute.begin =
  
  ## specifies a point where the relevant content begins. A numerical value must be less and a time value must be earlier than that in the end attribute.
  attribute begin { text }?
att.mediabounds.attribute.end =
  
  ## specifies a point where the relevant content ends. If not specified, the end of the content is assumed to be the end point. A numerical value must be greater and a time value must be later than that in the begin attribute.
  attribute end { text }?
att.mediabounds.attribute.betype =
  
  ## type of values used in the begin/end attributes. The begin and end attributes can only be interpreted meaningfully in conjunction with this attribute.
  attribute betype {
    
    ## a modified ISO time format (HH:MM:SS.ss) where 'HH' should be interpreted as any number of hours and '.ss' should be interpreted as any number of fractional parts of a second.
    "time"
  }?
att.medium.attributes = att.medium.attribute.medium
att.medium.attribute.medium =
  
  ## describes the writing medium.
  attribute medium { text }?
att.meiversion.attributes =
  att.meiversion.attribute.meiversion,
  att.meiversion.attribute.meiversion.num
att.meiversion.attribute.meiversion =
  
  ## specifies a generic MEI version label.
  [ a:defaultValue = "2013" ]
  attribute meiversion {
    
    ## this version of MEI.
    "2013"
  }?
att.meiversion.attribute.meiversion.num =
  
  ## records a detailed MEI version number.
  [ a:defaultValue = "2.1.0" ]
  attribute meiversion.num {
    
    ## this version of MEI.
    "2.1.0"
  }?
att.mensur.log.attributes =
  att.duration.ratio.attributes,
  att.slashcount.attributes,
  att.mensural.shared.attributes,
  att.mensur.log.attribute.dot,
  att.mensur.log.attribute.sign
att.mensur.log.attribute.dot =
  
  ## specifies whether a dot is to be added to the base symbol.
  attribute dot { data.BOOLEAN }?
att.mensur.log.attribute.sign =
  
  ## the base symbol in the mensuration sign/time signature of mensural notation.
  attribute sign { data.MENSURATIONSIGN }?
att.meterconformance.attributes = att.meterconformance.attribute.metcon
att.meterconformance.attribute.metcon =
  
  ## indicates the relationship between the content of a staff or layer and the prevailing meter.
  attribute metcon {
    
    ## conformant with the prevailing meter.
    "c"
    | 
      ## incomplete; i.e., not enough beats.
      "i"
    | 
      ## overfull; i.e., too many beats.
      "o"
  }?
att.meterconformance.bar.attributes =
  att.meterconformance.bar.attribute.metcon,
  att.meterconformance.bar.attribute.control
att.meterconformance.bar.attribute.metcon =
  
  ## indicates the relationship between the content of a measure and the prevailing meter.
  attribute metcon { data.BOOLEAN }?
att.meterconformance.bar.attribute.control =
  
  ## indicates whether or not a bar line is "controlling"; that is, if it indicates a point of alignment across all the parts. Bar lines within a score are usually controlling; that is, they "line up". Bar lines within parts may or may not be controlling. When applied to <measure>, this attribute indicates the nature of the right barline but not the left.
  attribute control { data.BOOLEAN }?
att.meterSig.anl.attributes = att.common.anl.attributes
att.meterSig.ges.attributes = empty
att.meterSig.log.attributes =
  att.meterSig.log.attribute.count,
  att.meterSig.log.attribute.sym,
  att.meterSig.log.attribute.unit
att.meterSig.log.attribute.count =
  
  ## captures the number of beats in a measure, that is, the top number of the meter signature. It must contain a decimal number or an additive expression that evaluates to a decimal number, such as 2+3.
  attribute count {
    xsd:string { pattern = "\d+(\.\d+)?(\s*\+\s*\d+(\.\d+)?)*" }
  }?
att.meterSig.log.attribute.sym =
  
  ## indicates the use of a meter symbol instead of a numeric meter signature, that is, 'C' for common time or 'C' with a slash for cut time.
  attribute sym { data.METERSIGN }?
att.meterSig.log.attribute.unit =
  
  ## contains the number indicating the beat unit, that is, the bottom number of the meter signature.
  attribute unit { xsd:decimal }?
att.meterSig.vis.attributes = att.meterSig.vis.attribute.rend
att.meterSig.vis.attribute.rend =
  
  ## contains an indication of how the meter signature should be rendered.
  attribute rend {
    
    ## show only the number of beats.
    "num"
    | 
      ## the lower number in the meter signature is replaced by a note symbol.
      "denomsym"
    | 
      ## meter signature rendered using traditional numeric values.
      "norm"
    | 
      ## meter signature not rendered.
      "invis"
  }?
att.meterSigDefault.log.attributes =
  att.meterSigDefault.log.attribute.meter.count,
  att.meterSigDefault.log.attribute.meter.unit
att.meterSigDefault.log.attribute.meter.count =
  
  ## captures the number of beats in a measure, that is, the top number of the meter signature. It must contain a decimal number or an additive expression that evaluates to a decimal number, such as 2+3.
  attribute meter.count {
    xsd:string { pattern = "\d+(\.\d+)?(\s*\+\s*\d+(\.\d+)?)*" }
  }?
att.meterSigDefault.log.attribute.meter.unit =
  
  ## contains the number indicating the beat unit, that is, the bottom number of the meter signature.
  attribute meter.unit { xsd:decimal }?
att.meterSigDefault.vis.attributes =
  att.meterSigDefault.vis.attribute.meter.rend,
  att.meterSigDefault.vis.attribute.meter.showchange,
  att.meterSigDefault.vis.attribute.meter.sym
att.meterSigDefault.vis.attribute.meter.rend =
  
  ## contains an indication of how the meter signature should be rendered.
  attribute meter.rend {
    
    ## show only the number of beats.
    "num"
    | 
      ## the lower number in the meter signature is replaced by a note symbol.
      "denomsym"
    | 
      ## meter signature rendered using traditional numeric values.
      "norm"
    | 
      ## meter signature not rendered.
      "invis"
  }?
att.meterSigDefault.vis.attribute.meter.showchange =
  
  ## determines whether a new meter signature should be displayed when the meter signature changes.
  attribute meter.showchange { data.BOOLEAN }?
att.meterSigDefault.vis.attribute.meter.sym =
  
  ## indicates the use of a meter symbol instead of a numeric meter signature, that is, 'C' for common time or 'C' with a slash for cut time.
  attribute meter.sym { data.METERSIGN }?
att.mmtempo.attributes =
  att.mmtempo.attribute.mm,
  att.mmtempo.attribute.mm.unit,
  att.mmtempo.attribute.mm.dots
att.mmtempo.attribute.mm =
  
  ## used to describe tempo in terms of beats (often the meter signature denominator) per minute, ala M.M. (Maezel's Metronome).
  attribute mm { data.TEMPOVALUE }?
att.mmtempo.attribute.mm.unit =
  
  ## captures the metronomic unit.
  attribute mm.unit { data.DURATION }?
att.mmtempo.attribute.mm.dots =
  
  ## records the number of augmentation dots required by a dotted metronome unit.
  attribute mm.dots { data.AUGMENTDOT }?
att.multinummeasures.attributes =
  att.multinummeasures.attribute.multi.number
att.multinummeasures.attribute.multi.number =
  
  ## indicates whether programmatically calculated counts of multiple measures of rest (mRest) and whole measure repeats (mRpt) in parts should be rendered.
  attribute multi.number { data.BOOLEAN }?
att.name.attributes =
  att.authorized.attributes,
  att.canonical.attributes,
  att.name.attribute.nymref,
  att.name.attribute.role
att.name.attribute.nymref =
  
  ## used to record a pointer to the regularized form of the name elsewhere in the document.
  attribute nymref { data.URI }?
att.name.attribute.role =
  
  ## used to specify further information about the entity referenced by this name, for example, the occupation of a person or the status of a place.
  attribute role { text }?
att.note.anl.attributes =
  att.common.anl.attributes,
  att.harmonicfunction.attributes,
  att.intervallicdesc.attributes,
  att.melodicfunction.attributes,
  att.pitchclass.attributes,
  att.solfa.attributes
att.note.ges.attributes =
  att.accidental.performed.attributes,
  att.articulation.performed.attributes,
  att.duration.performed.attributes,
  att.instrumentident.attributes,
  att.note.ges.cmn.attributes,
  att.note.ges.mensural.attributes,
  att.note.ges.tablature.attributes,
  att.note.ges.attribute.oct.ges,
  att.note.ges.attribute.pname.ges,
  att.note.ges.attribute.pnum
att.note.ges.attribute.oct.ges =
  
  ## records performed octave information that differs from the written value.
  attribute oct.ges { data.OCTAVE }?
att.note.ges.attribute.pname.ges =
  
  ## contains a performed pitch name that differs from the written value.
  attribute pname.ges { data.PITCHNAME.GES }?
att.note.ges.attribute.pnum =
  
  ## holds a pitch-to-number mapping, a base-40 or MIDI note number, for example.
  attribute pnum { data.PITCHNUMBER }?
att.note.log.attributes =
  att.event.attributes,
  att.accidental.attributes,
  att.articulation.attributes,
  att.augmentdots.attributes,
  att.duration.musical.attributes,
  att.fermatapresent.attributes,
  att.pitched.attributes,
  att.syltext.attributes,
  att.slurpresent.attributes,
  att.tiepresent.attributes,
  att.tupletpresent.attributes,
  att.note.log.cmn.attributes,
  att.note.log.mensural.attributes
att.note.vis.attributes =
  att.altsym.attributes,
  att.color.attributes,
  att.coloration.attributes,
  att.enclosingchars.attributes,
  att.relativesize.attributes,
  att.staffloc.attributes,
  att.stemmed.attributes,
  att.visibility.attributes,
  att.visualoffset.ho.attributes,
  att.visualoffset.to.attributes,
  att.xy.attributes,
  att.note.vis.cmn.attributes,
  att.note.vis.attribute.headshape
att.note.vis.attribute.headshape =
  
  ## used to override the head shape normally used for the given duration.
  attribute headshape { data.HEADSHAPE }?
att.octave.attributes = att.octave.attribute.oct
att.octave.attribute.oct =
  
  ## captures written octave information.
  attribute oct { data.OCTAVE }?
att.octavedefault.attributes =
  att.octavedefault.attribute.octave.default
att.octavedefault.attribute.octave.default =
  
  ## contains a default octave specification for use when the first note, rest, chord, etc. in a measure does not have an octave value specified.
  attribute octave.default { data.OCTAVE }?
att.octavedisplacement.attributes =
  att.octavedisplacement.attribute.dis,
  att.octavedisplacement.attribute.dis.place
att.octavedisplacement.attribute.dis =
  
  ## records the amount of octave displacement.
  attribute dis { data.OCTAVE.DIS }?
att.octavedisplacement.attribute.dis.place =
  
  ## records the direction of octave displacement.
  attribute dis.place { data.PLACE }?
att.onelinestaff.attributes = att.onelinestaff.attribute.ontheline
att.onelinestaff.attribute.ontheline =
  
  ## determines the placement of notes on a 1-line staff. A value of 'true' places all notes on the line, while a value of 'false' places stems-up notes above the line and stems-down notes below the line.
  attribute ontheline { data.BOOLEAN }?
att.pad.anl.attributes = empty
att.pad.ges.attributes = empty
att.pad.log.attributes = att.event.attributes, att.pad.log.attribute.num
att.pad.log.attribute.num =
  
  ## amount of "padding" to be added, in interline units; that is, in units of 1/2 the distance between adjacent staff lines.
  attribute num { xsd:decimal }
att.pad.vis.attributes = empty
att.part.anl.attributes = att.common.anl.attributes
att.part.ges.attributes = empty
att.part.log.attributes = empty
att.part.vis.attributes = empty
att.parts.anl.attributes = att.common.anl.attributes
att.parts.ges.attributes = empty
att.parts.log.attributes = empty
att.parts.vis.attributes = empty
att.pb.anl.attributes = att.common.anl.attributes
att.pb.ges.attributes = empty
att.pb.log.attributes = empty
att.pb.vis.attributes = att.pb.vis.attribute.func
att.pb.vis.attribute.func =
  
  ## states the side of a leaf (as in a manuscript) on which the content following the <pb> element occurs.
  attribute func {
    
    ##
    "verso"
    | 
      ##
      "recto"
  }?
att.phrase.anl.attributes =
  att.common.anl.attributes, att.joined.attributes
att.phrase.ges.attributes = att.duration.performed.attributes
att.phrase.log.attributes =
  att.controlevent.attributes,
  att.augmentdots.attributes,
  att.duration.additive.attributes,
  att.startendid.attributes,
  att.timestamp2.musical.attributes
att.phrase.vis.attributes =
  att.color.attributes,
  att.visualoffset.attributes,
  att.visualoffset2.attributes,
  att.xy.attributes,
  att.xy2.attributes,
  att.phrase.vis.cmn.attributes
att.pitch.attributes = att.pitch.attribute.pname
att.pitch.attribute.pname =
  
  ## contains a written pitch name.
  attribute pname { data.PITCHNAME }?
att.pitched.attributes = att.pitch.attributes, att.octave.attributes
att.placement.attributes = att.placement.attribute.place
att.placement.attribute.place =
  
  ## captures the placement of the item with respect to the staff with which it is associated.
  attribute place { data.STAFFREL }?
att.plist.attributes =
  att.plist.attribute.plist, att.plist.attribute.evaluate
att.plist.attribute.plist =
  
  ## contains a space separated list of references that identify logical events that participate in a collection, such as notes under a phrase mark.
  attribute plist { data.URIS }?
att.plist.attribute.evaluate =
  
  ## specifies the intended meaning when the target of a pointer is itself a pointer.
  attribute evaluate {
    
    ## if the element pointed to is itself a pointer, then the target of that pointer will be taken, and so on, until an element is found which is not a pointer.
    "all"
    | 
      ## if the element pointed to is itself a pointer, then its target (whether a pointer or not) is taken as the target of this pointer.
      "one"
    | 
      ## no further evaluation of targets is carried out beyond that needed to find the element specified in the pointer's target.
      "none"
  }?
att.pointing.attributes =
  att.pointing.attribute.xlinkactuate,
  att.pointing.attribute.xlinkrole,
  att.pointing.attribute.xlinkshow,
  att.pointing.attribute.target,
  att.pointing.attribute.targettype,
  att.pointing.attribute.xlinktitle
att.pointing.attribute.xlinkactuate =
  
  ## defines whether a link occurs automatically or must be requested by the user.
  attribute xlink:actuate {
    
    ## load the target resource immediately.
    "onLoad"
    | 
      ## load the target resource upon user request.
      "onRequest"
    | 
      ## do not permit loading of the target resource.
      "none"
    | 
      ## behavior other than allowed by the other values of this attribute.
      "other"
  }?
att.pointing.attribute.xlinkrole =
  
  ## indicates a property of the entire link. The value of the role attribute must be a URI.
  attribute xlink:role { data.URI }?
att.pointing.attribute.xlinkshow =
  
  ## defines how a remote resource is rendered.
  attribute xlink:show {
    
    ## open in a new window.
    "new"
    | 
      ## load the referenced resource in the same window.
      "replace"
    | 
      ## embed the referenced resource at the point of the link.
      "embed"
    | 
      ## do not permit traversal to the referenced resource.
      "none"
    | 
      ## behavior other than permitted by the other values of this attribute.
      "other"
  }?
att.pointing.attribute.target =
  
  ## allows the use of one or more previously-undeclared URIs to identify an external electronic object.
  attribute target { data.URIS }?
att.pointing.attribute.targettype =
  
  ## in contrast with the role attribute, allows the target resource to be characterized using any convenient classification scheme or typology.
  attribute targettype { xsd:NMTOKEN }?
att.pointing.attribute.xlinktitle =
  
  ## contains a human-readable description of the entire link.
  attribute xlink:title { text }?
att.relativesize.attributes = att.relativesize.attribute.size
att.relativesize.attribute.size =
  
  ## describes the relative size of a feature.
  attribute size { data.SIZE }?
att.responsibility.attributes = att.responsibility.attribute.resp
att.responsibility.attribute.resp =
  
  ## captures information regarding responsibility for some aspect of the text's creation, transcription, editing, or encoding. Its value must point to one or more identifiers declared in the document header.
  attribute resp { data.URIS }?
att.rest.anl.attributes = att.common.anl.attributes
att.rest.ges.attributes =
  att.duration.performed.attributes,
  att.instrumentident.attributes,
  att.rest.ges.mensural.attributes
att.rest.log.attributes =
  att.augmentdots.attributes,
  att.event.attributes,
  att.duration.musical.attributes,
  att.fermatapresent.attributes,
  att.tupletpresent.attributes,
  att.rest.log.cmn.attributes
att.rest.vis.attributes =
  att.altsym.attributes,
  att.color.attributes,
  att.enclosingchars.attributes,
  att.relativesize.attributes,
  att.rest.vis.cmn.attributes,
  att.rest.vis.mensural.attributes,
  att.staffloc.attributes,
  att.staffloc.pitched.attributes,
  att.visualoffset.attributes,
  att.xy.attributes
att.sb.anl.attributes = att.common.anl.attributes
att.sb.ges.attributes = empty
att.sb.log.attributes = empty
att.sb.vis.attributes = att.sb.vis.attribute.rend
att.sb.vis.attribute.rend =
  
  ## indicates whether hash marks should be rendered between systems. See Read, p. 436, ex. 26-3.
  attribute rend {
    
    ## display hash marks between systems.
    "hash"
  }?
att.scalable.attributes = att.scalable.attribute.scale
att.scalable.attribute.scale =
  
  ## scale factor to be applied to the feature to make it the desired display size.
  attribute scale { data.PERCENT }?
att.score.anl.attributes = att.common.anl.attributes
att.score.ges.attributes = empty
att.score.log.attributes = empty
att.score.vis.attributes = empty
att.scoreDef.anl.attributes = empty
att.scoreDef.ges.attributes =
  att.channelized.attributes,
  att.timebase.attributes,
  att.miditempo.attributes,
  att.mmtempo.attributes,
  att.scoreDef.ges.attribute.tune.pname,
  att.scoreDef.ges.attribute.tune.Hz,
  att.scoreDef.ges.attribute.tune.temper
att.scoreDef.ges.attribute.tune.pname =
  
  ## holds the pitch name of a tuning reference pitch.
  attribute tune.pname { data.PITCHNAME }?
att.scoreDef.ges.attribute.tune.Hz =
  
  ## holds a value for cycles per second, i.e., Hertz, for a tuning reference pitch.
  attribute tune.Hz { xsd:decimal }?
att.scoreDef.ges.attribute.tune.temper =
  
  ## provides an indication of the tuning system, 'just', for example.
  attribute tune.temper { data.TEMPERAMENT }?
att.scoreDef.log.attributes =
  att.cleffing.log.attributes,
  att.duration.default.attributes,
  att.keySigDefault.log.attributes,
  att.meterSigDefault.log.attributes,
  att.octavedefault.attributes,
  att.transposition.attributes,
  att.scoreDef.log.cmn.attributes,
  att.scoreDef.log.mensural.attributes
att.scoreDef.vis.attributes =
  att.barplacement.attributes,
  att.cleffing.vis.attributes,
  att.distances.attributes,
  att.keySigDefault.vis.attributes,
  att.lyricstyle.attributes,
  att.meterSigDefault.vis.attributes,
  att.multinummeasures.attributes,
  att.onelinestaff.attributes,
  att.textstyle.attributes,
  att.scoreDef.vis.cmn.attributes,
  att.scoreDef.vis.mensural.attributes,
  att.scoreDef.vis.attribute.ending.rend,
  att.scoreDef.vis.attribute.mnum.visible,
  att.scoreDef.vis.attribute.music.name,
  att.scoreDef.vis.attribute.music.size,
  att.scoreDef.vis.attribute.optimize,
  att.scoreDef.vis.attribute.page.height,
  att.scoreDef.vis.attribute.page.width,
  att.scoreDef.vis.attribute.page.topmar,
  att.scoreDef.vis.attribute.page.botmar,
  att.scoreDef.vis.attribute.page.leftmar,
  att.scoreDef.vis.attribute.page.rightmar,
  att.scoreDef.vis.attribute.page.panels,
  att.scoreDef.vis.attribute.page.scale,
  att.scoreDef.vis.attribute.spacing.packexp,
  att.scoreDef.vis.attribute.spacing.packfact,
  att.scoreDef.vis.attribute.spacing.staff,
  att.scoreDef.vis.attribute.spacing.system,
  att.scoreDef.vis.attribute.system.leftmar,
  att.scoreDef.vis.attribute.system.rightmar,
  att.scoreDef.vis.attribute.system.topmar,
  att.scoreDef.vis.attribute.vu.height
att.scoreDef.vis.attribute.ending.rend =
  
  ## describes where ending marks should be displayed.
  attribute ending.rend {
    
    ## ending rendered only above top staff.
    "top"
    | 
      ## ending rendered above staves that have bar lines drawn across them.
      "barred"
    | 
      ## endings rendered above staff groups.
      "grouped"
  }?
att.scoreDef.vis.attribute.mnum.visible =
  
  ## indicates whether measure numbers should be displayed.
  attribute mnum.visible { data.BOOLEAN }?
att.scoreDef.vis.attribute.music.name =
  
  ## sets the default music font name.
  attribute music.name { data.MUSICFONT }?
att.scoreDef.vis.attribute.music.size =
  
  ## sets the default music font size.
  attribute music.size { data.FONTSIZE }?
att.scoreDef.vis.attribute.optimize =
  
  ## indicates whether staves without notes, rests, etc. should be displayed. When the value is 'true', empty staves are displayed.
  attribute optimize { data.BOOLEAN }?
att.scoreDef.vis.attribute.page.height =
  
  ## specifies the height of the page; may be expressed in real-world units or staff steps.
  attribute page.height { data.MEASUREMENT }?
att.scoreDef.vis.attribute.page.width =
  
  ## describes the width of the page; may be expressed in real-world units or staff steps.
  attribute page.width { data.MEASUREMENT }?
att.scoreDef.vis.attribute.page.topmar =
  
  ## indicates the amount of whitespace at the top of a page.
  attribute page.topmar { data.MEASUREMENT }?
att.scoreDef.vis.attribute.page.botmar =
  
  ## indicates the amount of whitespace at the bottom of a page.
  attribute page.botmar { data.MEASUREMENT }?
att.scoreDef.vis.attribute.page.leftmar =
  
  ## indicates the amount of whitespace at the left side of a page.
  attribute page.leftmar { data.MEASUREMENT }?
att.scoreDef.vis.attribute.page.rightmar =
  
  ## indicates the amount of whitespace at the right side of a page.
  attribute page.rightmar { data.MEASUREMENT }?
att.scoreDef.vis.attribute.page.panels =
  
  ## indicates the number of logical pages to be rendered on a single physical page.
  attribute page.panels { data.PAGE.PANELS }?
att.scoreDef.vis.attribute.page.scale =
  
  ## indicates how the page should be scaled when rendered.
  attribute page.scale { data.PGSCALE }?
att.scoreDef.vis.attribute.spacing.packexp =
  
  ## describes a note's spacing relative to its time value.
  attribute spacing.packexp { xsd:decimal }?
att.scoreDef.vis.attribute.spacing.packfact =
  
  ## describes the note spacing of output.
  attribute spacing.packfact { xsd:decimal }?
att.scoreDef.vis.attribute.spacing.staff =
  
  ## specifies the minimum amount of space between adjacent staves in the same system; measured from the bottom line of the staff above to the top line of the staff below.
  attribute spacing.staff { data.MEASUREMENT }?
att.scoreDef.vis.attribute.spacing.system =
  
  ## describes the space between adjacent systems; a pair of space-separated values (minimum and maximum, respectively) provides a range between which a rendering system-supplied value may fall, while a single value indicates a fixed amount of space; that is, the minimum and maximum values are equal.
  attribute spacing.system {
    list { data.MEASUREMENT }
  }?
att.scoreDef.vis.attribute.system.leftmar =
  
  ## describes the amount of whitespace at the left system margin relative to page.leftmar.
  attribute system.leftmar { data.MEASUREMENT }?
att.scoreDef.vis.attribute.system.rightmar =
  
  ## describes the amount of whitespace at the right system margin relative to page.rightmar.
  attribute system.rightmar { data.MEASUREMENT }?
att.scoreDef.vis.attribute.system.topmar =
  
  ## describes the distance from page's top edge to the first system; used for first page only.
  attribute system.topmar { data.MEASUREMENT }?
att.scoreDef.vis.attribute.vu.height =
  
  ## defines the height of a "virtual unit" (vu) in terms of real-world units. A single vu is half the distance between the vertical center point of a staff line and that of an adjacent staff line.
  attribute vu.height {
    xsd:token { pattern = "\d+(\.\d+)?(cm|mm|in|pt|pc)" }
  }?
att.section.anl.attributes = att.common.anl.attributes
att.section.ges.attributes = empty
att.section.log.attributes = empty
att.section.vis.attributes = att.section.vis.attribute.restart
att.section.vis.attribute.restart =
  
  ## indicates that staves begin again with this section.
  attribute restart { data.BOOLEAN }?
att.sequence.attributes = att.sequence.attribute.seq
att.sequence.attribute.seq =
  
  ## used to assign a sequence number related to the order in which the encoded features carrying this attribute are believed to have occurred.
  attribute seq { xsd:positiveInteger }?
att.slashcount.attributes = att.slashcount.attribute.slash
att.slashcount.attribute.slash =
  
  ## indicates the number of slashes present.
  attribute slash { data.SLASH }?
att.slurpresent.attributes = att.slurpresent.attribute.slur
att.slurpresent.attribute.slur =
  
  ## indicates that this element participates in a slur. If visual information about the slur needs to be recorded, then a <slur> element should be employed.
  attribute slur { data.SLURS }?
att.space.anl.attributes = att.common.anl.attributes
att.space.ges.attributes = att.duration.performed.attributes
att.space.log.attributes =
  att.augmentdots.attributes,
  att.event.attributes,
  att.duration.musical.attributes,
  att.fermatapresent.attributes,
  att.tupletpresent.attributes,
  att.space.log.cmn.attributes
att.space.vis.attributes = att.space.vis.attribute.compressable
att.space.vis.attribute.compressable =
  
  ## indicates whether a space is 'compressible', i.e., if it may be removed at the discretion of processing software.
  attribute compressable { data.BOOLEAN }?
att.staff.anl.attributes = att.common.anl.attributes
att.staff.ges.attributes = empty
att.staff.log.attributes =
  att.meterconformance.attributes, att.staff.log.attribute.def
att.staff.log.attribute.def =
  
  ## provides a mechanism for linking the staff to a staffDef element.
  attribute def { data.URI }?
att.staff.vis.attributes = att.visibility.attributes
att.staffDef.anl.attributes = empty
att.staffDef.ges.attributes =
  att.instrumentident.attributes,
  att.timebase.attributes,
  att.staffDef.ges.tablature.attributes
att.staffDef.log.attributes =
  att.cleffing.log.attributes,
  att.duration.default.attributes,
  att.keySigDefault.log.attributes,
  att.meterSigDefault.log.attributes,
  att.octavedefault.attributes,
  att.transposition.attributes,
  att.staffDef.log.cmn.attributes,
  att.staffDef.log.mensural.attributes
att.staffDef.vis.attributes =
  att.cleffing.vis.attributes,
  att.distances.attributes,
  att.keySigDefault.vis.attributes,
  att.labels.addl.attributes,
  att.lyricstyle.attributes,
  att.meterSigDefault.vis.attributes,
  att.multinummeasures.attributes,
  att.onelinestaff.attributes,
  att.scalable.attributes,
  att.textstyle.attributes,
  att.visibility.attributes,
  att.staffDef.vis.cmn.attributes,
  att.staffDef.vis.mensural.attributes,
  att.staffDef.vis.attribute.grid.show,
  att.staffDef.vis.attribute.layerscheme,
  att.staffDef.vis.attribute.lines,
  att.staffDef.vis.attribute.lines.color,
  att.staffDef.vis.attribute.lines.visible,
  att.staffDef.vis.attribute.spacing
att.staffDef.vis.attribute.grid.show =
  
  ## determines whether to display guitar chord grids.
  attribute grid.show { data.BOOLEAN }?
att.staffDef.vis.attribute.layerscheme =
  
  ## indicates the number of layers and their stem directions.
  attribute layerscheme { data.LAYERSCHEME }?
att.staffDef.vis.attribute.lines =
  
  ## indicates the number of staff lines.
  attribute lines { xsd:positiveInteger }?
att.staffDef.vis.attribute.lines.color =
  
  ## captures the colors of the staff lines. The value is structured; that is, it should have the same number of space-separated RGB values as the number of lines indicated by the lines attribute. A line can be made invisible by assigning it the same RGB value as the background, usually white.
  attribute lines.color { data.COLORS }?
att.staffDef.vis.attribute.lines.visible =
  
  ## records whether all staff lines are visible.
  attribute lines.visible { data.BOOLEAN }?
att.staffDef.vis.attribute.spacing =
  
  ## records the absolute distance (as opposed to the relative distances recorded in <scoreDef> elements) between this staff and the preceding one in the same system. This value is meaningless for the first staff in a system since the spacing.system attribute indicates the spacing between systems.
  attribute spacing { data.MEASUREMENT }?
att.staffgroupingsym.attributes = att.staffgroupingsym.attribute.symbol
att.staffgroupingsym.attribute.symbol =
  
  ## specifies the symbol used to group a set of staves.
  attribute symbol {
    
    ## curved symbol, i.e., {.
    "brace"
    | 
      ## square symbol, i.e., [.
      "bracket"
    | 
      ## line symbol, i.e., |.
      "line"
    | 
      ## grouping symbol missing.
      "none"
  }?
att.staffGrp.anl.attributes = empty
att.staffGrp.ges.attributes = att.instrumentident.attributes
att.staffGrp.log.attributes = empty
att.staffGrp.vis.attributes =
  att.labels.addl.attributes,
  att.staffgroupingsym.attributes,
  att.visibility.attributes,
  att.staffGrp.vis.attribute.barthru
att.staffGrp.vis.attribute.barthru =
  
  ## indicates whether bar lines go across the space between staves (true) or are only drawn across the lines of each staff (false).
  attribute barthru { data.BOOLEAN }?
att.staffident.attributes = att.staffident.attribute.staff
att.staffident.attribute.staff =
  
  ## signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
  attribute staff {
    list { xsd:positiveInteger+ }
  }?
att.staffloc.attributes = att.staffloc.attribute.loc
att.staffloc.attribute.loc =
  
  ## holds the staff location of the feature.
  attribute loc { data.STAFFLOC }?
att.staffloc.pitched.attributes =
  att.staffloc.pitched.attribute.ploc,
  att.staffloc.pitched.attribute.oloc
att.staffloc.pitched.attribute.ploc =
  
  ## captures staff location in terms of written pitch name.
  attribute ploc { data.PITCHNAME }?
att.staffloc.pitched.attribute.oloc =
  
  ## records staff location in terms of written octave.
  attribute oloc { data.OCTAVE }?
att.startendid.attributes =
  att.startid.attributes, att.startendid.attribute.endid
att.startendid.attribute.endid =
  
  ## indicates the final element in a sequence of events to which the feature applies.
  attribute endid { data.URI }?
att.startid.attributes = att.startid.attribute.startid
att.startid.attribute.startid =
  
  ## holds a reference to the first element in a sequence of events to which the feature applies.
  attribute startid { data.URI }?
att.stemmed.attributes =
  att.stemmed.cmn.attributes,
  att.stemmed.attribute.stem.dir,
  att.stemmed.attribute.stem.len,
  att.stemmed.attribute.stem.pos,
  att.stemmed.attribute.stem.x,
  att.stemmed.attribute.stem.y
att.stemmed.attribute.stem.dir =
  
  ## describes the direction of a stem.
  attribute stem.dir { data.STEMDIRECTION }?
att.stemmed.attribute.stem.len =
  
  ## encodes the stem length.
  attribute stem.len { xsd:decimal }?
att.stemmed.attribute.stem.pos =
  
  ## records the position of the stem in relation to the note head(s).
  attribute stem.pos { data.STEMPOSITION }?
att.stemmed.attribute.stem.x =
  
  ## records the output x coordinate of the stem's attachment point.
  attribute stem.x { xsd:decimal }?
att.stemmed.attribute.stem.y =
  
  ## records the output y coordinate of the stem's attachment point.
  attribute stem.y { xsd:decimal }?
att.syl.anl.attributes = att.common.anl.attributes
att.syl.ges.attributes = empty
att.syl.log.attributes =
  att.syl.log.attribute.con, att.syl.log.attribute.wordpos
att.syl.log.attribute.con =
  
  ## describes the symbols typically used to indicate breaks between syllables and their functions.
  attribute con {
    
    ## space (word separator).
    "s"
    | 
      ## dash (syllable separator).
      "d"
    | 
      ## underscore (syllable extension).
      "u"
    | 
      ## tilde (syllable elision).
      "t"
    | 
      ## circumflex [angled line above] (syllable elision).
      "c"
    | 
      ## caron [angled line below] (syllable elision).
      "v"
    | 
      ## inverted breve [curved line above] (syllable elision).
      "i"
    | 
      ## breve [curved line below] (syllable elision).
      "b"
  }?
att.syl.log.attribute.wordpos =
  
  ## records the position of a syllable within a word.
  attribute wordpos {
    
    ## (initial) first syllable.
    "i"
    | 
      ## (medial) neither first nor last syllable.
      "m"
    | 
      ## (terminal) last syllable.
      "t"
  }?
att.syl.vis.attributes =
  att.typography.attributes,
  att.visualoffset.attributes,
  att.xy.attributes,
  att.horizontalalign.attributes
att.syltext.attributes = att.syltext.attribute.syl
att.syltext.attribute.syl =
  
  ## holds an associated sung text syllable.
  attribute syl { text }?
att.tempo.anl.attributes = att.common.anl.attributes
att.tempo.ges.attributes =
  att.miditempo.attributes, att.mmtempo.attributes
att.tempo.log.attributes =
  att.controlevent.attributes, att.startid.attributes
att.tempo.vis.attributes =
  att.placement.attributes,
  att.visualoffset.attributes,
  att.visualoffset2.ho.attributes,
  att.visualoffset2.to.attributes,
  att.xy.attributes
att.textstyle.attributes =
  att.textstyle.attribute.text.fam,
  att.textstyle.attribute.text.name,
  att.textstyle.attribute.text.size,
  att.textstyle.attribute.text.style,
  att.textstyle.attribute.text.weight
att.textstyle.attribute.text.fam =
  
  ## provides a default value for the font family name of text (other than lyrics) when this information is not provided on the individual elements.
  attribute text.fam { data.FONTFAMILY }?
att.textstyle.attribute.text.name =
  
  ## provides a default value for the font name of text (other than lyrics) when this information is not provided on the individual elements.
  attribute text.name { data.FONTNAME }?
att.textstyle.attribute.text.size =
  
  ## provides a default value for the font size of text (other than lyrics) when this information is not provided on the individual elements.
  attribute text.size { data.FONTSIZE }?
att.textstyle.attribute.text.style =
  
  ## provides a default value for the font style of text (other than lyrics) when this information is not provided on the individual elements.
  attribute text.style { data.FONTSTYLE }?
att.textstyle.attribute.text.weight =
  
  ## provides a default value for the font weight for text (other than lyrics) when this information is not provided on the individual elements.
  attribute text.weight { data.FONTWEIGHT }?
att.tiepresent.attributes = att.tiepresent.attribute.tie
att.tiepresent.attribute.tie =
  
  ## indicates that this element participates in a tie. If visual information about the tie needs to be recorded, then a <tie> element should be employed.
  attribute tie { data.TIES }?
att.timestamp.musical.attributes =
  att.timestamp.musical.attribute.tstamp
att.timestamp.musical.attribute.tstamp =
  
  ## encodes the onset time in terms of musical time, i.e., beats[.fractional_beat_part].
  attribute tstamp { data.BEAT }?
att.timestamp.performed.attributes =
  att.timestamp.performed.attribute.tstamp.ges,
  att.timestamp.performed.attribute.tstamp.real
att.timestamp.performed.attribute.tstamp.ges =
  
  ## used to record the onset time in pulses per quarter note (ppq, MusicXML divisions, or MIDI clicks) since the start of the file.
  attribute tstamp.ges { xsd:nonNegativeInteger }?
att.timestamp.performed.attribute.tstamp.real =
  
  ## used to record the onset time in terms of ISO time since the start of the file.
  attribute tstamp.real { data.ISOTIME }?
att.timestamp2.musical.attributes =
  att.timestamp2.musical.attribute.tstamp2
att.timestamp2.musical.attribute.tstamp2 =
  
  ## encodes the ending point of an event in terms of musical time, i.e., a count of measures plus a beat location.
  attribute tstamp2 { data.MEASUREBEAT }?
att.transposition.attributes =
  att.transposition.attribute.trans.diat,
  att.transposition.attribute.trans.semi
att.transposition.attribute.trans.diat =
  
  ## records the amount of diatonic pitch shift, e.g., C to C = 0, C to D = 1, necessary to calculate the sounded pitch from the written one. 
  attribute trans.diat { xsd:decimal }?
att.transposition.attribute.trans.semi =
  
  ## records the amount of pitch shift in semitones, e.g., C to C = 1, C to D = 1, necessary to calculate the sounded pitch from the written one. 
  attribute trans.semi { xsd:decimal }?
att.tupletpresent.attributes = att.tupletpresent.attribute.tuplet
att.tupletpresent.attribute.tuplet =
  
  ## indicates that this feature participates in a tuplet. If visual information about the tuplet needs to be recorded, then a <tuplet> element should be employed.
  attribute tuplet { data.TUPLETS }?
att.typed.attributes =
  att.typed.attribute.type, att.typed.attribute.subtype
att.typed.attribute.type =
  
  ## characterizes the element in some sense, using any convenient classification scheme or typology.
  attribute type { xsd:NMTOKEN }?
att.typed.attribute.subtype =
  
  ## provide any sub-classification for the element, additional to that given by its type attribute.
  attribute subtype { xsd:NMTOKEN }?
sch:pattern [
  id = "mei-att.typed-subtype-When_subtype-constraint-3"
  "\x{a}" ~
  "    "
  sch:rule [
    context = "mei:*[@subtype]"
    "\x{a}" ~
    "      "
    sch:assert [
      test = "@type"
      "An element with a subtype attribute must have a type\x{a}" ~
      "                  attribute."
    ]
    "\x{a}" ~
    "    "
  ]
  "\x{a}" ~
  "  "
]
att.typography.attributes =
  att.typography.attribute.fontfam,
  att.typography.attribute.fontname,
  att.typography.attribute.fontsize,
  att.typography.attribute.fontstyle,
  att.typography.attribute.fontweight
att.typography.attribute.fontfam =
  
  ## contains the name of a font-family.
  attribute fontfam { data.FONTFAMILY }?
att.typography.attribute.fontname =
  
  ## holds the name of a font.
  attribute fontname { data.FONTNAME }?
att.typography.attribute.fontsize =
  
  ## indicates the size of a font in printers' points, i.e., 1/72nd of an inch.
  attribute fontsize { xsd:decimal }?
att.typography.attribute.fontstyle =
  
  ## records the style of a font, i.e, italic, oblique, or normal.
  attribute fontstyle { data.FONTSTYLE }?
att.typography.attribute.fontweight =
  
  ## used to indicate bold type.
  attribute fontweight { data.FONTWEIGHT }?
att.visibility.attributes = att.visibility.attribute.visible
att.visibility.attribute.visible =
  
  ## indicates if a feature should be rendered when the notation is presented graphically or sounded when it is presented in an aural form.
  attribute visible { data.BOOLEAN }?
att.visualoffset.attributes =
  att.visualoffset.ho.attributes,
  att.visualoffset.to.attributes,
  att.visualoffset.vo.attributes
att.visualoffset.ho.attributes = att.visualoffset.ho.attribute.ho
att.visualoffset.ho.attribute.ho =
  
  ## records a horizontal adjustment to a feature's programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
  attribute ho { data.MEASUREMENT }?
att.visualoffset.to.attributes = att.visualoffset.to.attribute.to
att.visualoffset.to.attribute.to =
  
  ## records a timestamp adjustment of a feature's programmatically-determined location in terms of musical time; that is, beats.
  attribute to { data.TSTAMPOFFSET }?
att.visualoffset.vo.attributes = att.visualoffset.vo.attribute.vo
att.visualoffset.vo.attribute.vo =
  
  ## records the vertical adjustment of a feature's programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
  attribute vo { data.MEASUREMENT }?
att.visualoffset2.attributes =
  att.visualoffset2.ho.attributes,
  att.visualoffset2.to.attributes,
  att.visualoffset2.vo.attributes
att.visualoffset2.ho.attributes =
  att.visualoffset2.ho.attribute.startho,
  att.visualoffset2.ho.attribute.endho
att.visualoffset2.ho.attribute.startho =
  
  ## records the horizontal adjustment of a feature's programmatically-determined start point.
  attribute startho { data.MEASUREMENT }?
att.visualoffset2.ho.attribute.endho =
  
  ## records the horizontal adjustment of a feature's programmatically-determined end point.
  attribute endho { data.MEASUREMENT }?
att.visualoffset2.to.attributes =
  att.visualoffset2.to.attribute.startto,
  att.visualoffset2.to.attribute.endto
att.visualoffset2.to.attribute.startto =
  
  ## records a timestamp adjustment of a feature's programmatically-determined start point.
  attribute startto { data.TSTAMPOFFSET }?
att.visualoffset2.to.attribute.endto =
  
  ## records a timestamp adjustment of a feature's programmatically-determined end point.
  attribute endto { data.TSTAMPOFFSET }?
att.visualoffset2.vo.attributes =
  att.visualoffset2.vo.attribute.startvo,
  att.visualoffset2.vo.attribute.endvo
att.visualoffset2.vo.attribute.startvo =
  
  ## records a vertical adjustment of a feature's programmatically-determined start point.
  attribute startvo { data.MEASUREMENT }?
att.visualoffset2.vo.attribute.endvo =
  
  ## records a vertical adjustment of a feature's programmatically-determined end point.
  attribute endvo { data.MEASUREMENT }?
att.whitespace.attributes = att.whitespace.attribute.xmlspace
att.whitespace.attribute.xmlspace =
  
  ## allows one to signal to an application whether an element's white space is "significant". The behavior of xml:space cascades to all descendant elements, but it can be turned off locally by setting the xml:space attribute to the value "default".
  attribute xml:space {
    
    ## allows the application to handle white space as necessary. Not including an xml:space attribute produces the same result as using the default value.
    "default"
    | 
      ## instructs the application to maintain white space "as-is", suggesting that it might have meaning.
      "preserve"
  }?
att.width.attributes = att.width.attribute.width
att.width.attribute.width =
  
  ## measurement of the horizontal dimension of an entity. The width attribute may be used to capture measure width data for interchange with music printing systems that utilize this information for printing. On <barLine> the width attribute captures the width of the preceding measure.
  attribute width { data.MEASUREMENT }?
att.xy.attributes = att.xy.attribute.x, att.xy.attribute.y
att.xy.attribute.x =
  
  ## encodes an x coordinate for a feature in an output coordinate system. When it is necessary to record the placement of a feature in a facsimile image, use the facs attribute.
  attribute x { xsd:decimal }?
att.xy.attribute.y =
  
  ## encodes an y coordinate for a feature in an output coordinate system. When it is necessary to record the placement of a feature in a facsimile image, use the facs attribute.
  attribute y { xsd:decimal }?
att.xy2.attributes = att.xy2.attribute.x2, att.xy2.attribute.y2
att.xy2.attribute.x2 =
  
  ## encodes the optional 2nd x coordinate.
  attribute x2 { xsd:decimal }?
att.xy2.attribute.y2 =
  
  ## encodes the optional 2nd y coordinate.
  attribute y2 { xsd:decimal }?
model.addressLike = address
model.addressLike_alternation = address
model.addressLike_sequence = address
model.addressLike_sequenceOptional = address?
model.addressLike_sequenceOptionalRepeatable = address*
model.addressLike_sequenceRepeatable = address+
model.annotLike = annot
model.annotLike_alternation = annot
model.annotLike_sequence = annot
model.annotLike_sequenceOptional = annot?
model.annotLike_sequenceOptionalRepeatable = annot*
model.annotLike_sequenceRepeatable = annot+
model.biblLike = bibl
model.biblLike_alternation = bibl
model.biblLike_sequence = bibl
model.biblLike_sequenceOptional = bibl?
model.biblLike_sequenceOptionalRepeatable = bibl*
model.biblLike_sequenceRepeatable = bibl+
model.biblPart =
  model.editionLike
  | model.respLike
  | biblScope
  | creation
  | extent
  | genre
  | imprint
  | physLoc
  | recipient
  | relatedItem
  | series
  | textLang
model.captionLike = caption
model.controleventLike =
  dir
  | dynam
  | phrase
  | tempo
  | model.controleventLike.cmn
  | bend
  | gliss
  | model.controleventLike.harmony
model.controleventLike_alternation =
  dir
  | dynam
  | phrase
  | tempo
  | model.controleventLike.cmn_alternation
  | bend
  | gliss
  | model.controleventLike.harmony_alternation
model.controleventLike_sequence =
  dir,
  dynam,
  phrase,
  tempo,
  model.controleventLike.cmn_sequence,
  bend,
  gliss,
  model.controleventLike.harmony_sequence
model.controleventLike_sequenceOptional =
  dir?,
  dynam?,
  phrase?,
  tempo?,
  model.controleventLike.cmn_sequenceOptional?,
  bend?,
  gliss?,
  model.controleventLike.harmony_sequenceOptional?
model.controleventLike_sequenceOptionalRepeatable =
  dir*,
  dynam*,
  phrase*,
  tempo*,
  model.controleventLike.cmn_sequenceOptionalRepeatable*,
  bend*,
  gliss*,
  model.controleventLike.harmony_sequenceOptionalRepeatable*
model.controleventLike_sequenceRepeatable =
  dir+,
  dynam+,
  phrase+,
  tempo+,
  model.controleventLike.cmn_sequenceRepeatable+,
  bend+,
  gliss+,
  model.controleventLike.harmony_sequenceRepeatable+
model.dateLike = date
model.dateLike_alternation = date
model.dateLike_sequence = date
model.dateLike_sequenceOptional = date?
model.dateLike_sequenceOptionalRepeatable = date*
model.dateLike_sequenceRepeatable = date+
model.editionLike = edition
model.editorialLike = abbr | expan | instrName | instrConfig | fingering
model.editorialLike_alternation =
  abbr | expan | instrName | instrConfig | fingering
model.editorialLike_sequence =
  abbr, expan, instrName, instrConfig, fingering
model.editorialLike_sequenceOptional =
  abbr?, expan?, instrName?, instrConfig?, fingering?
model.editorialLike_sequenceOptionalRepeatable =
  abbr*, expan*, instrName*, instrConfig*, fingering*
model.editorialLike_sequenceRepeatable =
  abbr+, expan+, instrName+, instrConfig+, fingering+
model.endingLike = ending
model.eventLike =
  model.keySigLike
  | model.meterSigLike
  | barLine
  | chord
  | clef
  | clefGrp
  | custos
  | note
  | pad
  | rest
  | space
  | model.eventLike.cmn
  | model.eventLike.mensural
  | tabChord
model.identifierLike = identifier
model.identifierLike_alternation = identifier
model.identifierLike_sequence = identifier
model.identifierLike_sequenceOptional = identifier?
model.identifierLike_sequenceOptionalRepeatable = identifier*
model.identifierLike_sequenceRepeatable = identifier+
model.imprintPart = distributor | publisher | pubPlace
model.incipLike = incip
model.instrDefLike = instrDef
model.keyAccidLike = keyAccid
model.keySigLike = keySig
model.keySigLike_alternation = keySig
model.keySigLike_sequence = keySig
model.keySigLike_sequenceOptional = keySig?
model.keySigLike_sequenceOptionalRepeatable = keySig*
model.keySigLike_sequenceRepeatable = keySig+
model.labelLike = label
model.layerDefLike = layerDef
model.layerLike = layer
model.layerPart =
  model.eventLike
  | model.layerPart.mensuralAndNeumes
  | model.layerPart.cmn
model.layerPart.mensuralAndNeumes =
  model.scoreDefLike
  | model.staffDefLike
  | model.layerPart.mensural
  | model.layerPart.neumes
  | model.midiLike
model.lbLike = lb
model.lbLike_alternation = lb
model.lbLike_sequence = lb
model.lbLike_sequenceOptional = lb?
model.lbLike_sequenceOptionalRepeatable = lb*
model.lbLike_sequenceRepeatable = lb+
model.mdivLike = mdiv
model.measurementLike = model.numLike
model.measurementLike_alternation = model.numLike_alternation
model.measurementLike_sequence = model.numLike_sequence
model.measurementLike_sequenceOptional = model.numLike_sequenceOptional?
model.measurementLike_sequenceOptionalRepeatable =
  model.numLike_sequenceOptionalRepeatable*
model.measurementLike_sequenceRepeatable =
  model.numLike_sequenceRepeatable+
model.meterSigLike = meterSig | meterSigGrp
model.meterSigLike_alternation = meterSig | meterSigGrp
model.meterSigLike_sequence = meterSig, meterSigGrp
model.meterSigLike_sequenceOptional = meterSig?, meterSigGrp?
model.meterSigLike_sequenceOptionalRepeatable = meterSig*, meterSigGrp*
model.meterSigLike_sequenceRepeatable = meterSig+, meterSigGrp+
model.milestoneLike.music = model.pbLike | sb
model.milestoneLike.text = model.lbLike | model.pbLike
model.milestoneLike.text_alternation =
  model.lbLike_alternation | model.pbLike_alternation
model.milestoneLike.text_sequence =
  model.lbLike_sequence, model.pbLike_sequence
model.milestoneLike.text_sequenceOptional =
  model.lbLike_sequenceOptional?, model.pbLike_sequenceOptional?
model.milestoneLike.text_sequenceOptionalRepeatable =
  model.lbLike_sequenceOptionalRepeatable*,
  model.pbLike_sequenceOptionalRepeatable*
model.milestoneLike.text_sequenceRepeatable =
  model.lbLike_sequenceRepeatable+, model.pbLike_sequenceRepeatable+
model.nameLike = name
model.nameLike_alternation = name
model.nameLike_sequence = name
model.nameLike_sequenceOptional = name?
model.nameLike_sequenceOptionalRepeatable = name*
model.nameLike_sequenceRepeatable = name+
model.noteModifierLike = accid | artic | dot
model.noteModifierLike_alternation = accid | artic | dot
model.noteModifierLike_sequence = accid, artic, dot
model.noteModifierLike_sequenceOptional = accid?, artic?, dot?
model.noteModifierLike_sequenceOptionalRepeatable = accid*, artic*, dot*
model.noteModifierLike_sequenceRepeatable = accid+, artic+, dot+
model.numLike = num
model.numLike_alternation = num
model.numLike_sequence = num
model.numLike_sequenceOptional = num?
model.numLike_sequenceOptionalRepeatable = num*
model.numLike_sequenceRepeatable = num+
model.paracontentPart =
  model.textphraseLike
  | model.editLike
  | model.transcriptionLike
  | model.tableLike
  | model.listLike
  | model.quoteLike
model.partLike = part
model.partsLike = parts
model.pbLike = pb
model.pbLike_alternation = pb
model.pbLike_sequence = pb
model.pbLike_sequenceOptional = pb?
model.pbLike_sequenceOptionalRepeatable = pb*
model.pbLike_sequenceRepeatable = pb+
model.pLike = p
model.rendLike = rend | stack
model.rendLike_alternation = rend | stack
model.rendLike_sequence = rend, stack
model.rendLike_sequenceOptional = rend?, stack?
model.rendLike_sequenceOptionalRepeatable = rend*, stack*
model.rendLike_sequenceRepeatable = rend+, stack+
model.repositoryLike = repository
model.repositoryLike_alternation = repository
model.repositoryLike_sequence = repository
model.repositoryLike_sequenceOptional = repository?
model.repositoryLike_sequenceOptionalRepeatable = repository*
model.repositoryLike_sequenceRepeatable = repository+
model.resourceLike = facsimile | performance
model.respLike =
  arranger
  | author
  | composer
  | editor
  | funder
  | librettist
  | lyricist
  | respStmt
  | sponsor
model.scoreDefLike = scoreDef
model.scoreDefLike_alternation = scoreDef
model.scoreDefLike_sequence = scoreDef
model.scoreDefLike_sequenceOptional = scoreDef?
model.scoreDefLike_sequenceOptionalRepeatable = scoreDef*
model.scoreDefLike_sequenceRepeatable = scoreDef+
model.scoreLike = score
model.scorePart =
  model.endingLike
  | model.scoreDefLike
  | model.scorePart.mensuralAndNeumes
  | model.sectionLike
  | model.staffDefLike
model.scorePart.mensuralAndNeumes = notAllowed
model.sectionLike = section
model.sectionPart =
  model.endingLike
  | model.scoreDefLike
  | model.sectionLike
  | model.sectionPart.mensuralAndNeumes
  | model.staffDefLike
  | model.sectionPart.cmn
model.sectionPart.mensuralAndNeumes =
  model.staffLike
  | model.sectionPart.mensural
  | model.sectionPart.neumes
model.staffDefLike = staffDef
model.staffDefLike_alternation = staffDef
model.staffDefLike_sequence = staffDef
model.staffDefLike_sequenceOptional = staffDef?
model.staffDefLike_sequenceOptionalRepeatable = staffDef*
model.staffDefLike_sequenceRepeatable = staffDef+
model.staffDefPart =
  model.keySigLike
  | model.meterSigLike
  | clef
  | clefGrp
  | model.staffDefPart.mensural
model.staffGrpLike = staffGrp
model.staffLike = staff
model.staffLike_alternation = staff
model.staffLike_sequence = staff
model.staffLike_sequenceOptional = staff?
model.staffLike_sequenceOptionalRepeatable = staff*
model.staffLike_sequenceRepeatable = staff+
model.staffPart =
  model.layerLike
  | model.staffPart.mensuralAndNeumes
  | model.ossiaLike
  | fingering
  | tabChord
  | tabBarre
  | connectingLine
model.staffPart.mensuralAndNeumes =
  model.scoreDefLike
  | model.staffDefLike
  | model.staffPart.mensural
  | model.staffPart.neumes
model.textcomponentLike =
  model.pLike
  | model.tableLike
  | model.lgLike
  | model.listLike
  | model.quoteLike
model.textphraseLike =
  model.addressLike
  | model.annotLike
  | model.biblLike
  | model.dateLike
  | model.editorialLike
  | model.identifierLike
  | model.measurementLike
  | model.milestoneLike.text
  | model.nameLike
  | model.rendLike
  | model.titleLike
  | model.figureLike
  | model.nameLike.agent
  | model.nameLike.label
  | model.nameLike.place
  | model.locrefLike
model.textphraseLike.limited =
  model.addressLike
  | model.biblLike
  | model.dateLike
  | model.editorialLike
  | model.identifierLike
  | model.lbLike
  | model.measurementLike
  | model.nameLike
  | model.rendLike
  | model.titleLike
  | model.figureLike
  | model.nameLike.agent
  | model.nameLike.label
  | model.nameLike.place
  | model.locrefLike
model.titleLike = title
model.titleLike_alternation = title
model.titleLike_sequence = title
model.titleLike_sequenceOptional = title?
model.titleLike_sequenceOptionalRepeatable = title*
model.titleLike_sequenceRepeatable = title+
accid =
  
  ## (accidental)  Records a temporary alteration to the pitch of a note. 
  element accid {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.typography.attributes,
    att.accid.log.attributes,
    att.accid.vis.attributes,
    att.accid.ges.attributes,
    att.accid.anl.attributes,
    empty
  }
actor =
  
  ## Name of an actor appearing within a cast list.
  element actor {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
address =
  
  ## Contains a postal address, for example of a publisher, an organization, or an individual. 
  element address {
    addrLine+,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
addrLine =
  
  ## (address line)  Single line of a postal address. 
  element addrLine {
    (text
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
annot =
  
  ## (annotation)  Provides a short statement explaining the text or indicating the basis for an assertion. 
  element annot {
    (text
     | model.textcomponentLike
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.bibl.attributes,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.source.attributes,
    att.typed.attributes,
    att.annot.log.attributes,
    att.annot.vis.attributes,
    att.annot.ges.attributes,
    att.annot.anl.attributes,
    att.plist.attributes,
    att.responsibility.attributes,
    empty
  }
arranger =
  
  ## A person or organization who transcribes a musical composition, usually for a different medium from that of the original; in an arrangement the musical substance remains essentially unchanged.
  element arranger {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.facsimile.attributes,
    att.typed.attributes,
    empty
  }
artic =
  
  ## (articulation)  An indication of how to play a note or chord. 
  element artic {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.typography.attributes,
    att.artic.log.attributes,
    att.artic.vis.attributes,
    att.artic.ges.attributes,
    att.artic.anl.attributes,
    empty
  }
author =
  
  ## The name of the creator of the intellectual content of a non-musical, literary work.
  element author {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.facsimile.attributes,
    att.typed.attributes,
    empty
  }
barLine =
  
  ## Vertical line drawn through one or more staves that divides musical notation into metrical units. 
  element barLine {
    empty
    >> sch:pattern [
         id = "mei-barLine-Check_barLinetaktplace-constraint-4"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:barLine[@taktplace]"
           "\x{a}" ~
           "          "
           sch:let [ name = "staff" value = "ancestor::mei:staff/@n" ]
           "\x{a}" ~
           "          "
           sch:let [
             name = "staffpos"
             value =
               "count(ancestor::mei:staff/preceding-sibling::mei:staff)               + 1"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "number(@taktplace) <= number(2 *               preceding::mei:staffDef[@n=$staff and @lines][1]/@lines)"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.pointing.attributes,
    att.barLine.log.attributes,
    att.barLine.vis.attributes,
    att.barLine.ges.attributes,
    att.barLine.anl.attributes,
    empty
  }
bibl =
  
  ## (bibliographic reference)  Provides a loosely-structured bibliographic citation in which the sub-components may or may not be explicitly marked. 
  element bibl {
    (text | model.biblPart | model.imprintPart | model.textphraseLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.pointing.attributes,
    empty
  }
biblList =
  
  ## List of bibliographic references.
  element biblList {
    head?,
    model.biblLike*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.typed.attributes,
    empty
  }
biblScope =
  
  ## (scope of citation)  Defines the scope of a bibliographic reference, for example as a list of page numbers, or a named subdivision of a larger work.
  element biblScope {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.facsimile.attributes,
    att.measurement.attributes,
    empty
  }
body =
  
  ## Contains the whole of a single musical text, excluding any front or back matter. 
  element body {
    model.mdivLike+,
    att.common.attributes,
    att.declaring.attributes,
    empty
  }
caption =
  
  ## A label which accompanies an illustration or a table.
  element caption {
    (text
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
castGrp =
  
  ## (cast group)  Groups one or more individual castItem elements within a cast list.
  element castGrp {
    (castItem | castGrp | roleDesc)+,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
castItem =
  
  ## Contains a single entry within a cast list, describing either a single role or a list of non-speaking roles.
  element castItem {
    (text | role | roleDesc | actor | instrVoice)+,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
castList =
  
  ## Contains a single cast list or dramatis personae.
  element castList {
    model.headLike?,
    (castItem | castGrp)+,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
chord =
  
  ## A simultaneous sounding of two or more notes in the same layer *with the same duration*.
  element chord {
    (note | artic | model.editLike | model.transcriptionLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.chord.log.attributes,
    att.chord.vis.attributes,
    att.chord.ges.attributes,
    att.chord.anl.attributes,
    empty
  }
clef =
  
  ## Indication of the exact location of a particular note on the staff and, therefore, the other notes as well. 
  element clef {
    empty
    >> sch:pattern [
         id = "mei-clef-Clef_position_lines-constraint-5"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:clef[ancestor::mei:staffDef[@lines]]"
           "\x{a}" ~
           "          "
           sch:let [
             name = "thisstaff"
             value = "ancestor::mei:staffDef/@n"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "number(@line) <=               number(ancestor::mei:staffDef[@n=$thisstaff and @lines][1]/@lines)"
             "The clef position\x{a}" ~
             "              must be less than or equal to the number of lines on the staff."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ]
    >> sch:pattern [
         id = "mei-clef-Clef_position_nolines-constraint-6"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:clef[ancestor::mei:staffDef[not(@lines)]]"
           "\x{a}" ~
           "          "
           sch:let [
             name = "thisstaff"
             value = "ancestor::mei:staffDef/@n"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "number(@line) <=               number(preceding::mei:staffDef[@n=$thisstaff and @lines][1]/@lines)"
             "The clef position\x{a}" ~
             "              must be less than or equal to the number of lines on the staff."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.event.attributes,
    att.facsimile.attributes,
    att.clef.anl.attributes,
    att.clef.ges.attributes,
    att.clef.log.attributes,
    att.clef.vis.attributes,
    empty
  }
clefGrp =
  
  ## (clef group)  A set of simultaneously-occurring clefs.
  element clefGrp {
    clef+,
    att.common.attributes,
    att.event.attributes,
    att.facsimile.attributes,
    att.clefGrp.log.attributes,
    att.clefGrp.vis.attributes,
    att.clefGrp.ges.attributes,
    att.clefGrp.anl.attributes,
    empty
  }
composer =
  
  ## The name of the creator of the intellectual content of a musical work.
  element composer {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.facsimile.attributes,
    att.typed.attributes,
    empty
  }
creation =
  
  ## Non-bibliographic details of the creation of an intellectual entity, in narrative form, such as the date, place, and circumstances of its composition. 
  element creation {
    (text | date | geogName)*,
    att.common.attributes,
    att.bibl.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
custos =
  
  ## Symbol placed at the end of a line of music to indicate the first note of the next line. Sometimes called a "direct". 
  element custos {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.source.attributes,
    att.custos.log.attributes,
    att.custos.vis.attributes,
    att.custos.ges.attributes,
    att.custos.anl.attributes,
    empty
  }
date =
  
  ## A string identifying a point in time or the time period between two such points.
  element date {
    (text | model.textphraseLike)*,
    att.bibl.attributes,
    att.calendared.attributes,
    att.common.attributes,
    att.datable.attributes,
    att.edit.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
dir =
  
  ## (directive)  A text expression that is on the score (typically above, below, or between staves, but not on the staff) not encoded elsewhere in more specific elements, such as <tempo> or <dynam>. 
  element dir {
    ((text
      | model.textphraseLike.limited
      | model.graphicprimitiveLike
      | model.editLike
      | model.transcriptionLike)*)
    >> sch:pattern [
         id = "mei-dir-dir_start-type_attributes_required-constraint-7"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:dir[not(ancestor::mei:syllable)]"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             " Must have one of\x{a}" ~
             "              the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.typed.attributes,
    att.dir.log.attributes,
    att.dir.vis.attributes,
    att.dir.ges.attributes,
    att.dir.anl.attributes,
    empty
  }
distributor =
  
  ## Name of a person or other agency responsible for the distribution of a bibliographic item.
  element distributor {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.facsimile.attributes,
    empty
  }
dot =
  
  ## Dot of augmentation or division. 
  element dot {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.dot.log.attributes,
    att.dot.vis.attributes,
    att.dot.ges.attributes,
    att.dot.anl.attributes,
    empty
  }
dynam =
  
  ## (dynamic)  Indication of the volume of a note, phrase, or section of music. 
  element dynam {
    ((text
      | model.textphraseLike.limited
      | model.editLike
      | model.transcriptionLike)*)
    >> sch:pattern [
         id =
           "mei-dynam-dynam_start-type_attributes_required-constraint-8"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:dynam"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             " Must have one of\x{a}" ~
             "              the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.dynam.log.attributes,
    att.dynam.vis.attributes,
    att.dynam.ges.attributes,
    att.dynam.anl.attributes,
    empty
  }
edition =
  
  ## (edition designation)  A word or text phrase that indicates a difference in either content or form between the item being described and a related item previously issued by the same publisher/distributor (e.g. 2nd edition, version 2.0, etc.), or simultaneously issued by either the same publisher/distributor or another publisher/distributor (e.g. large print edition, British edition, etc.). 
  element edition {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
editor =
  
  ## The name of the individual(s), institution(s) or organization(s) acting in an editorial capacity.
  element editor {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.facsimile.attributes,
    att.typed.attributes,
    empty
  }
ending =
  
  ## Alternative ending for a repeated passage of music; i.e., prima volta, seconda volta, etc. 
  element ending {
    expansion*,
    (model.appLike
     | model.divLike
     | model.milestoneLike.music
     | model.annotLike
     | model.graphicprimitiveLike
     | model.editLike
     | model.transcriptionLike
     | model.sectionPart)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.typed.attributes,
    att.pointing.attributes,
    att.ending.anl.attributes,
    att.ending.ges.attributes,
    att.ending.log.attributes,
    att.ending.vis.attributes,
    empty
  }
expansion =
  
  ## Indicates how a section may be programmatically expanded into its 'through-composed' form. 
  element expansion {
    empty,
    att.common.attributes,
    att.source.attributes,
    att.typed.attributes,
    att.plist.attributes,
    empty
  }
extent =
  
  ## Used to express size in terms other than physical dimensions, such as number of pages, number of records in file, number of bytes, performance duration for music, audio recordings and visual projections, etc. 
  element extent {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.facsimile.attributes,
    att.measurement.attributes,
    empty
  }
funder =
  
  ## Names of individuals, institutions, or organizations responsible for funding. Funders provide financial support for a project; they are distinct from sponsors, who provide intellectual support and authority.
  element funder {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.facsimile.attributes,
    empty
  }
fw =
  
  ## (forme work)  This element is intended for capture of header/footer material that is non-repeating; that is, occuring on isolated pages. For recurring headers and footers use pgHead* and pgFoot* elements. 
  element fw {
    (text
     | model.textcomponentLike
     | model.textphraseLike.limited
     | model.editLike
     | model.transcriptionLike
     | model.appLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.typed.attributes,
    empty
  }
genre =
  
  ## Term or terms that designate a category characterizing a particular style, form, or content.
  element genre {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    att.facsimile.attributes,
    empty
  }
group =
  
  ## Contains a composite musical text, grouping together a sequence of distinct musical texts (or groups of such musical texts) which are regarded as a unit for some purpose, for example, the collected works of a composer. 
  element group {
    (music | group),
    (music | group)*,
    att.common.attributes,
    att.declaring.attributes,
    empty
  }
grpSym =
  
  ## (group symbol)  A brace or bracket used to group two or more staves of a score or part. 
  element grpSym {
    model.labelLike*,
    att.common.attributes,
    att.facsimile.attributes,
    att.grpSym.log.attributes,
    att.grpSym.vis.attributes,
    att.grpSym.ges.attributes,
    att.grpSym.anl.attributes,
    empty
  }
identifier =
  
  ## An alpha-numeric string that establishes the identity of the described material. 
  element identifier {
    (text
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.authorized.attributes,
    att.bibl.attributes,
    att.common.attributes,
    att.facsimile.attributes,
    att.typed.attributes,
    empty
  }
imprint =
  
  ## Information relating to the publication or distribution of a bibliographic item.
  element imprint {
    ((model.imprintPart | model.dateLike),
     respStmt*,
     model.annotLike*)+,
    att.common.attributes,
    att.bibl.attributes,
    att.facsimile.attributes,
    empty
  }
incip =
  
  ## (incipit)  The opening music and/or words of a composition. 
  element incip {
    (incipCode | incipText | model.scoreLike | model.graphicLike)*,
    att.common.attributes,
    att.bibl.attributes,
    att.typed.attributes,
    empty
  }
keyAccid =
  
  ## (key accidental)  Accidental in a key signature. 
  element keyAccid {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.keyAccid.anl.attributes,
    att.keyAccid.ges.attributes,
    att.keyAccid.log.attributes,
    att.keyAccid.vis.attributes,
    
    ## specifies whether enharmonic (written) values or implicit ("perform-able") values are allowed.
    attribute form {
      
      ## only performed values (sharp, flat, natural) allowed.
      "implicit"
      | 
        ## all enharmonic (written) values allowed.
        "explicit"
    }?,
    empty
  }
keySig =
  
  ## (key signature)  Written key signature. 
  element keySig {
    model.keyAccidLike*,
    att.common.attributes,
    att.facsimile.attributes,
    att.keySig.anl.attributes,
    att.keySig.ges.attributes,
    att.keySig.log.attributes,
    att.keySig.vis.attributes,
    empty
  }
label =
  
  ## A container for text that identifies the feature to which it is attached.
  element label {
    (text
     | model.textphraseLike.limited
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.source.attributes,
    att.typed.attributes,
    empty
  }
layer =
  
  ## An independent stream of events on a staff. 
  element layer {
    ((model.appLike
      | model.divLike
      | model.milestoneLike.music
      | model.annotLike
      | model.graphicprimitiveLike
      | model.editLike
      | model.transcriptionLike
      | model.layerPart)*)
    >> sch:pattern [
         id = "mei-layer-Check_layern-constraint-9"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:layer[@n]"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "number(@n) = round(number(@n))"
             "The n attribute must be a single\x{a}" ~
             "              integer."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.declaring.attributes,
    att.facsimile.attributes,
    att.layer.log.attributes,
    att.layer.vis.attributes,
    att.layer.ges.attributes,
    att.layer.anl.attributes,
    empty
  }
layerDef =
  
  ## (layer definition)  Container for layer meta-information.
  element layerDef {
    model.labelLike*,
    (model.instrDefLike*)
    >> sch:pattern [
         id = "mei-layerDef-Check_layerDefn-constraint-10"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:layerDef"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "number(@n) = round(number(@n))"
             "An n attribute with a single integer\x{a}" ~
             "              value must be present."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.declaring.attributes,
    att.layerDef.log.attributes,
    att.layerDef.vis.attributes,
    att.layerDef.ges.attributes,
    att.layerDef.anl.attributes,
    empty
  }
lb =
  
  ## (line break)  An empty formatting element that forces text to begin on a new line. 
  element lb {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.source.attributes,
    att.typed.attributes,
    
    ## states whether the line break follows a single line or a line group.
    attribute func {
      
      ##
      "line"
      | 
        ##
        "group"
    }?,
    empty
  }
librettist =
  
  ## Person or organization who is a writer of the text of an opera, oratorio, etc.
  element librettist {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.facsimile.attributes,
    att.typed.attributes,
    empty
  }
lyricist =
  
  ## Person or organization who is a writer of the text of a song.
  element lyricist {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.facsimile.attributes,
    att.typed.attributes,
    empty
  }
mdiv =
  
  ## (musical division)  contains a subdivision of the body of a musical text. 
  element mdiv {
    ((model.scoreLike?, model.partsLike?) | model.mdivLike*),
    att.common.attributes,
    att.declaring.attributes,
    att.facsimile.attributes,
    att.typed.attributes,
    empty
  }
mei =
  
  ## Contains a single MEI-conformant document, consisting of an MEI header and a musical text, either in isolation or as part of an meiCorpus element. 
  element mei {
    meiHead,
    music
    >> sch:ns [
         prefix = "mei"
         uri = "http://www.music-encoding.org/ns/mei"
       ]
    >> sch:pattern [
         id = "mei-mei-Check_staff-constraint-11"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:*[@staff]"
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "every $i in tokenize(@staff, '\s+') satisfies               $i=//mei:staffDef/@n"
             "The values in @staff must correspond to @n attribute of a\x{a}" ~
             "              staffDef element."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.meiversion.attributes,
    att.id.attributes,
    empty
  }
music =
  
  ## Contains a single musical text of any kind, whether unitary or composite, for example, an etude, opera, song cycle, symphony, or anthology of piano solos.
  element music {
    model.alignLike*,
    model.resourceLike*,
    macro.musicPart,
    att.common.attributes,
    att.declaring.attributes,
    att.meiversion.attributes,
    empty
  }
name =
  
  ## Proper noun or noun phrase. 
  element name {
    (text
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.bibl.attributes,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.name.attributes,
    att.typed.attributes,
    empty
  }
note =
  
  ## A single pitched event. 
  element note {
    (model.noteModifierLike
     | model.verseLike
     | model.sylLike
     | model.appLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.note.log.attributes,
    att.note.vis.attributes,
    att.note.ges.attributes,
    att.note.anl.attributes,
    empty
  }
num =
  
  ## (number)  Numeric information in any form. 
  element num {
    (text
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.measurement.attributes,
    empty
  }
p =
  
  ## (paragraph)  One or more text phrases that form a logical prose passage. 
  element p {
    (text | model.paracontentPart)*,
    att.common.attributes,
    att.declaring.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.xy.attributes,
    empty
  }
pad =
  
  ## (padding)  An indication of extra visual space between notational elements.
  element pad {
    empty,
    att.common.attributes,
    att.pad.log.attributes,
    att.pad.vis.attributes,
    att.pad.ges.attributes,
    att.pad.anl.attributes,
    empty
  }
part =
  
  ## An alternative visual rendition of the score from the point of view of a particular performer (or group of performers). 
  element part {
    (model.appLike
     | model.divLike
     | model.milestoneLike.music
     | model.annotLike
     | model.graphicprimitiveLike
     | model.editLike
     | model.transcriptionLike
     | model.scorePart)*,
    att.common.attributes,
    att.declaring.attributes,
    att.typed.attributes,
    att.part.log.attributes,
    att.part.vis.attributes,
    att.part.ges.attributes,
    att.part.anl.attributes,
    empty
  }
parts =
  
  ## Provides a container for performers' parts.
  element parts {
    model.partLike*,
    att.common.attributes,
    att.declaring.attributes,
    att.typed.attributes,
    att.parts.log.attributes,
    att.parts.vis.attributes,
    att.parts.ges.attributes,
    att.parts.anl.attributes,
    empty
  }
pb =
  
  ## (page break)  An empty formatting element that forces text to begin on a new page. 
  element pb {
    macro.metaLike.page,
    att.common.attributes,
    att.facsimile.attributes,
    att.pointing.attributes,
    att.source.attributes,
    att.pb.anl.attributes,
    att.pb.ges.attributes,
    att.pb.log.attributes,
    att.pb.vis.attributes,
    empty
  }
pgDesc =
  
  ## (page description)  Contains a brief prose description of the appearance or description of the content of a physical page. 
  element pgDesc {
    (text
     | model.graphicprimitiveLike
     | model.textcomponentLike
     | model.annotLike
     | model.locrefLike)*,
    att.common.attributes,
    att.lang.attributes,
    empty
  }
pgFoot =
  
  ## (page footer)  A running footer on the first page. 
  element pgFoot {
    (text
     | model.textcomponentLike
     | model.textphraseLike.limited
     | model.editLike
     | model.transcriptionLike
     | model.appLike
     | anchoredText)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
pgFoot2 =
  
  ## (page footer 2)  A running footer on the pages following the first. 
  element pgFoot2 {
    (text
     | model.textcomponentLike
     | model.textphraseLike.limited
     | model.editLike
     | model.transcriptionLike
     | model.appLike
     | anchoredText)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
pgHead =
  
  ## (page header)  A running header on the first page. 
  element pgHead {
    (text
     | model.textcomponentLike
     | model.textphraseLike.limited
     | model.editLike
     | model.transcriptionLike
     | model.appLike
     | anchoredText)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
pgHead2 =
  
  ## (page header 2)  A running header on the pages following the first. 
  element pgHead2 {
    (text
     | model.textcomponentLike
     | model.textphraseLike.limited
     | model.editLike
     | model.transcriptionLike
     | model.appLike
     | anchoredText)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
phrase =
  
  ## Indication of 1) a "unified melodic idea" or 2) performance technique. 
  element phrase {
    empty
    >> sch:pattern [
         id =
           "mei-phrase-phrase_start-_and_end-type_attributes_required-constraint-12"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:phrase"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             " Must have one of\x{a}" ~
             "              the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@dur or @dur.ges or @endid or @tstamp2"
             "Must have one of the\x{a}" ~
             "              attributes: dur, dur.ges, endid, or tstamp2"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.phrase.log.attributes,
    att.phrase.vis.attributes,
    att.phrase.ges.attributes,
    att.phrase.anl.attributes,
    empty
  }
physLoc =
  
  ## (physical location)  Groups information about the physical location of a bibliographic item, such as the repository in which it is located and its shelf mark.
  element physLoc {
    model.repositoryLike?,
    model.identifierLike*,
    att.common.attributes,
    att.bibl.attributes,
    att.facsimile.attributes,
    empty
  }
publisher =
  
  ## Name of the organization responsible for the publication of a bibliographic item.
  element publisher {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.facsimile.attributes,
    empty
  }
pubPlace =
  
  ## (publication place)  Name of the place where a bibliographic item was published.
  element pubPlace {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.facsimile.attributes,
    empty
  }
recipient =
  
  ## The name of the individual(s), institution(s) or organization(s) receiving correspondence.
  element recipient {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.facsimile.attributes,
    empty
  }
relatedItem =
  
  ## (related item)  Contains or references another bibliographic item which is related to the present one.
  element relatedItem {
    model.biblLike*,
    att.datapointing.attributes,
    att.common.attributes,
    att.bibl.attributes,
    att.facsimile.attributes,
    att.pointing.attributes,
    
    ## describes the relationship between the <relatedItem> and the resource described in the parent element, i.e., <bibl>, <source> or <relatedItem>. The values are based on MODS version 3.4. The subject of these relations is always the <relatedItem>, and the object is always the parent of the <relatedItem>. "preceding" and "succeeding" indicate temporal order.
    attribute rel {
      
      ## predecessor of the resource
      "preceding"
      | 
        ## successor to the resource
        "succeeding"
      | 
        ## original form of the resource
        "original"
      | 
        ## parent containing the resource
        "host"
      | 
        ## intellectual or physical component of the resource
        "constituent"
      | 
        ## version of the resource's intellectual content not changed enough to be a different work
        "otherVersion"
      | 
        ## version of the resource in a different physical format
        "otherFormat"
      | 
        ## published bibliographic description, review, abstract, or index of the resource's content
        "isReferencedBy"
      | 
        ## cited or referred to in the resource
        "references"
    },
    empty
  }
rend =
  
  ## (render)  A formatting element indicating special visual rendering, e.g., bold or italicized, of a text word or phrase. 
  element rend {
    (text
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.color.attributes,
    att.common.attributes,
    att.horizontalalign.attributes,
    att.lang.attributes,
    att.typography.attributes,
    att.whitespace.attributes,
    
    ## used to extend the values of the rend attribute.
    attribute altrend { text }?,
    
    ## captures the appearance of the element's contents using MEI-defined descriptors.
    attribute rend { data.TEXTRENDITION }?,
    
    ## A positive value for rotation rotates the text in a counter-clockwise fashion, while negative values produce clockwise rotation.
    attribute rotation { data.DEGREES }?,
    
    ## specifies the vertical position of the element content relative to the surrounding text.
    attribute valign {
      
      ## aligns the top of the content with the top of the surrounding text.
      "top"
      | 
        ## aligns the middle of the content with the middle of the surrounding text.
        "middle"
      | 
        ## aligns the bottom of the content with the bottom of the surrounding text.
        "bottom"
      | 
        ## aligns the baseline of the content with the baseline of the surrounding text.
        "baseline"
    }?,
    empty
  }
repository =
  
  ## Institution, agency, or individual which holds a bibliographic item. 
  element repository {
    (text | model.textphraseLike.limited)*,
    att.bibl.attributes,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.name.attributes,
    att.typed.attributes,
    empty
  }
resp =
  
  ## (responsibility)  A phrase describing the nature of intellectual responsibility. 
  element resp {
    text,
    att.common.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    att.coded.attributes,
    att.facsimile.attributes,
    empty
  }
respStmt =
  
  ## (responsibility statement)  Names one or more individuals, groups, or in rare cases, mechanical processes, responsible for creation or realization of the intellectual or artistic content. 
  element respStmt {
    (resp | model.nameLike | model.nameLike.agent)*,
    att.common.attributes,
    att.bibl.attributes,
    att.facsimile.attributes,
    empty
  }
rest =
  
  ## A non-sounding event found in the source being transcribed. 
  element rest {
    empty
    >> sch:pattern [
         id = "mei-rest-Check_restline-constraint-13"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:rest[@line]"
           "\x{a}" ~
           "          "
           sch:let [
             name = "thisstaff"
             value = "ancestor::mei:staff/@n"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "number(@line) <=               number(preceding::mei:staffDef[@n=$thisstaff and @lines][1]/@lines)"
             "The value of\x{a}" ~
             "              @line must be less than or equal to the number of lines on the staff."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.rest.log.attributes,
    att.rest.vis.attributes,
    att.rest.ges.attributes,
    att.rest.anl.attributes,
    empty
  }
role =
  
  ## Name of a dramatic role, as given in a cast list.
  element role {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
roleDesc =
  
  ## (role description)  Describes a character's role in a drama.
  element roleDesc {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
sb =
  
  ## (system break)  An empty formatting element that forces musical notation to begin on a new line. 
  element sb {
    custos?,
    att.common.attributes,
    att.facsimile.attributes,
    att.source.attributes,
    att.sb.log.attributes,
    att.sb.vis.attributes,
    att.sb.ges.attributes,
    att.sb.anl.attributes,
    empty
  }
score =
  
  ## Full score view of the musical content. 
  element score {
    (model.appLike
     | model.divLike
     | model.milestoneLike.music
     | model.annotLike
     | model.graphicprimitiveLike
     | model.editLike
     | model.transcriptionLike
     | model.scorePart)*,
    att.common.attributes,
    att.declaring.attributes,
    att.typed.attributes,
    att.score.log.attributes,
    att.score.vis.attributes,
    att.score.ges.attributes,
    att.score.anl.attributes,
    empty
  }
scoreDef =
  
  ## (score definition)  Container for score meta-information.
  element scoreDef {
    model.alignLike*,
    model.chordTableLike?,
    model.symbolTableLike?,
    model.keySigLike?,
    model.meterSigLike?,
    pgHead?,
    pgHead2?,
    pgFoot?,
    pgFoot2?,
    instrGrp?,
    model.staffGrpLike?,
    att.common.attributes,
    att.scoreDef.log.attributes,
    att.scoreDef.vis.attributes,
    att.scoreDef.ges.attributes,
    att.scoreDef.anl.attributes,
    empty
  }
section =
  
  ## Segment of music data. 
  element section {
    expansion*,
    ((model.appLike
      | model.divLike
      | model.milestoneLike.music
      | model.annotLike
      | model.graphicprimitiveLike
      | model.editLike
      | model.transcriptionLike
      | model.sectionPart)*)
    >> sch:pattern [
         id = "mei-section-Check_sectionexpansion-constraint-14"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:section[mei:expansion]"
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "descendant::mei:section|descendant::mei:ending|descendant::mei:rdg"
             "Must have descendant section, ending, or rdg elements that can be pointed\x{a}" ~
             "              to."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.declaring.attributes,
    att.facsimile.attributes,
    att.typed.attributes,
    att.pointing.attributes,
    att.section.log.attributes,
    att.section.vis.attributes,
    att.section.ges.attributes,
    att.section.anl.attributes,
    empty
  }
series =
  
  ## Contains information about the serial publication in which a bibliographic item has appeared.
  element series {
    (model.titleLike
     | model.locrefLike
     | editor
     | respStmt
     | extent
     | model.identifierLike
     | model.pLike)*,
    att.common.attributes,
    att.bibl.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
space =
  
  ## A placeholder used to fill an incomplete measure, layer, etc. most often so that the combined duration of the events equals the number of beats in the measure.
  element space {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.space.log.attributes,
    att.space.vis.attributes,
    att.space.ges.attributes,
    att.space.anl.attributes,
    empty
  }
sponsor =
  
  ## Names of sponsoring individuals, organizations or institutions. Sponsors give their intellectual authority to a project; they are to be distinguished from funders, who provide the funding but do not necessarily take intellectual responsibility.
  element sponsor {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.facsimile.attributes,
    empty
  }
stack =
  
  ## (stacked text)  An inline table with a single column.
  element stack {
    (text | model.textphraseLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    
    ## indicates the delimiter used to mark the portions of text that are to be stacked.
    attribute delim { text }?,
    
    ## specifies how the stacked text components should be aligned.
    attribute align {
      
      ## left justified.
      "left"
      | 
        ## right justified.
        "right"
      | 
        ## centered.
        "center"
      | 
        ## aligned on right-most digit.
        "rightdigit"
    }?,
    empty
  }
staff =
  
  ## A group of equidistant horizontal lines on which notes are placed in order to represent pitch or a grouping element for individual 'strands' of notes, rests, etc. that may or may not actually be rendered on staff lines; that is, both diastematic and non-diastematic signs. 
  element staff {
    ((model.appLike
      | model.divLike
      | model.milestoneLike.music
      | model.annotLike
      | model.graphicprimitiveLike
      | model.editLike
      | model.transcriptionLike
      | model.staffPart)*)
    >> sch:pattern [
         id = "mei-staff-Check_staffn-constraint-15"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:staff[@n]"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "number(@n) = round(number(@n))"
             "The n attribute must be a single\x{a}" ~
             "              integer."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.declaring.attributes,
    att.facsimile.attributes,
    att.staff.log.attributes,
    att.staff.vis.attributes,
    att.staff.ges.attributes,
    att.staff.anl.attributes,
    empty
  }
staffDef =
  
  ## (staff definition)  Container for staff meta-information.
  element staffDef {
    model.labelLike*,
    ((model.instrDefLike | model.layerDefLike | model.staffDefPart)*)
    >> sch:pattern [
         id = "mei-staffDef-Check_staffDefn-constraint-16"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:staffDef"
           "\x{a}" ~
           "          "
           sch:let [ name = "thisstaff" value = "@n" ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@n"
             "A staffDef must have an n attribute."
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "@lines or preceding::mei:staffDef[@n=$thisstaff and @lines]"
             "The first\x{a}" ~
             "              occurrence of a staff must declare the number of staff lines."
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "count(mei:clef) + count(mei:clefGrp) < 2"
             "Only one clef or clefGrp\x{a}" ~
             "              is permitted."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ]
    >> sch:pattern [
         id = "mei-staffDef-Check_ancestor_staff-constraint-17"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:staffDef[ancestor::mei:staff]"
           "\x{a}" ~
           "          "
           sch:let [ name = "thisstaff" value = "@n" ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "ancestor::mei:staff/@n eq $thisstaff"
             "If a staffDef appears in a\x{a}" ~
             "              staff, it must bear the same @n than this staff."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ]
    >> sch:pattern [
         id = "mei-staffDef-Check_clef_position_staffDef-constraint-18"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:staffDef[@clef.line and @lines]"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "number(@clef.line) <= number(@lines)"
             "The clef position must be\x{a}" ~
             "              less than or equal to the number of lines on the staff."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ]
    >> sch:pattern [
         id =
           "mei-staffDef-Check_clef_position_staffDef_nolines-constraint-19"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:staffDef[@clef.line and not(@lines)]"
           "\x{a}" ~
           "          "
           sch:let [ name = "thisstaff" value = "@n" ]
           "\x{a}" ~
           "          "
           sch:let [
             name = "stafflines"
             value =
               "preceding::mei:staffDef[@n=$thisstaff and               @lines][1]/@lines"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "number(@clef.line) <= number($stafflines)"
             "The clef position must\x{a}" ~
             "              be less than or equal to the number of lines on the staff."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ]
    >> sch:pattern [
         id = "mei-staffDef-Check_tab_strings_lines-constraint-20"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:staffDef[@tab.strings and @lines]"
           "\x{a}" ~
           "          "
           sch:let [
             name = "countTokens"
             value =
               "count(tokenize(normalize-space(@tab.strings),               '\s'))"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "$countTokens = 1 or $countTokens = @lines"
             "The tab.strings attribute\x{a}" ~
             "              must have the same number of values as there are staff lines."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ]
    >> sch:pattern [
         id = "mei-staffDef-Check_tab_strings_nolines-constraint-21"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:staffDef[@tab.strings and not(@lines)]"
           "\x{a}" ~
           "          "
           sch:let [
             name = "countTokens"
             value =
               "count(tokenize(normalize-space(@tab.strings),               '\s'))"
           ]
           "\x{a}" ~
           "          "
           sch:let [ name = "thisStaff" value = "@n" ]
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "$countTokens = 1 or $countTokens =               preceding::mei:staffDef[@n=$thisStaff and @lines][1]/@lines"
             "The tab.strings attribute\x{a}" ~
             "              must have the same number of values as there are staff lines."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ]
    >> sch:pattern [
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:staffDef[@lines.color and @lines]"
           "\x{a}" ~
           "          "
           sch:let [
             name = "countTokens"
             value =
               "count(tokenize(normalize-space(@lines.color),                 '\s'))"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "$countTokens = 1 or $countTokens = @lines"
             "The lines.color attribute\x{a}" ~
             "                must have either 1) a single value or 2) the same number of values as there are\x{a}" ~
             "                staff lines."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:staffDef[@lines.color and not(@lines)]"
           "\x{a}" ~
           "          "
           sch:let [
             name = "countTokens"
             value =
               "count(tokenize(normalize-space(@lines.color),                 '\s'))"
           ]
           "\x{a}" ~
           "          "
           sch:let [ name = "thisStaff" value = "@n" ]
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "$countTokens = 1 or $countTokens =                 preceding::mei:staffDef[@n=$thisStaff and @lines][1]/@lines"
             "The lines.color\x{a}" ~
             "                attribute must have either 1) a single value or 2) the same number of values as\x{a}" ~
             "                there are staff lines."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ]
    >> sch:pattern [
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:staffDef[@ppq][ancestor::mei:scoreDef[@ppq]]"
           "\x{a}" ~
           "          "
           sch:let [ name = "staffPPQ" value = "@ppq" ]
           "\x{a}" ~
           "          "
           sch:let [
             name = "scorePPQ"
             value = "ancestor::mei:scoreDef[@ppq][1]/@ppq"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "($scorePPQ mod $staffPPQ) = 0"
             "The value of ppq must be a factor of\x{a}" ~
             "                the value of ppq on an ancestor scoreDef."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ]
    >> sch:pattern [
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:staffDef[@ppq][preceding::mei:scoreDef[@ppq]]"
           "\x{a}" ~
           "          "
           sch:let [ name = "staffPPQ" value = "@ppq" ]
           "\x{a}" ~
           "          "
           sch:let [
             name = "scorePPQ"
             value = "preceding::mei:scoreDef[@ppq][1]/@ppq"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "($scorePPQ mod $staffPPQ) = 0"
             "The value of ppq must be a factor of\x{a}" ~
             "                the value of ppq on a preceding scoreDef."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.declaring.attributes,
    att.staffDef.log.attributes,
    att.staffDef.vis.attributes,
    att.staffDef.ges.attributes,
    att.staffDef.anl.attributes,
    empty
  }
staffGrp =
  
  ## (staff group)  A group of bracketed or braced staves. 
  element staffGrp {
    grpSym*,
    model.labelLike*,
    model.instrDefLike*,
    (model.staffGrpLike | model.staffDefLike)+,
    (grpSym*)
    >> sch:pattern [
         id =
           "mei-staffGrp-Check_staffGrp_unique_staff_n_values-constraint-26"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:staffGrp"
           "\x{a}" ~
           "          "
           sch:let [
             name = "countstaves"
             value = "count(descendant::mei:staffDef)"
           ]
           "\x{a}" ~
           "          "
           sch:let [
             name = "countuniqstaves"
             value =
               "count(distinct-values(descendant::mei:staffDef/@n))"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "$countstaves eq $countuniqstaves"
             "Each staffDef must have a unique\x{a}" ~
             "              value for the n attribute."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.declaring.attributes,
    att.facsimile.attributes,
    att.staffGrp.log.attributes,
    att.staffGrp.vis.attributes,
    att.staffGrp.ges.attributes,
    att.staffGrp.anl.attributes,
    empty
  }
syl =
  
  ## (syllable)  Individual lyric syllable. 
  element syl {
    (text
     | model.textphraseLike.limited
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.syl.log.attributes,
    att.syl.vis.attributes,
    att.syl.ges.attributes,
    att.syl.anl.attributes,
    empty
  }
tempo =
  
  ## Text and symbols descriptive of tempo, mood, or style, e.g., "allarg.", "a tempo", "cantabile", "Moderato", "=60", "Moderato  =60").
  element tempo {
    ((text
      | model.textphraseLike.limited
      | model.graphicprimitiveLike
      | model.editLike
      | model.transcriptionLike)*)
    >> sch:pattern [
         id =
           "mei-tempo-tempo_in_header_disallow_most_attrs-constraint-27"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:tempo[ancestor::mei:meiHead]"
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "not(@*[name() != 'label' and name() != 'n' and name() !=               'xml:base' and name() != 'xml:id' and name() != 'xml:lang'])"
             "Only label, n, xml:base,\x{a}" ~
             "              xml:id, and xml:lang attributes allowed when this element occurs in the\x{a}" ~
             "              header."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ]
    >> sch:pattern [
         id =
           "mei-tempo-tempo_start-type_attributes_required-constraint-28"
         "\x{a}" ~
         "        "
         sch:rule [
           context =
             "mei:tempo[not(ancestor::mei:syllable) and not(ancestor::mei:meiHead)]"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             " Must have one of\x{a}" ~
             "              the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.tempo.log.attributes,
    att.tempo.vis.attributes,
    att.tempo.ges.attributes,
    att.tempo.anl.attributes,
    empty
  }
textLang =
  
  ## (text language)  Identifies the languages and writing systems within the work described by a bibliographic description, not the language of the description.
  element textLang {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.facsimile.attributes,
    
    ## (main language) supplies a code which identifies the chief language used in the bibliographic work.
    attribute mainLang { xsd:language }?,
    
    ## (other languages) one or more codes identifying any other languages used in the bibliographic work.
    attribute otherLangs {
      list { xsd:language+ }
    }?,
    empty
  }
title =
  
  ## Title of a bibliographic entity. 
  element title {
    (text
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.authorized.attributes,
    att.canonical.attributes,
    att.bibl.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.typed.attributes,
    
    ## indicates the bibliographic level for a title.
    attribute level {
      
      ## article.
      "a"
      | 
        ## monograph.
        "m"
      | 
        ## journal.
        "j"
      | 
        ## series.
        "s"
      | 
        ## unpublished (including theses and dissertations unless published by a commercial press).
        "u"
    }?,
    empty
  }
titlePage =
  
  ## Contains a transcription of the title page of a text. 
  element titlePage {
    (model.textcomponentLike | model.milestoneLike.text)+,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
att.regularmethod.attributes = att.regularmethod.attribute.method
att.regularmethod.attribute.method =
  
  ## indicates the method employed to mark corrections and normalizations.
  attribute method {
    
    ## corrections and normalizations made silently.
    "silent"
    | 
      ## corrections and normalizations indicated using elements.
      "tags"
  }?
model.editorialDeclPart =
  correction | interpretation | normalization | segmentation | stdVals
model.encodingPart_sequenceOptional =
  appInfo?, editorialDecl?, projectDesc?, samplingDecl?
model.eventPart =
  model.addressLike
  | model.dateLike
  | model.nameLike
  | model.nameLike.agent
  | model.nameLike.geogName
model.frontPart = titlePage
model.headerPart_sequenceOptional = encodingDesc?, workDesc?
model.physDescPart =
  extent
  | model.frontPart
  | captureMode
  | carrierForm
  | condition
  | dimensions
  | exhibHist
  | fileChar
  | fingerprint
  | handList
  | inscription
  | physMedium
  | plateNum
  | playingSpeed
  | provenance
  | soundChan
  | specRepro
  | tapeConfig
  | treatHist
  | treatSched
  | watermark
model.pubStmtPart =
  model.addressLike
  | model.dateLike
  | model.identifierLike
  | distributor
  | publisher
  | pubPlace
  | respStmt
  | availability
model.workIdent = model.incipLike | tempo | key | mensuration | meter
model.workLike = work
accessRestrict =
  
  ## (access restriction)  Describes the conditions that affect the accessibility of material. 
  element accessRestrict {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
acqSource =
  
  ## (acquisition source)  Post-publication source, such as a vendor or distributor, from which access to a bibliographic item may be obtained, including electronic access. 
  element acqSource {
    (text | model.textphraseLike.limited)*,
    att.bibl.attributes,
    att.common.attributes,
    att.lang.attributes,
    empty
  }
altId =
  
  ## (alternative identifier)  May contain a bibliographic identifier that does not fit within the meiHead element's id attribute, for example because the id does not fit the definition of an XML id or because multiple identifiers are needed. 
  element altId {
    (text | model.lbLike | model.rendLike)*,
    att.bibl.attributes,
    att.common.attributes,
    att.typed.attributes,
    empty
  }
appInfo =
  
  ## (application information)  Groups information about applications which have acted upon the MEI file. 
  element appInfo { application*, att.common.attributes, empty }
application =
  
  ## Provides information about an application which has acted upon the current document. 
  element application {
    model.nameLike+,
    (model.locrefLike* | model.pLike*),
    att.common.attributes,
    att.datable.attributes,
    att.typed.attributes,
    
    ## supplies a version number for an application, independent of its identifier or display name.
    attribute version { text }?,
    empty
  }
audience =
  
  ## Defines the class of user for which the work is intended, as defined by age group (e.g., children, young adults, adults, etc.), educational level (e.g., primary, secondary, etc.), or other categorization.
  element audience {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    empty
  }
availability =
  
  ## Groups elements that describe the availability of and access to a bibliographic item, including an MEI-encoded document. 
  element availability {
    macro.availabilityPart,
    att.bibl.attributes,
    att.common.attributes,
    att.datapointing.attributes,
    empty
  }
captureMode =
  
  ## (capture mode)  The means used to record notation, sound, or images in the production of a source/manifestation (e.g., analogue, acoustic, electric, digital, optical etc.).
  element captureMode {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    empty
  }
carrierForm =
  
  ## (carrier form)  The specific class of material to which the physical carrier of the source/manifestation belongs (e.g., sound cassette, videodisc, microfilm cartridge, transparency, etc.). The carrier for a manifestation comprising multiple physical components may include more than one form (e.g., a filmstrip with an accompanying booklet, a separate sound disc carrying the sound track for a film, etc.).
  element carrierForm {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    empty
  }
change =
  
  ## Individual change within the revision description. 
  element change {
    respStmt?,
    changeDesc,
    (model.dateLike?)
    >> sch:pattern [
         id = "mei-change-change_requirements-constraint-29"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:change"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@isodate or mei:date"
             "The date of the change must be recorded in an\x{a}" ~
             "              isodate attribute or date element."
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@resp or mei:respStmt"
             "The person responsible for the change must be\x{a}" ~
             "              recorded in a resp attribute or respStmt element."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.bibl.attributes,
    att.datable.attributes,
    att.responsibility.attributes,
    empty
  }
changeDesc =
  
  ## (change description)  Description of a revision of the MEI file.
  element changeDesc {
    model.pLike+,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
classCode =
  
  ## (classification code)  Holds a citation to the source of controlled-vocabulary terms used in the <termList> element; for example, Library of Congress Subject Headings (LCSH), Library of Congress Classification (LCC), Library of Congress Name Authority File (LCNAF), or other thesaurus or ontology. 
  element classCode {
    (text | model.lbLike | model.rendLike)*,
    att.common.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    empty
  }
classification =
  
  ## Groups information which describes the nature or topic of an entity. 
  element classification {
    (classCode | termList)+,
    att.common.attributes,
    att.bibl.attributes,
    att.datapointing.attributes,
    empty
  }
condition =
  
  ## The physical condition of an item, particularly any variances between the physical makeup of the item and that of other copies of the same item (e.g., missing pages, plates, etc.). 
  element condition {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
contentItem =
  
  ## Contains a single entry within a content description element.
  element contentItem {
    text*, att.bibl.attributes, att.common.attributes, empty
  }
contents =
  
  ## Description of the material contained within a resource.
  element contents {
    model.headLike?,
    (model.pLike? | (model.labelLike?, contentItem)+),
    att.common.attributes,
    att.bibl.attributes,
    att.pointing.attributes,
    empty
  }
context =
  
  ## The historical, social, intellectual, artistic, or other context within which the work was originally conceived (e.g., the 17th century restoration of the monarchy in England, the aesthetic movement of the late 19th century, etc.) or the historical, social, intellectual, artistic, or other context within which the expression was realized.
  element context {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    empty
  }
correction =
  
  ## States how and under what circumstances corrections have been made in the text. 
  element correction {
    model.pLike+,
    att.common.attributes,
    att.bibl.attributes,
    att.datapointing.attributes,
    att.lang.attributes,
    att.regularmethod.attributes,
    
    ## indicates the degree of correction applied to the text.
    attribute corrlevel {
      
      ## the text has been thoroughly checked and proofread.
      "high"
      | 
        ## the text has been checked at least once.
        "medium"
      | 
        ## the text has not been checked.
        "low"
      | 
        ## the correction status of the text is unknown.
        "unknown"
    }?,
    empty
  }
dimensions =
  
  ## Information about the physical size of a bibliographic source; usually includes numerical data. 
  element dimensions {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.measurement.attributes,
    empty
  }
editionStmt =
  
  ## (edition statement)  Container for meta-data pertaining to a particular edition of the material being described. 
  element editionStmt {
    (model.editionLike, respStmt*)+,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
editorialDecl =
  
  ## (editorial declaration)  Used to provide details of editorial principles and practices applied during the encoding of musical text. 
  element editorialDecl {
    (model.pLike+ | (model.editorialDeclPart+, model.pLike*)),
    att.common.attributes,
    att.bibl.attributes,
    att.datapointing.attributes,
    att.lang.attributes,
    empty
  }
encodingDesc =
  
  ## (encoding description)  Documents the relationship between an electronic file and the source or sources from which it was derived as well as applications used in the encoding/editing process. 
  element encodingDesc {
    model.encodingPart_sequenceOptional,
    att.bibl.attributes,
    att.common.attributes,
    empty
  }
ensemble =
  
  ## The name of a standard instrumental or vocal grouping, such as 'orchestra' or 'marching band'. 
  element ensemble {
    text,
    att.common.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    att.coded.attributes,
    empty
  }
event =
  
  ## Contains a description of an event, including the dates and locations of its occurrence and prominent participants.
  element event {
    model.headLike?,
    (model.eventPart
     | model.pLike
     | model.tableLike
     | \list
     | castList)*,
    biblList*,
    att.bibl.attributes,
    att.calendared.attributes,
    att.common.attributes,
    att.datable.attributes,
    att.edit.attributes,
    att.lang.attributes,
    empty
  }
eventList =
  
  ## Contains historical information given as a sequence of significant past events. 
  element eventList {
    model.headLike?,
    event+,
    biblList*,
    att.bibl.attributes,
    att.common.attributes,
    att.typed.attributes,
    empty
  }
exhibHist =
  
  ## (exhibition history)  A record of public exhibitions, including dates, venues, etc. 
  element exhibHist {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
fileChar =
  
  ## (file characteristics)  Standards or schemes used to encode the file (e.g., ASCII, SGML, etc.), physical characteristics of the file (e.g., recording density, parity, blocking, etc.), and other characteristics that have a bearing on how the file can be processed.
  element fileChar {
    text, att.common.attributes, att.bibl.attributes, empty
  }
fileDesc =
  
  ## (file description)  Contains a full bibliographic description of the MEI file. 
  element fileDesc {
    titleStmt,
    editionStmt?,
    extent?,
    pubStmt,
    seriesStmt?,
    notesStmt?,
    sourceDesc?,
    att.bibl.attributes,
    att.common.attributes,
    empty
  }
fingerprint =
  
  ## Contains a string that uniquely identifies an item, such as those constructed by combining groups of characters transcribed from specified pages of a printed item or a file's checksum.
  element fingerprint {
    text,
    att.common.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    empty
  }
hand =
  
  ## Defines a distinct scribe or handwriting style. 
  element hand {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    att.medium.attributes,
    att.responsibility.attributes,
    
    ## marks this hand as the first one of the document.
    attribute initial { data.BOOLEAN }?,
    empty
  }
handList =
  
  ## Container for one or more hand elements. 
  element handList {
    hand+, att.common.attributes, att.bibl.attributes, empty
  }
history =
  
  ## Provides a container for information about the creation and history of a resource.
  element history {
    model.headLike?,
    creation?,
    (eventList | p)*,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
incipCode =
  
  ## Incipit coded in a non-XML, plain text format, such as Plaine & Easie Code.
  element incipCode {
    text
    >> sch:pattern [
         id =
           "mei-incipCode-Check_incipCode_form_mimetype-constraint-30"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:incipCode"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@form or @mimetype"
             "incipCode must have a form or mimetype\x{a}" ~
             "              attribute."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.bibl.attributes,
    att.internetmedia.attributes,
    att.pointing.attributes,
    att.whitespace.attributes,
    
    ## form of the encoded incipit.
    ## Suggested values include: 1] plaineAndEasie; 2] humdrumKern; 3] parsons
    attribute form {
      
      ## Plaine & Easie Code.
      "plaineAndEasie"
      | 
        ## Humdrum Kern format.
        "humdrumKern"
      | 
        ## Parsons code.
        "parsons"
      | xsd:Name
    }?,
    empty
  }
incipText =
  
  ## Opening words of a musical composition.
  element incipText {
    (model.pLike | model.lgLike)*,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    att.pointing.attributes,
    att.internetmedia.attributes,
    empty
  }
inscription =
  
  ## An inscription added to an item, such as a bookplate, a note designating the item as a gift, and/or the author's signature.
  element inscription {
    (text
     | model.textphraseLike.limited
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
instrumentation =
  
  ## Instrumental and non-dramatic vocal resources.
  element instrumentation {
    head?,
    (ensemble | instrVoice | instrVoiceGrp)*,
    att.common.attributes,
    att.bibl.attributes,
    att.authorized.attributes,
    empty
  }
instrVoice =
  
  ## (instrument or voice)  Name of an instrument on which a performer plays or a performer's voice range.
  element instrVoice {
    (text | model.instrvoicePart)*,
    att.common.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    att.coded.attributes,
    
    ## indicates the number of performers.
    attribute count { xsd:positiveInteger }?,
    
    ## marks this instrument or vocal part as a soloist. Do not use this attribute for a solo instrument which is not accompanied.
    attribute solo { data.BOOLEAN }?,
    empty
  }
instrVoiceGrp =
  
  ## Several instrumental or vocal resources treated as a group.
  element instrVoiceGrp {
    (text | model.headLike | instrVoice | instrVoiceGrp)*,
    att.common.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    att.coded.attributes,
    empty
  }
interpretation =
  
  ## Describes the scope of any analytic or interpretive information added to the transcription of the music. 
  element interpretation {
    model.pLike+,
    att.common.attributes,
    att.bibl.attributes,
    att.datapointing.attributes,
    att.lang.attributes,
    empty
  }
key =
  
  ## Key captures information about tonal center and mode. 
  element key {
    text,
    att.common.attributes,
    att.bibl.attributes,
    att.keySig.log.attributes,
    empty
  }
language =
  
  ## Description of a language used in the document. 
  element language {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.authorized.attributes,
    empty
  }
langUsage =
  
  ## (language usage)  Groups elements describing the languages, sub-languages, dialects, etc., represented within the encoded resource. 
  element langUsage {
    language+,
    att.common.attributes,
    att.bibl.attributes,
    att.datapointing.attributes,
    empty
  }
meiHead =
  
  ## (MEI header)  Supplies the descriptive and declarative metadata prefixed to every MEI-conformant text. 
  element meiHead {
    altId*,
    fileDesc,
    model.headerPart_sequenceOptional,
    revisionDesc?,
    att.bibl.attributes,
    att.common.attributes,
    att.lang.attributes,
    att.meiversion.attributes,
    
    ## specifies the kind of document to which the header is attached, for example whether it is a corpus or individual text.
    attribute type {
      
      ## header is attached to a music document.
      "music"
      | 
        ## header is attached to a corpus.
        "corpus"
    }?,
    empty
  }
mensuration =
  
  ## Captures information about mensuration within bibliographic descriptions.
  element mensuration {
    text,
    att.common.attributes,
    att.bibl.attributes,
    att.mensur.log.attributes,
    empty
  }
meter =
  
  ## Captures information about the time signature within bibliographic descriptions. 
  element meter {
    text,
    att.common.attributes,
    att.bibl.attributes,
    att.meterSig.log.attributes,
    empty
  }
normalization =
  
  ## Indicates the extent of normalization or regularization of the original source carried out in converting it to electronic form. 
  element normalization {
    model.pLike+,
    att.common.attributes,
    att.bibl.attributes,
    att.datapointing.attributes,
    att.lang.attributes,
    att.regularmethod.attributes,
    empty
  }
notesStmt =
  
  ## (notes statement) Collects any notes providing information about a text additional to that recorded in other parts of the bibliographic description. 
  element notesStmt {
    model.annotLike+, att.common.attributes, att.bibl.attributes, empty
  }
otherChar =
  
  ## (other distinguishing characteristic)  Any characteristic that serves to differentiate a work or expression from another.
  element otherChar {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
perfMedium =
  
  ## (performance medium)  Indicates the number and character of the performing forces used in a musical composition. 
  element perfMedium {
    model.headLike?,
    castList?,
    instrumentation?,
    att.common.attributes,
    att.bibl.attributes,
    att.authorized.attributes,
    empty
  }
physDesc =
  
  ## (physical description)  Container for information about the appearance, construction, or handling of physical materials, such as their dimension, quantity, color, style, and technique of creation. 
  element physDesc {
    model.pLike*,
    model.physDescPart*,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
physMedium =
  
  ## (physical medium)  Records the physical materials used in the source, such as ink and paper. 
  element physMedium {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.authorized.attributes,
    att.lang.attributes,
    empty
  }
plateNum =
  
  ## (plate number)  Designation assigned to a resource by a music publisher, usually printed at the bottom of each page, and sometimes appearing also on the title page. 
  element plateNum {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.facsimile.attributes,
    empty
  }
playingSpeed =
  
  ## Playing speed for a sound recording is the speed at which the carrier must be operated to produce the sound intended (e.g., 33 1/3 rpm, 19 cm/s, etc.)
  element playingSpeed {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
price =
  
  ## The cost of access to a bibliographic item.
  element price {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.measurement.attributes,
    empty
  }
projectDesc =
  
  ## (project description)  Project-level meta-data describing the aim or purpose for which the electronic file was encoded, funding agencies, etc. together with any other relevant information concerning the process by which it was assembled or collected. 
  element projectDesc {
    model.pLike+,
    att.common.attributes,
    att.bibl.attributes,
    att.datapointing.attributes,
    att.lang.attributes,
    empty
  }
provenance =
  
  ## The record of ownership or custodianship of an item. 
  element provenance {
    (eventList? | (text | model.textphraseLike.limited)*),
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
pubStmt =
  
  ## (publication statement)  Container for information regarding the publication or distribution of a bibliographic item, including the publisher's name and address, the date of publication, and other relevant details. 
  element pubStmt {
    (unpub? | model.pubStmtPart*),
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
revisionDesc =
  
  ## (revision description)  Container for information about alterations that have been made to an MEI file. 
  element revisionDesc {
    change+, att.common.attributes, att.bibl.attributes, empty
  }
samplingDecl =
  
  ## (sampling declaration)  Contains a prose description of the rationale and methods used in sampling texts in the creation of a corpus or collection. 
  element samplingDecl {
    model.pLike+,
    att.common.attributes,
    att.bibl.attributes,
    att.datapointing.attributes,
    att.lang.attributes,
    empty
  }
scoreFormat =
  
  ## Describes the type of score used to represent a musical composition (e.g., short score, full score, condensed score, close score, etc.).
  element scoreFormat {
    text,
    att.common.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    empty
  }
segmentation =
  
  ## Describes the principles according to which the musical text has been segmented, for example into movements, sections, etc. 
  element segmentation {
    model.pLike+,
    att.common.attributes,
    att.bibl.attributes,
    att.datapointing.attributes,
    att.lang.attributes,
    empty
  }
seriesStmt =
  
  ## (series statement)  Groups information about the series, if any, to which a publication belongs. 
  element seriesStmt {
    model.titleLike+,
    (editor | respStmt)*,
    (model.identifierLike | biblScope | contents | seriesStmt)*,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
soundChan =
  
  ## (sound channels)  Reflects the number of sound channels used to make a recording (monaural, stereophonic, quadraphonic, etc.).
  element soundChan {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    empty
  }
source =
  
  ## A bibliographic description of a source used in the creation of the electronic file.
  element source {
    model.identifierLike*,
    titleStmt?,
    macro.bibldescPart,
    contents?,
    langUsage?,
    notesStmt?,
    classification?,
    itemList?,
    componentGrp?,
    relationList?,
    att.common.attributes,
    att.bibl.attributes,
    att.datapointing.attributes,
    att.pointing.attributes,
    empty
  }
sourceDesc =
  
  ## (source description)  A container for the descriptions of the source(s) used in the creation of the electronic file. 
  element sourceDesc { source+, att.common.attributes, empty }
specRepro =
  
  ## (special reproduction characteristic)  The equalization system, noise reduction system, etc. used in making the recording (e.g., NAB, DBX, Dolby, etc.).
  element specRepro {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    empty
  }
stdVals =
  
  ## (standard values)  Specifies the format used when standardized date or number values are supplied. 
  element stdVals {
    model.pLike+,
    att.common.attributes,
    att.bibl.attributes,
    att.datapointing.attributes,
    att.lang.attributes,
    empty
  }
sysReq =
  
  ## (system requirements)  System requirements for using the electronic item.
  element sysReq {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
tapeConfig =
  
  ## (tape configuration)  Number of tracks on a sound tape (e.g., eight track, twelve track).
  element tapeConfig {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    empty
  }
term =
  
  ## Keyword or phrase which describes a resource. 
  element term {
    (text | term | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    
    ## contains a reference to the controlled vocabulary from which the term is drawn. The value must match the value of an ID attribute on a classCode element given elsewhere in the document.
    attribute classcode { data.URI }?,
    empty
  }
termList =
  
  ## Collection of text phrases which describe a resource.
  element termList {
    term+,
    att.common.attributes,
    att.bibl.attributes,
    
    ## contains a reference to the controlled vocabulary from which the terms are drawn. The value must match the value of an ID attribute on a classCode element given elsewhere in the document.
    attribute classcode { data.URI }?,
    empty
  }
titleStmt =
  
  ## (title statement)  Container for title and responsibility meta-data.
  element titleStmt {
    model.titleLike+,
    model.respLike*,
    att.bibl.attributes,
    att.common.attributes,
    empty
  }
treatHist =
  
  ## (treatment history)  A record of the treatment the item has undergone (e.g., de-acidification, restoration, etc.). 
  element treatHist {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
treatSched =
  
  ## (treatment scheduled)  Scheduled treatment, e.g. de-acidification, restoration, etc., for an item. 
  element treatSched {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
unpub =
  
  ## (unpublished)  Used to explicitly indicate that a bibliographic resource is unpublished. 
  element unpub {
    text, att.common.attributes, att.bibl.attributes, empty
  }
useRestrict =
  
  ## (usage restrictions)  Container for information about the conditions that affect use of a bibliographic item after access has been granted. 
  element useRestrict {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
watermark =
  
  ## Contains a description of a watermark or similar device. 
  element watermark {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.facsimile.attributes,
    empty
  }
work =
  
  ## Provides a detailed description of a work, specifically its history, language use, and high-level musical attributes: key, tempo, meter, and medium of performance.
  element work {
    model.identifierLike*,
    titleStmt?,
    model.workIdent*,
    otherChar?,
    history?,
    langUsage?,
    perfMedium?,
    audience?,
    contents?,
    context?,
    biblList*,
    notesStmt?,
    classification?,
    expressionList?,
    componentGrp?,
    relationList?,
    att.datapointing.attributes,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
workDesc =
  
  ## (work description)  Grouping mechanism for information describing non-bibliographic aspects of a text.
  element workDesc { work+, att.common.attributes, empty }
att.arpeg.anl.attributes = att.common.anl.attributes
att.arpeg.ges.attributes = empty
att.arpeg.log.attributes =
  att.controlevent.attributes, att.arpeg.log.attribute.order
att.arpeg.log.attribute.order =
  
  ## describes the direction in which an arpeggio is to be performed.
  attribute order {
    
    ## lowest to highest pitch.
    "up"
    | 
      ## highest to lowest pitch.
      "down"
    | 
      ## non-arpeggiated style (usually rendered with a preceding bracket instead of a wavy line).
      "nonarp"
  }?
att.arpeg.vis.attributes =
  att.color.attributes,
  att.visualoffset.attributes,
  att.xy.attributes,
  att.arpeg.vis.attribute.arrow
att.arpeg.vis.attribute.arrow =
  
  ## indicates if an arrowhead is to be drawn as part of the arpeggiation symbol.
  attribute arrow { data.BOOLEAN }?
att.beam.anl.attributes = att.common.anl.attributes
att.beam.ges.attributes = empty
att.beam.log.attributes =
  att.event.attributes, att.beamedwith.attributes
att.beam.vis.attributes = att.color.attributes, att.beamrend.attributes
att.beamed.attributes = att.beamed.attribute.beam
att.beamed.attribute.beam =
  
  ## indicates that this event is "under a beam".
  attribute beam { data.BEAMS }?
att.beamedwith.attributes = att.beamedwith.attribute.beam.with
att.beamedwith.attribute.beam.with =
  
  ## In the case of cross-staff beams, the beam.with attribute is used to indicate which staff the beam is connected to; that is, the staff above or the staff below.
  attribute beam.with { data.OTHERSTAFF }?
att.beaming.log.attributes =
  att.beaming.log.attribute.beam.group,
  att.beaming.log.attribute.beam.rests
att.beaming.log.attribute.beam.group =
  
  ## provides an example of how automated beaming (including secondary beams) is to be performed. 
  attribute beam.group { text }?
att.beaming.log.attribute.beam.rests =
  
  ## indicates whether automatically-drawn beams should include rests shorter than a quarter note duration.
  attribute beam.rests { data.BOOLEAN }?
att.beamrend.attributes =
  att.beamrend.attribute.rend, att.beamrend.attribute.slope
att.beamrend.attribute.rend =
  
  ## captures whether a beam is "feathered" and in which direction.
  attribute rend {
    
    ## (accelerando) indicates that the secondary beams get progressively closer together toward the end of the beam.
    "acc"
    | 
      ## (mixed acc and rit) for beams that are "feathered" in both directions.
      "mixed"
    | 
      ## (ritardando) means that the secondary beams become progressively more distant toward the end of the beam.
      "rit"
    | 
      ## (normal) indicates that the secondary beams are equidistant along the course of the beam.
      "norm"
  }?
att.beamrend.attribute.slope =
  
  ## records the slope of the beam.
  attribute slope { xsd:decimal }?
att.beamsecondary.attributes = att.beamsecondary.attribute.breaksec
att.beamsecondary.attribute.breaksec =
  
  ## presence of this attribute indicates that the secondary beam should be broken following this note/chord. The value of the attribute records the number of beams which should remain unbroken.
  attribute breaksec { xsd:positiveInteger }?
att.beamSpan.anl.attributes = att.common.anl.attributes
att.beamSpan.ges.attributes = att.duration.performed.attributes
att.beamSpan.log.attributes =
  att.controlevent.attributes,
  att.augmentdots.attributes,
  att.beamedwith.attributes,
  att.duration.additive.attributes,
  att.startendid.attributes,
  att.timestamp2.musical.attributes
att.beamSpan.vis.attributes = att.beam.vis.attributes
att.beatRpt.anl.attributes = att.common.anl.attributes
att.beatRpt.ges.attributes = empty
att.beatRpt.log.attributes = att.event.attributes
att.beatRpt.vis.attributes =
  att.altsym.attributes,
  att.color.attributes,
  att.expandable.attributes,
  att.beatRpt.vis.attribute.rend
att.beatRpt.vis.attribute.rend =
  
  ## indicates the number of slashes required to render the appropriate beat repeat symbol. When a single beat is repeated, consisting of a single note or chord, it is indicated by a single thick, slanting slash; therefore, the value '1' should be used. The following values should be used when the beat is divided into even notes: 4ths or 8ths=1, 16ths=2, 32nds=3, 64ths=4, 128ths=5. When the beat is comprised of mixed duration values, the symbol is always rendered as 2 slashes and 2 dots.
  attribute rend { data.BEATRPT.REND }
att.bend.anl.attributes = att.common.anl.attributes
att.bend.ges.attributes = att.bend.ges.attribute.amount
att.bend.ges.attribute.amount =
  
  ## records the amount of detuning. The decimal values should be rendered as a fraction (or an integer plus a fraction) along with the bend symbol.
  attribute amount { data.BEND.AMOUNT }?
att.bend.log.attributes =
  att.controlevent.attributes,
  att.augmentdots.attributes,
  att.duration.additive.attributes,
  att.startendid.attributes,
  att.timestamp2.musical.attributes
att.bend.vis.attributes =
  att.color.attributes,
  att.visualoffset.attributes,
  att.visualoffset2.attributes,
  att.xy.attributes,
  att.xy2.attributes,
  att.curvature.attributes,
  att.curverend.attributes
att.breath.anl.attributes = att.common.anl.attributes
att.breath.ges.attributes = empty
att.breath.log.attributes =
  att.controlevent.attributes,
  att.augmentdots.attributes,
  att.duration.additive.attributes,
  att.startendid.attributes,
  att.timestamp2.musical.attributes
att.breath.vis.attributes =
  att.altsym.attributes,
  att.color.attributes,
  att.placement.attributes,
  att.visualoffset.attributes,
  att.xy.attributes
att.bTrem.anl.attributes = att.common.anl.attributes
att.bTrem.ges.attributes = att.tremmeasured.attributes
att.bTrem.log.attributes =
  att.event.attributes,
  att.augmentdots.attributes,
  att.duration.musical.attributes,
  att.numbered.attributes,
  att.bTrem.log.attribute.form
att.bTrem.log.attribute.form =
  
  ## describes the style of the tremolo.
  attribute form {
    
    ## measured tremolo.
    "meas"
    | 
      ## unmeasured tremolo.
      "unmeas"
  }?
att.bTrem.vis.attributes = att.numberplacement.attributes
att.chord.ges.cmn.attributes = att.graced.attributes
att.chord.log.cmn.attributes =
  att.beamed.attributes, att.lvpresent.attributes, att.ornam.attributes
att.chord.vis.cmn.attributes = att.beamsecondary.attributes
att.cutout.attributes = att.cutout.attribute.cutout
att.cutout.attribute.cutout =
  
  ## "Cut-out" style indicated for this measure.
  attribute cutout {
    
    ## the staff lines should not be drawn.
    "cutout"
  }?
att.expandable.attributes = att.expandable.attribute.expand
att.expandable.attribute.expand =
  
  ## indicates whether to render a repeat symbol or the source material to which it refers. A value of 'true' renders the source material, while 'false' displays the repeat symbol.
  attribute expand { data.BOOLEAN }?
att.fermata.anl.attributes = att.common.anl.attributes
att.fermata.ges.attributes = att.duration.performed.attributes
att.fermata.log.attributes =
  att.controlevent.attributes, att.startendid.attributes
att.fermata.vis.attributes =
  att.altsym.attributes,
  att.color.attributes,
  att.placement.attributes,
  att.visualoffset.attributes,
  att.xy.attributes,
  att.fermata.vis.attribute.form,
  att.fermata.vis.attribute.shape
att.fermata.vis.attribute.form =
  
  ## describes the visual appearance of the fermata; that is, whether it occurs as upright or inverted.
  attribute form {
    
    ## inverted, i.e., curve or bracket below the dot.
    "inv"
    | 
      ## upright; i.e., curve or bracket above the dot.
      "norm"
  }?
att.fermata.vis.attribute.shape =
  
  ## describes the visual appearance of the fermata; that is, whether it has a curved or square shape.
  attribute shape {
    
    ## a curve above or below the dot.
    "curved"
    | 
      ## a bracket above or below the dot.
      "square"
  }?
att.fTrem.anl.attributes = att.common.anl.attributes
att.fTrem.ges.attributes = att.tremmeasured.attributes
att.fTrem.log.attributes =
  att.event.attributes,
  att.augmentdots.attributes,
  att.duration.musical.attributes,
  att.fTrem.log.attribute.form
att.fTrem.log.attribute.form =
  
  ## describes the style of the tremolo.
  attribute form {
    
    ## measured tremolo.
    "meas"
    | 
      ## unmeasured tremolo.
      "unmeas"
  }?
att.fTrem.vis.attributes = att.slashcount.attributes
att.gliss.anl.attributes = att.common.anl.attributes
att.gliss.ges.attributes = att.duration.performed.attributes
att.gliss.log.attributes =
  att.controlevent.attributes,
  att.augmentdots.attributes,
  att.duration.additive.attributes,
  att.startendid.attributes,
  att.timestamp2.musical.attributes
att.gliss.vis.attributes =
  att.color.attributes,
  att.visualoffset.attributes,
  att.visualoffset2.attributes,
  att.xy.attributes,
  att.xy2.attributes,
  att.linerend.attributes,
  att.gliss.vis.attribute.text
att.gliss.vis.attribute.text =
  
  ## records a text string, such as 'gliss', that accompanies the glissando mark.
  attribute text { text }?
att.graced.attributes =
  att.graced.attribute.grace, att.graced.attribute.grace.time
att.graced.attribute.grace =
  
  ## marks a note or chord as a "grace" (without a definitive written duration) and records from which other note/chord it should "steal" time.
  attribute grace { data.GRACE }?
att.graced.attribute.grace.time =
  
  ## records the amount of time to be "stolen" from a non-grace note/chord.
  attribute grace.time { data.PERCENT }?
att.hairpin.anl.attributes = att.common.anl.attributes
att.hairpin.ges.attributes = att.duration.performed.attributes
att.hairpin.log.attributes =
  att.controlevent.attributes,
  att.augmentdots.attributes,
  att.duration.additive.attributes,
  att.startendid.attributes,
  att.timestamp2.musical.attributes,
  att.hairpin.log.attribute.form
att.hairpin.log.attribute.form =
  
  ## captures the visual rendition and function of the hairpin; that is, whether it indicates an increase or a decrease in volume.
  attribute form {
    
    ## crescendo; i.e., louder.
    "cres"
    | 
      ## diminuendo; i.e., softer.
      "dim"
  }
att.hairpin.vis.attributes =
  att.color.attributes,
  att.placement.attributes,
  att.visualoffset.attributes,
  att.visualoffset2.attributes,
  att.xy.attributes,
  att.xy2.attributes,
  att.hairpin.vis.attribute.opening
att.hairpin.vis.attribute.opening =
  
  ## specifies the distance between the points of the open end of a hairpin dynamic mark.
  attribute opening { data.MEASUREMENT }?
att.halfmRpt.anl.attributes = att.common.anl.attributes
att.halfmRpt.ges.attributes = empty
att.halfmRpt.log.attributes =
  att.event.attributes, att.duration.musical.attributes
att.halfmRpt.vis.attributes =
  att.altsym.attributes,
  att.color.attributes,
  att.expandable.attributes,
  att.visualoffset.attributes
att.harpPedal.anl.attributes = att.common.anl.attributes
att.harpPedal.ges.attributes = att.duration.performed.attributes
att.harpPedal.log.attributes =
  att.controlevent.attributes,
  att.startendid.attributes,
  att.harpPedal.log.attribute.c,
  att.harpPedal.log.attribute.d,
  att.harpPedal.log.attribute.e,
  att.harpPedal.log.attribute.f,
  att.harpPedal.log.attribute.g,
  att.harpPedal.log.attribute.a,
  att.harpPedal.log.attribute.b
att.harpPedal.log.attribute.c =
  
  ## indicates the pedal setting for the harp's C strings.
  [ a:defaultValue = "n" ]
  attribute c {
    
    ## flat.
    "f"
    | 
      ## natural.
      "n"
    | 
      ## sharp.
      "s"
  }?
att.harpPedal.log.attribute.d =
  
  ## indicates the pedal setting for the harp's D strings.
  [ a:defaultValue = "n" ]
  attribute d {
    
    ## flat.
    "f"
    | 
      ## natural.
      "n"
    | 
      ## sharp.
      "s"
  }?
att.harpPedal.log.attribute.e =
  
  ## indicates the pedal setting for the harp's E strings.
  [ a:defaultValue = "n" ]
  attribute e {
    
    ## flat.
    "f"
    | 
      ## natural.
      "n"
    | 
      ## sharp.
      "s"
  }?
att.harpPedal.log.attribute.f =
  
  ## indicates the pedal setting for the harp's F strings.
  [ a:defaultValue = "n" ]
  attribute f {
    
    ## flat.
    "f"
    | 
      ## natural.
      "n"
    | 
      ## sharp.
      "s"
  }?
att.harpPedal.log.attribute.g =
  
  ## indicates the pedal setting for the harp's G strings.
  [ a:defaultValue = "n" ]
  attribute g {
    
    ## flat.
    "f"
    | 
      ## natural.
      "n"
    | 
      ## sharp.
      "s"
  }?
att.harpPedal.log.attribute.a =
  
  ## indicates the pedal setting for the harp's A strings.
  [ a:defaultValue = "n" ]
  attribute a {
    
    ## flat.
    "f"
    | 
      ## natural.
      "n"
    | 
      ## sharp.
      "s"
  }?
att.harpPedal.log.attribute.b =
  
  ## indicates the pedal setting for the harp's B strings.
  [ a:defaultValue = "n" ]
  attribute b {
    
    ## flat.
    "f"
    | 
      ## natural.
      "n"
    | 
      ## sharp.
      "s"
  }?
att.harpPedal.vis.attributes =
  att.color.attributes,
  att.placement.attributes,
  att.visualoffset.attributes,
  att.xy.attributes
att.layerDef.log.cmn.attributes = att.beaming.log.attributes
att.lvpresent.attributes = att.lvpresent.attribute.lv
att.lvpresent.attribute.lv =
  
  ## indicates the attachment of an l.v. (laissez vibrer) sign to this element.
  attribute lv { data.BOOLEAN }?
att.measure.vis.attributes =
  att.barplacement.attributes,
  att.measurement.attributes,
  att.width.attributes
att.meterSigGrp.anl.attributes = att.common.anl.attributes
att.meterSigGrp.ges.attributes = empty
att.meterSigGrp.log.attributes = empty
att.meterSigGrp.vis.attributes = empty
att.mRest.anl.attributes = att.common.anl.attributes
att.mRest.ges.attributes =
  att.duration.performed.attributes, att.instrumentident.attributes
att.mRest.log.attributes =
  att.duration.musical.attributes,
  att.event.attributes,
  att.fermatapresent.attributes
att.mRest.vis.attributes =
  att.altsym.attributes,
  att.cutout.attributes,
  att.relativesize.attributes,
  att.staffloc.attributes,
  att.staffloc.pitched.attributes,
  att.visualoffset.attributes,
  att.visibility.attributes,
  att.xy.attributes
att.mRpt.anl.attributes = att.common.anl.attributes
att.mRpt.ges.attributes = empty
att.mRpt.log.attributes = att.event.attributes
att.mRpt.vis.attributes =
  att.altsym.attributes, att.color.attributes, att.expandable.attributes
att.mRpt2.anl.attributes = att.common.anl.attributes
att.mRpt2.ges.attributes = empty
att.mRpt2.log.attributes = att.event.attributes
att.mRpt2.vis.attributes =
  att.altsym.attributes, att.color.attributes, att.expandable.attributes
att.mSpace.anl.attributes = att.common.anl.attributes
att.mSpace.ges.attributes =
  att.duration.performed.attributes, att.instrumentident.attributes
att.mSpace.log.attributes =
  att.augmentdots.attributes,
  att.event.attributes,
  att.duration.musical.attributes,
  att.fermatapresent.attributes
att.mSpace.vis.attributes =
  att.altsym.attributes,
  att.cutout.attributes,
  att.visibility.attributes,
  att.xy.attributes
att.multiRest.anl.attributes = att.common.anl.attributes
att.multiRest.ges.attributes =
  att.duration.performed.attributes, att.instrumentident.attributes
att.multiRest.log.attributes =
  att.event.attributes, att.numbered.attributes
att.multiRest.vis.attributes =
  att.altsym.attributes,
  att.staffloc.attributes,
  att.staffloc.pitched.attributes,
  att.multiRest.vis.attribute.block
att.multiRest.vis.attribute.block =
  
  ## When the block attribute is used, combinations of the 1, 2, and 4 measure rest forms (Read, p. 104) should be rendered instead of the modern form or an alternative symbol.
  attribute block { data.BOOLEAN }?
att.multiRpt.anl.attributes = att.common.anl.attributes
att.multiRpt.ges.attributes = empty
att.multiRpt.log.attributes =
  att.event.attributes, att.numbered.attributes
att.multiRpt.vis.attributes =
  att.altsym.attributes, att.expandable.attributes
att.note.ges.cmn.attributes =
  att.graced.attributes, att.note.ges.cmn.attribute.gliss
att.note.ges.cmn.attribute.gliss =
  
  ## indicates that this element participates in a glissando.
  attribute gliss { data.GLISSANDO }?
att.note.log.cmn.attributes =
  att.beamed.attributes, att.lvpresent.attributes, att.ornam.attributes
att.note.vis.cmn.attributes = att.beamsecondary.attributes
att.numbered.attributes = att.numbered.attribute.num
att.numbered.attribute.num =
  
  ## records a number or count accompanying a notational feature.
  attribute num { xsd:positiveInteger }?
att.numberplacement.attributes =
  att.numberplacement.attribute.num.place,
  att.numberplacement.attribute.num.visible
att.numberplacement.attribute.num.place =
  
  ## states where the tuplet number will be placed in relation to the note heads.
  attribute num.place { data.PLACE }?
att.numberplacement.attribute.num.visible =
  
  ## determines if the tuplet number is visible.
  attribute num.visible { data.BOOLEAN }?
att.octave.anl.attributes = att.common.anl.attributes
att.octave.ges.attributes = att.duration.performed.attributes
att.octave.log.attributes =
  att.controlevent.attributes,
  att.augmentdots.attributes,
  att.duration.additive.attributes,
  att.octavedisplacement.attributes,
  att.startendid.attributes,
  att.timestamp2.musical.attributes,
  att.octave.log.attribute.coll
att.octave.log.attribute.coll =
  
  ## indicates whether the octave displacement should be performed simultaneously with the written notes, i.e., "coll' ottava". Unlike other octave signs which are indicated by broken lines, coll' ottava typically uses an unbroken line or a series of longer broken lines, ending with a short vertical stroke. See Read, p. 47-48.
  attribute coll {
    
    ## coll' ottava (with the octave).
    "coll"
  }?
att.octave.vis.attributes =
  att.xy.attributes,
  att.visualoffset.attributes,
  att.visualoffset2.ho.attributes,
  att.visualoffset2.to.attributes,
  att.linerend.attributes
att.ossia.anl.attributes = att.common.anl.attributes
att.ossia.ges.attributes = empty
att.ossia.log.attributes = empty
att.ossia.vis.attributes = empty
att.pedal.anl.attributes = att.common.anl.attributes
att.pedal.ges.attributes = empty
att.pedal.log.attributes =
  att.controlevent.attributes,
  att.startendid.attributes,
  att.pedal.log.attribute.dir
att.pedal.log.attribute.dir =
  
  ## records the position of the piano damper pedal.
  attribute dir {
    
    ## depress the pedal.
    "down"
    | 
      ## release the pedal.
      "up"
    | 
      ## half pedal.
      "half"
    | 
      ## release then immediately depress the pedal.
      "bounce"
  }
att.pedal.vis.attributes =
  att.color.attributes,
  att.placement.attributes,
  att.xy.attributes,
  att.visualoffset.attributes,
  att.pedal.vis.attribute.style
att.pedal.vis.attribute.style =
  
  ## determines whether piano pedal marks should be rendered as lines or as terms.
  attribute style {
    
    ## continuous line with start and end positions rendered by vertical bars and bounces shown by upward-pointing "blips".
    "line"
    | 
      ## pedal down and half pedal rendered with "Ped.", pedal up rendered by "*", pedal "bounce" rendered with "* Ped.".
      "pedstar"
    | 
      ## pedal up and down indications same as with "pedstar", but bounce is rendered with "Ped." only.
      "altpedstar"
  }?
att.phrase.vis.cmn.attributes =
  att.curvature.attributes, att.curverend.attributes
att.pianopedals.attributes = att.pianopedals.attribute.pedal.style
att.pianopedals.attribute.pedal.style =
  
  ## determines whether piano pedal marks should be rendered as lines or as terms.
  attribute pedal.style {
    
    ## continuous line with start and end positions rendered by vertical bars and bounces shown by upward-pointing "blips".
    "line"
    | 
      ## pedal down and half pedal rendered with "Ped.", pedal up rendered by "*", pedal "bounce" rendered with "* Ped.".
      "pedstar"
    | 
      ## pedal up and down indications same as with "pedstar", but bounce is rendered with "Ped." only.
      "altpedstar"
  }?
att.reh.anl.attributes = att.common.anl.attributes
att.reh.ges.attributes = empty
att.reh.log.attributes =
  att.staffident.attributes,
  att.startid.attributes,
  att.timestamp.musical.attributes,
  att.timestamp.performed.attributes
att.reh.vis.attributes =
  att.color.attributes,
  att.placement.attributes,
  att.typography.attributes,
  att.visualoffset.attributes,
  att.xy.attributes
att.rehearsal.attributes = att.rehearsal.attribute.reh.enclose
att.rehearsal.attribute.reh.enclose =
  
  ## describes the enclosing shape for rehearsal marks.
  attribute reh.enclose {
    
    ## enclosed by box.
    "box"
    | 
      ## enclosed by circle.
      "circle"
    | 
      ## no enclosing shape.
      "none"
  }?
att.rest.log.cmn.attributes = att.beamed.attributes
att.rest.vis.cmn.attributes = empty
att.scoreDef.log.cmn.attributes = att.beaming.log.attributes
att.scoreDef.vis.cmn.attributes =
  att.beaming.vis.attributes,
  att.pianopedals.attributes,
  att.rehearsal.attributes,
  att.slurrend.attributes,
  att.tierend.attributes,
  att.scoreDef.vis.cmn.attribute.grid.show
att.scoreDef.vis.cmn.attribute.grid.show =
  
  ## determines whether to display guitar chord grids.
  attribute grid.show { data.BOOLEAN }?
att.slur.anl.attributes =
  att.common.anl.attributes, att.joined.attributes
att.slur.ges.attributes = att.duration.performed.attributes
att.slur.log.attributes =
  att.controlevent.attributes,
  att.augmentdots.attributes,
  att.duration.additive.attributes,
  att.startendid.attributes,
  att.timestamp2.musical.attributes
att.slur.vis.attributes =
  att.color.attributes,
  att.visualoffset.attributes,
  att.visualoffset2.attributes,
  att.xy.attributes,
  att.xy2.attributes,
  att.curvature.attributes,
  att.curverend.attributes
att.slurrend.attributes = att.slurrend.attribute.slur.rend
att.slurrend.attribute.slur.rend =
  
  ## describes the line style of the slur.
  attribute slur.rend { data.CURVERENDITION }?
att.space.log.cmn.attributes = att.beamed.attributes
att.staffDef.log.cmn.attributes = att.beaming.log.attributes
att.staffDef.vis.cmn.attributes =
  att.beaming.vis.attributes,
  att.pianopedals.attributes,
  att.rehearsal.attributes,
  att.slurrend.attributes,
  att.tierend.attributes
att.stemmed.cmn.attributes =
  att.stemmed.cmn.attribute.stem.mod,
  att.stemmed.cmn.attribute.stem.with
att.stemmed.cmn.attribute.stem.mod =
  
  ## encodes any stem "modifiers"; that is, symbols rendered on the stem, such as tremolo or Sprechstimme indicators.
  attribute stem.mod { data.STEMMODIFIER }?
att.stemmed.cmn.attribute.stem.with =
  
  ## contains an indication of which staff a note or chord that logically belongs to the current staff should be visually placed on; that is, the one above or the one below.
  attribute stem.with { data.OTHERSTAFF }?
att.tie.anl.attributes = att.common.anl.attributes
att.tie.ges.attributes = empty
att.tie.log.attributes =
  att.controlevent.attributes,
  att.startendid.attributes,
  att.timestamp2.musical.attributes
att.tie.vis.attributes =
  att.color.attributes,
  att.visualoffset.attributes,
  att.visualoffset2.attributes,
  att.xy.attributes,
  att.xy2.attributes,
  att.curvature.attributes,
  att.curverend.attributes
att.tierend.attributes = att.tierend.attribute.tie.rend
att.tierend.attribute.tie.rend =
  
  ## describes the line style of the tie.
  attribute tie.rend { data.CURVERENDITION }?
att.tremmeasured.attributes = att.tremmeasured.attribute.measperf
att.tremmeasured.attribute.measperf =
  
  ## the performed duration of an individual note in a measured tremolo.
  attribute measperf { data.DURATION.cmn }?
att.tuplet.anl.attributes = att.common.anl.attributes
att.tuplet.ges.attributes = att.duration.performed.attributes
att.tuplet.log.attributes =
  att.event.attributes,
  att.beamedwith.attributes,
  att.augmentdots.attributes,
  att.duration.additive.attributes,
  att.duration.ratio.attributes,
  att.startendid.attributes
att.tuplet.vis.attributes =
  att.color.attributes,
  att.numberplacement.attributes,
  att.tuplet.vis.attribute.bracket.place,
  att.tuplet.vis.attribute.bracket.visible,
  att.tuplet.vis.attribute.dur.visible,
  att.tuplet.vis.attribute.num.format
att.tuplet.vis.attribute.bracket.place =
  
  ## used to state where a tuplet bracket will be placed in relation to the note heads.
  attribute bracket.place { data.PLACE }?
att.tuplet.vis.attribute.bracket.visible =
  
  ## states whether a bracket should be rendered with a tuplet.
  attribute bracket.visible { data.BOOLEAN }?
att.tuplet.vis.attribute.dur.visible =
  
  ## determines if the tuplet duration is visible.
  attribute dur.visible { data.BOOLEAN }?
att.tuplet.vis.attribute.num.format =
  
  ## controls how the num:numbase ratio is to be displayed.
  attribute num.format {
    
    ## only the num attribute is displayed, e.g., '7'.
    "count"
    | 
      ## both the num and numbase attributes are displayed, e.g., '7:4'.
      "ratio"
  }?
att.tupletSpan.anl.attributes = att.tuplet.anl.attributes
att.tupletSpan.ges.attributes = att.tuplet.ges.attributes
att.tupletSpan.log.attributes =
  att.controlevent.attributes,
  att.beamedwith.attributes,
  att.augmentdots.attributes,
  att.duration.additive.attributes,
  att.duration.ratio.attributes,
  att.startendid.attributes,
  att.timestamp2.musical.attributes
att.tupletSpan.vis.attributes = att.tuplet.vis.attributes
model.controleventLike.cmn =
  arpeg
  | beamSpan
  | breath
  | fermata
  | hairpin
  | harpPedal
  | octave
  | pedal
  | reh
  | slur
  | tie
  | tupletSpan
  | model.ornamentLike.cmn
model.controleventLike.cmn_alternation =
  arpeg
  | beamSpan
  | breath
  | fermata
  | hairpin
  | harpPedal
  | octave
  | pedal
  | reh
  | slur
  | tie
  | tupletSpan
  | model.ornamentLike.cmn_alternation
model.controleventLike.cmn_sequence =
  arpeg,
  beamSpan,
  breath,
  fermata,
  hairpin,
  harpPedal,
  octave,
  pedal,
  reh,
  slur,
  tie,
  tupletSpan,
  model.ornamentLike.cmn_sequence
model.controleventLike.cmn_sequenceOptional =
  arpeg?,
  beamSpan?,
  breath?,
  fermata?,
  hairpin?,
  harpPedal?,
  octave?,
  pedal?,
  reh?,
  slur?,
  tie?,
  tupletSpan?,
  model.ornamentLike.cmn_sequenceOptional?
model.controleventLike.cmn_sequenceOptionalRepeatable =
  arpeg*,
  beamSpan*,
  breath*,
  fermata*,
  hairpin*,
  harpPedal*,
  octave*,
  pedal*,
  reh*,
  slur*,
  tie*,
  tupletSpan*,
  model.ornamentLike.cmn_sequenceOptionalRepeatable*
model.controleventLike.cmn_sequenceRepeatable =
  arpeg+,
  beamSpan+,
  breath+,
  fermata+,
  hairpin+,
  harpPedal+,
  octave+,
  pedal+,
  reh+,
  slur+,
  tie+,
  tupletSpan+,
  model.ornamentLike.cmn_sequenceRepeatable+
model.eventLike.cmn = beam | beatRpt | bTrem | fTrem | halfmRpt | tuplet
model.eventLike.cmn_alternation =
  beam | beatRpt | bTrem | fTrem | halfmRpt | tuplet
model.eventLike.cmn_sequence =
  beam, beatRpt, bTrem, fTrem, halfmRpt, tuplet
model.eventLike.cmn_sequenceOptional =
  beam?, beatRpt?, bTrem?, fTrem?, halfmRpt?, tuplet?
model.eventLike.cmn_sequenceOptionalRepeatable =
  beam*, beatRpt*, bTrem*, fTrem*, halfmRpt*, tuplet*
model.eventLike.cmn_sequenceRepeatable =
  beam+, beatRpt+, bTrem+, fTrem+, halfmRpt+, tuplet+
model.eventLike.measureFilling =
  mRest | mRpt | mRpt2 | mSpace | multiRest | multiRpt
model.eventLike.measureFilling_alternation =
  mRest | mRpt | mRpt2 | mSpace | multiRest | multiRpt
model.eventLike.measureFilling_sequence =
  mRest, mRpt, mRpt2, mSpace, multiRest, multiRpt
model.eventLike.measureFilling_sequenceOptional =
  mRest?, mRpt?, mRpt2?, mSpace?, multiRest?, multiRpt?
model.eventLike.measureFilling_sequenceOptionalRepeatable =
  mRest*, mRpt*, mRpt2*, mSpace*, multiRest*, multiRpt*
model.eventLike.measureFilling_sequenceRepeatable =
  mRest+, mRpt+, mRpt2+, mSpace+, multiRest+, multiRpt+
model.layerPart.cmn = model.eventLike.measureFilling
model.measureLike = measure
model.measureLike_alternation = measure
model.measureLike_sequence = measure
model.measureLike_sequenceOptional = measure?
model.measureLike_sequenceOptionalRepeatable = measure*
model.measureLike_sequenceRepeatable = measure+
model.measurePart =
  model.controleventLike
  | model.staffLike
  | model.ossiaLike
  | model.lyricsLike
  | model.midiLike
  | fingering
  | tabChord
  | tabBarre
  | connectingLine
model.ossiaLike = ossia
model.sectionPart.cmn = model.measureLike
arpeg =
  
  ## (arpeggiation)  Indicates that the notes of a chord are to be performed successively rather than simultaneously, usually from lowest to highest. Sometimes called a "roll". 
  element arpeg {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.arpeg.log.attributes,
    att.arpeg.vis.attributes,
    att.arpeg.ges.attributes,
    att.arpeg.anl.attributes,
    empty
  }
beam =
  
  ## A container for a series of explicitly beamed events that begins and ends entirely within a measure. 
  element beam {
    ((model.eventLike
      | model.appLike
      | model.editLike
      | model.transcriptionLike)*)
    >> sch:pattern [
         id = "mei-beam-When_not_copyof_beam_content-constraint-31"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:beam[not(@copyof)]"
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "count(descendant::*[local-name()='note' or local-name()='rest' or               local-name()='chord' or local-name()='space']) > 1"
             "A beam without a copyof\x{a}" ~
             "              attribute must have at least 2 note, rest, chord, or space descendants."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.beam.log.attributes,
    att.beam.vis.attributes,
    att.beam.ges.attributes,
    att.beam.anl.attributes,
    empty
  }
beamSpan =
  
  ## (beam span)  Alternative element for explicitly encoding beams, particularly those which extend across bar lines. 
  element beamSpan {
    empty
    >> sch:pattern [
         id =
           "mei-beamSpan-beamspan_start-_and_end-type_attributes_required-constraint-32"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:beamSpan"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             " Must have one of\x{a}" ~
             "              the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@dur or @dur.ges or @endid or @tstamp2"
             "Must have one of the\x{a}" ~
             "              attributes: dur, dur.ges, endid, or tstamp2"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.beamSpan.log.attributes,
    att.beamSpan.vis.attributes,
    att.beamSpan.ges.attributes,
    att.beamSpan.anl.attributes,
    empty
  }
beatRpt =
  
  ## (beat repeat)  An indication that material on a preceding beat should be repeated. 
  element beatRpt {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.beatRpt.log.attributes,
    att.beatRpt.vis.attributes,
    att.beatRpt.ges.attributes,
    att.beatRpt.anl.attributes,
    empty
  }
bend =
  
  ## A variation in pitch (often micro-tonal) upwards or downwards during the course of a note.
  element bend {
    empty
    >> sch:pattern [
         id =
           "mei-bend-bend_start-_and_end-type_attributes_required-constraint-33"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:bend"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             " Must have one of\x{a}" ~
             "              the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@dur or @dur.ges or @endid or @tstamp2"
             "Must have one of the\x{a}" ~
             "              attributes: dur, dur.ges, endid, or tstamp2"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.bend.log.attributes,
    att.bend.vis.attributes,
    att.bend.ges.attributes,
    att.bend.anl.attributes,
    empty
  }
breath =
  
  ## (breath mark)  A indication of a point at which the performer on an instrument requiring breath (including the voice) may breathe. 
  element breath {
    empty
    >> sch:pattern [
         id =
           "mei-breath-breath_start-type_attributes_required-constraint-34"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:breath"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             " Must have one of\x{a}" ~
             "              the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.breath.log.attributes,
    att.breath.vis.attributes,
    att.breath.ges.attributes,
    att.breath.anl.attributes,
    empty
  }
bTrem =
  
  ## (bowed tremolo)  A rapid alternation on a single pitch or chord.
  element bTrem {
    (chord | note),
    att.common.attributes,
    att.facsimile.attributes,
    att.bTrem.log.attributes,
    att.bTrem.vis.attributes,
    att.bTrem.ges.attributes,
    att.bTrem.anl.attributes,
    empty
  }
fermata =
  
  ## An indication placed over a note or rest to indicate that it should be held longer than its written value. May also occur over a bar line to indicate the end of a phrase or section. Sometimes called a 'hold' or 'pause'. 
  element fermata {
    empty
    >> sch:pattern [
         id =
           "mei-fermata-fermata_start-type_attributes_required-constraint-35"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:fermata"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             " Must have one of\x{a}" ~
             "              the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.fermata.log.attributes,
    att.fermata.vis.attributes,
    att.fermata.ges.attributes,
    att.fermata.anl.attributes,
    empty
  }
fTrem =
  
  ## (fingered tremolo)  A rapid alternation between a pair of notes (or chords or perhaps between a note and a chord) that are (usually) farther apart than a major second.
  element fTrem {
    ((chord, (chord | note))
     | (note, (chord | note))),
    att.common.attributes,
    att.facsimile.attributes,
    att.fTrem.log.attributes,
    att.fTrem.vis.attributes,
    att.fTrem.ges.attributes,
    att.fTrem.anl.attributes,
    empty
  }
gliss =
  
  ## (glissando)  A continuous or sliding movement from one pitch to another, usually indicated by a straight or wavy line. 
  element gliss {
    empty
    >> sch:pattern [
         id =
           "mei-gliss-gliss_start-_and_end-type_attributes_required-constraint-36"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:gliss"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             " Must have one of\x{a}" ~
             "              the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@dur or @dur.ges or @endid or @tstamp2"
             "Must have one of the\x{a}" ~
             "              attributes: dur, dur.ges, endid, or tstamp2"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.gliss.log.attributes,
    att.gliss.vis.attributes,
    att.gliss.ges.attributes,
    att.gliss.anl.attributes,
    empty
  }
hairpin =
  
  ## Indicates continuous dynamics expressed on the score as wedge-shaped graphics, e.g. < and >. 
  element hairpin {
    empty
    >> sch:pattern [
         id =
           "mei-hairpin-hairpin_start-_and_end-type_attributes_required-constraint-37"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:hairpin"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             " Must have one of\x{a}" ~
             "              the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@dur or @dur.ges or @endid or @tstamp2"
             "Must have one of the\x{a}" ~
             "              attributes: dur, dur.ges, endid, or tstamp2"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.hairpin.log.attributes,
    att.hairpin.vis.attributes,
    att.hairpin.ges.attributes,
    att.hairpin.anl.attributes,
    empty
  }
halfmRpt =
  
  ## (half-measure repeat)  A half-measure repeat in any meter.
  element halfmRpt {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.halfmRpt.log.attributes,
    att.halfmRpt.vis.attributes,
    att.halfmRpt.ges.attributes,
    att.halfmRpt.anl.attributes,
    empty
  }
harpPedal =
  
  ## (harp pedal)  Harp pedal diagram. 
  element harpPedal {
    empty
    >> sch:pattern [
         id =
           "mei-harpPedal-harpPedal_start-type_attributes_required-constraint-38"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:harpPedal"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             " Must have one of\x{a}" ~
             "              the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.harpPedal.log.attributes,
    att.harpPedal.vis.attributes,
    att.harpPedal.ges.attributes,
    att.harpPedal.anl.attributes,
    empty
  }
measure =
  
  ## Unit of musical time consisting of a fixed number of note-values of a given type, as determined by the prevailing meter, and delimited in musical notation by two bar lines. 
  element measure {
    (model.appLike
     | model.divLike
     | model.milestoneLike.music
     | model.staffDefLike
     | model.annotLike
     | model.graphicprimitiveLike
     | model.editLike
     | model.transcriptionLike
     | model.measurePart)*,
    att.common.attributes,
    att.declaring.attributes,
    att.facsimile.attributes,
    att.typed.attributes,
    att.pointing.attributes,
    att.measure.log.attributes,
    att.measure.vis.attributes,
    att.measure.ges.attributes,
    att.measure.anl.attributes,
    empty
  }
meterSig =
  
  ## (meter signature)  Written meter signature.
  element meterSig {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.meterSig.anl.attributes,
    att.meterSig.ges.attributes,
    att.meterSig.log.attributes,
    att.meterSig.vis.attributes,
    empty
  }
meterSigGrp =
  
  ## (meter signature group)  Used to capture alternating, interchanging, and mixed meter signatures.
  element meterSigGrp {
    meterSig,
    meterSig+,
    att.common.attributes,
    att.facsimile.attributes,
    att.meterSigGrp.anl.attributes,
    att.meterSigGrp.ges.attributes,
    att.meterSigGrp.log.attributes,
    att.meterSigGrp.vis.attributes,
    
    ## Function of the meter signature group.
    attribute func {
      
      ## Meter signatures appear in alternating measures.
      "alternating"
      | 
        ## Meter signatures are interchangable, e.g. 3/4 and 6/8.
        "interchanging"
      | 
        ## Meter signatures with different unit values are used to express a complex metrical pattern that is not expressable using traditional means, such as 2/4+1/8.
        "mixed"
    },
    empty
  }
mRest =
  
  ## (measure rest)  Complete measure rest in any meter. 
  element mRest {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.mRest.log.attributes,
    att.mRest.vis.attributes,
    att.mRest.ges.attributes,
    att.mRest.anl.attributes,
    empty
  }
mRpt =
  
  ## (measure repeat)  An indication that the previous measure should be repeated. 
  element mRpt {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.mRpt.log.attributes,
    att.mRpt.vis.attributes,
    att.mRpt.ges.attributes,
    att.mRpt.anl.attributes,
    empty
  }
mRpt2 =
  
  ## (2-measure repeat)  An indication that the previous two measures should be repeated.
  element mRpt2 {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.mRpt2.log.attributes,
    att.mRpt2.vis.attributes,
    att.mRpt2.ges.attributes,
    att.mRpt2.anl.attributes,
    empty
  }
mSpace =
  
  ## (measure space)  A measure containing only empty space in any meter. 
  element mSpace {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.mSpace.log.attributes,
    att.mSpace.vis.attributes,
    att.mSpace.ges.attributes,
    att.mSpace.anl.attributes,
    empty
  }
multiRest =
  
  ## (multiple rest)  Multiple measures of rest compressed into a single symbol, frequently found in performer parts. 
  element multiRest {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.multiRest.log.attributes,
    att.multiRest.vis.attributes,
    att.multiRest.ges.attributes,
    att.multiRest.anl.attributes,
    empty
  }
multiRpt =
  
  ## (multiple repeat)  Multiple repeated measures. 
  element multiRpt {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.multiRpt.log.attributes,
    att.multiRpt.vis.attributes,
    att.multiRpt.ges.attributes,
    att.multiRpt.anl.attributes,
    empty
  }
octave =
  
  ## An indication that a passage should be performed one or more octaves above or below its written pitch. 
  element octave {
    empty
    >> sch:pattern [
         id =
           "mei-octave-octave_start-_and_end-type_attributes_required-constraint-39"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:octave"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             " Must have one of\x{a}" ~
             "              the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@dur or @dur.ges or @endid or @tstamp2"
             "Must have one of the\x{a}" ~
             "              attributes: dur, dur.ges, endid, or tstamp2"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.octave.log.attributes,
    att.octave.vis.attributes,
    att.octave.ges.attributes,
    att.octave.anl.attributes,
    empty
  }
ossia =
  
  ## An alternate notational version *present in the source being transcribed*. 
  element ossia {
    ((model.staffLike, model.staffLike+)
     | (model.layerLike, model.layerLike+))
    >> sch:pattern [
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:measure/mei:ossia"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "count(mei:*) = count(mei:staff)"
             "Ossia may contain only staff\x{a}" ~
             "                elements in this context."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:staff/mei:ossia"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "count(mei:*) = count(mei:layer)"
             "Ossia may contain only layer\x{a}" ~
             "                elements in this context."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.ossia.log.attributes,
    att.ossia.vis.attributes,
    att.ossia.ges.attributes,
    att.ossia.anl.attributes,
    empty
  }
pedal =
  
  ## Piano pedal mark. 
  element pedal {
    empty
    >> sch:pattern [
         id =
           "mei-pedal-pedal_start-type_attributes_required-constraint-42"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:pedal"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             " Must have one of\x{a}" ~
             "              the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.pedal.log.attributes,
    att.pedal.vis.attributes,
    att.pedal.ges.attributes,
    att.pedal.anl.attributes,
    empty
  }
reh =
  
  ## (rehearsal mark)  In an orchestral score and its corresponding parts, a mark indicating a convenient point from which to resume rehearsal after a break. 
  element reh {
    (text | model.lbLike | model.rendLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.reh.log.attributes,
    att.reh.vis.attributes,
    att.reh.ges.attributes,
    att.reh.anl.attributes,
    empty
  }
slur =
  
  ## Indication of 1) a "unified melodic idea" or 2) performance technique. 
  element slur {
    empty
    >> sch:pattern [
         id =
           "mei-slur-slur_start-_and_end-type_attributes_required-constraint-43"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:slur"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             " Must have one of\x{a}" ~
             "              the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@dur or @dur.ges or @endid or @tstamp2"
             "Must have one of the\x{a}" ~
             "              attributes: dur, dur.ges, endid, or tstamp2"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.typed.attributes,
    att.slur.log.attributes,
    att.slur.vis.attributes,
    att.slur.ges.attributes,
    att.slur.anl.attributes,
    empty
  }
tie =
  
  ## An indication that two notes of the same pitch form a single note with their combined rhythmic values. 
  element tie {
    empty
    >> sch:pattern [
         id =
           "mei-tie-tie_start-_and_end-type_attributes_required-constraint-44"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:tie"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             " Must have one of\x{a}" ~
             "              the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@dur or @dur.ges or @endid or @tstamp2"
             "Must have one of the\x{a}" ~
             "              attributes: dur, dur.ges, endid, or tstamp2"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.typed.attributes,
    att.tie.log.attributes,
    att.tie.vis.attributes,
    att.tie.ges.attributes,
    att.tie.anl.attributes,
    empty
  }
tuplet =
  
  ## A group of notes with "irregular" (sometimes called "irrational") rhythmic values, for example, three notes in the time normally occupied by two or nine in the time of five. 
  element tuplet {
    ((model.eventLike
      | model.appLike
      | model.editLike
      | model.transcriptionLike)*)
    >> sch:pattern [
         id = "mei-tuplet-When_not_copyof_tuplet_content-constraint-45"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:tuplet[not(@copyof)]"
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "count(descendant::*[local-name()='note' or local-name()='rest' or               local-name()='chord']) > 1"
             "A tuplet without a copyof attribute must have at least\x{a}" ~
             "              2 note, rest, or chord descendants."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.tuplet.log.attributes,
    att.tuplet.vis.attributes,
    att.tuplet.ges.attributes,
    att.tuplet.anl.attributes,
    empty
  }
tupletSpan =
  
  ## (tuplet span)  Alternative element for encoding tuplets, especially useful for tuplets that extend across bar lines. 
  element tupletSpan {
    empty
    >> sch:pattern [
         id =
           "mei-tupletSpan-tupletSpan_start-_and_end-type_attributes_required-constraint-46"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:tupletSpan"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of\x{a}" ~
             "              the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@dur or @dur.ges or @endid or @tstamp2"
             "Must have one of the\x{a}" ~
             "              attributes: dur, dur.ges, endid, or tstamp2"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.tupletSpan.log.attributes,
    att.tupletSpan.vis.attributes,
    att.tupletSpan.ges.attributes,
    att.tupletSpan.anl.attributes,
    empty
  }
att.accid.vis.mensural.attributes = att.staffloc.pitched.attributes
att.dot.vis.mensural.attributes = att.staffloc.pitched.attributes
att.ligature.anl.attributes = att.common.anl.attributes
att.ligature.ges.attributes = empty
att.ligature.log.attributes = att.ligature.log.attribute.form
att.ligature.log.attribute.form =
  
  ## provides an indication of the function of the ligature.
  attribute form { data.LIGATUREFORM }?
att.ligature.vis.attributes = empty
att.mensur.anl.attributes = att.common.anl.attributes
att.mensur.ges.attributes = empty
att.mensur.vis.attributes =
  att.color.attributes,
  att.relativesize.attributes,
  att.staffloc.attributes,
  att.mensur.vis.attribute.form,
  att.mensur.vis.attribute.orient
att.mensur.vis.attribute.form =
  
  ## indicates whether the base symbol is written vertically or horizontally.
  attribute form {
    
    ##
    "horizontal"
    | 
      ##
      "vertical"
  }?
att.mensur.vis.attribute.orient =
  
  ## describes the rotation or reflection of the base symbol.
  attribute orient { data.ORIENTATION }?
att.mensural.log.attributes =
  att.mensural.shared.attributes,
  att.mensural.log.attribute.mensur.dot,
  att.mensural.log.attribute.mensur.sign,
  att.mensural.log.attribute.mensur.slash,
  att.mensural.log.attribute.proport.num,
  att.mensural.log.attribute.proport.numbase
att.mensural.log.attribute.mensur.dot =
  
  ## determines if a dot is to be added to the base symbol.
  attribute mensur.dot { data.BOOLEAN }?
att.mensural.log.attribute.mensur.sign =
  
  ## the base symbol in the mensuration sign/time signature of mensural notation.
  attribute mensur.sign { data.MENSURATIONSIGN }?
att.mensural.log.attribute.mensur.slash =
  
  ## indicates the number lines added to the mensuration sign. For example, one slash is added for what we now call 'alla breve'.
  attribute mensur.slash { xsd:positiveInteger }?
att.mensural.log.attribute.proport.num =
  
  ## Together, proport.num and proport.numbase specify a proportional change as a ratio, e.g., 1:3. Proport.num is for the first value in the ratio.
  attribute proport.num { xsd:positiveInteger }?
att.mensural.log.attribute.proport.numbase =
  
  ## Together, proport.num and proport.numbase specify a proportional change as a ratio, e.g., 1:3. Proport.numbase is for the second value in the ratio.
  attribute proport.numbase { xsd:positiveInteger }?
att.mensural.shared.attributes =
  att.mensural.shared.attribute.modusmaior,
  att.mensural.shared.attribute.modusminor,
  att.mensural.shared.attribute.prolatio,
  att.mensural.shared.attribute.tempus
att.mensural.shared.attribute.modusmaior =
  
  ## describes the maxima-long relationship.
  attribute modusmaior { data.MODUSMAIOR }?
att.mensural.shared.attribute.modusminor =
  
  ## describes the long-breve relationship.
  attribute modusminor { data.MODUSMINOR }?
att.mensural.shared.attribute.prolatio =
  
  ## describes the semibreve-minim relationship.
  attribute prolatio { data.PROLATIO }?
att.mensural.shared.attribute.tempus =
  
  ## describes the breve-semibreve relationship.
  attribute tempus { data.TEMPUS }?
att.mensural.vis.attributes =
  att.mensural.vis.attribute.mensur.color,
  att.mensural.vis.attribute.mensur.form,
  att.mensural.vis.attribute.mensur.loc,
  att.mensural.vis.attribute.mensur.orient,
  att.mensural.vis.attribute.mensur.size
att.mensural.vis.attribute.mensur.color =
  
  ## records the color of the mensuration sign. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
  attribute mensur.color { data.COLOR }?
att.mensural.vis.attribute.mensur.form =
  
  ## indicates whether the base symbol is written vertically or horizontally.
  attribute mensur.form {
    
    ##
    "horizontal"
    | 
      ##
      "vertical"
  }?
att.mensural.vis.attribute.mensur.loc =
  
  ## holds the staff location of the mensuration sign.
  attribute mensur.loc { data.STAFFLOC }?
att.mensural.vis.attribute.mensur.orient =
  
  ## describes the rotation or reflection of the base symbol.
  attribute mensur.orient { data.ORIENTATION }?
att.mensural.vis.attribute.mensur.size =
  
  ## describes the relative size of the mensuration sign.
  attribute mensur.size { data.SIZE }?
att.note.ges.mensural.attributes = att.duration.ratio.attributes
att.note.log.mensural.attributes = att.note.log.mensural.attribute.lig
att.note.log.mensural.attribute.lig =
  
  ## indicates this element's participation in a ligature.
  attribute lig {
    
    ##
    "recta"
    | 
      ##
      "obliqua"
  }?
att.proport.anl.attributes = att.common.anl.attributes
att.proport.ges.attributes = empty
att.proport.log.attributes = att.duration.ratio.attributes
att.proport.vis.attributes = empty
att.rest.ges.mensural.attributes = att.duration.ratio.attributes
att.rest.vis.mensural.attributes =
  att.rest.vis.mensural.attribute.spaces
att.rest.vis.mensural.attribute.spaces =
  
  ## states how many spaces are covered by the rest.
  attribute spaces { xsd:positiveInteger }?
att.scoreDef.log.mensural.attributes = att.mensural.log.attributes
att.scoreDef.vis.mensural.attributes = att.mensural.vis.attributes
att.staffDef.log.mensural.attributes = att.mensural.log.attributes
att.staffDef.vis.mensural.attributes = att.mensural.vis.attributes
model.eventLike.mensural = ligature | mensur | proport
model.eventLike.mensural_alternation = ligature | mensur | proport
model.eventLike.mensural_sequence = ligature, mensur, proport
model.eventLike.mensural_sequenceOptional = ligature?, mensur?, proport?
model.eventLike.mensural_sequenceOptionalRepeatable =
  ligature*, mensur*, proport*
model.eventLike.mensural_sequenceRepeatable =
  ligature+, mensur+, proport+
model.layerPart.mensural =
  model.controleventLike | model.noteModifierLike | model.lyricsLike
model.layerPart.mensural_alternation =
  model.controleventLike_alternation
  | model.noteModifierLike_alternation
  | model.lyricsLike_alternation
model.layerPart.mensural_sequence =
  model.controleventLike_sequence,
  model.noteModifierLike_sequence,
  model.lyricsLike_sequence
model.layerPart.mensural_sequenceOptional =
  model.controleventLike_sequenceOptional?,
  model.noteModifierLike_sequenceOptional?,
  model.lyricsLike_sequenceOptional?
model.layerPart.mensural_sequenceOptionalRepeatable =
  model.controleventLike_sequenceOptionalRepeatable*,
  model.noteModifierLike_sequenceOptionalRepeatable*,
  model.lyricsLike_sequenceOptionalRepeatable*
model.layerPart.mensural_sequenceRepeatable =
  model.controleventLike_sequenceRepeatable+,
  model.noteModifierLike_sequenceRepeatable+,
  model.lyricsLike_sequenceRepeatable+
model.sectionPart.mensural = notAllowed
model.sectionPart.mensural_alternation = notAllowed
model.sectionPart.mensural_sequence = empty
model.sectionPart.mensural_sequenceOptional = empty
model.sectionPart.mensural_sequenceOptionalRepeatable = empty
model.sectionPart.mensural_sequenceRepeatable = notAllowed
model.staffDefPart.mensural = mensur | proport
model.staffPart.mensural = notAllowed
model.staffPart.mensural_alternation = notAllowed
model.staffPart.mensural_sequence = empty
model.staffPart.mensural_sequenceOptional = empty
model.staffPart.mensural_sequenceOptionalRepeatable = empty
model.staffPart.mensural_sequenceRepeatable = notAllowed
ligature =
  
  ## A mensural notation symbol that combines two or more notes into a single sign. 
  element ligature {
    model.layerPart*,
    att.common.attributes,
    att.facsimile.attributes,
    att.ligature.log.attributes,
    att.ligature.vis.attributes,
    att.ligature.ges.attributes,
    att.ligature.anl.attributes,
    empty
  }
mensur =
  
  ## (mensuration)  Collects information about the metrical relationship between a note value and the next smaller value; that is, either triple or duple. 
  element mensur {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.mensur.log.attributes,
    att.mensur.vis.attributes,
    att.mensur.ges.attributes,
    att.mensur.anl.attributes,
    empty
  }
proport =
  
  ## (proportion)  Description of note duration as arithmetic ratio. 
  element proport {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.proport.log.attributes,
    att.proport.vis.attributes,
    att.proport.ges.attributes,
    att.proport.anl.attributes,
    empty
  }
att.ineume.anl.attributes = att.common.anl.attributes
att.ineume.ges.attributes = empty
att.ineume.log.attributes =
  att.ineume.log.attribute.form, att.ineume.log.attribute.name
att.ineume.log.attribute.form =
  
  ## provides a subclass or functional label for the neume.
  attribute form { data.INEUMEFORM }?
att.ineume.log.attribute.name =
  
  ## records the name of the neume.
  attribute name { data.INEUMENAME }?
att.ineume.vis.attributes =
  att.color.attributes, att.staffloc.attributes
att.uneume.anl.attributes =
  att.common.anl.attributes,
  att.harmonicfunction.attributes,
  att.melodicfunction.attributes,
  att.intervallicdesc.attributes,
  att.solfa.attributes
att.uneume.ges.attributes = empty
att.uneume.log.attributes =
  att.event.attributes,
  att.syltext.attributes,
  att.uneume.log.attribute.form,
  att.uneume.log.attribute.name
att.uneume.log.attribute.form =
  
  ## provides a subclass or functional label for the neume.
  attribute form { data.UNEUMEFORM }?
att.uneume.log.attribute.name =
  
  ## records the name of the neume.
  attribute name { data.UNEUMENAME }?
att.uneume.vis.attributes =
  att.altsym.attributes,
  att.color.attributes,
  att.relativesize.attributes,
  att.staffloc.attributes,
  att.visualoffset.ho.attributes,
  att.xy.attributes,
  att.visibility.attributes
model.eventLike.neumes = ineume | uneume
model.eventLike.neumes_alternation = ineume | uneume
model.eventLike.neumes_sequence = ineume, uneume
model.eventLike.neumes_sequenceOptional = ineume?, uneume?
model.eventLike.neumes_sequenceOptionalRepeatable = ineume*, uneume*
model.eventLike.neumes_sequenceRepeatable = ineume+, uneume+
model.layerPart.neumes = model.eventLike.neumes | model.syllableLike
model.layerPart.neumes_alternation =
  model.eventLike.neumes_alternation | model.syllableLike_alternation
model.layerPart.neumes_sequence =
  model.eventLike.neumes_sequence, model.syllableLike_sequence
model.layerPart.neumes_sequenceOptional =
  model.eventLike.neumes_sequenceOptional?,
  model.syllableLike_sequenceOptional?
model.layerPart.neumes_sequenceOptionalRepeatable =
  model.eventLike.neumes_sequenceOptionalRepeatable*,
  model.syllableLike_sequenceOptionalRepeatable*
model.layerPart.neumes_sequenceRepeatable =
  model.eventLike.neumes_sequenceRepeatable+,
  model.syllableLike_sequenceRepeatable+
model.sectionPart.neumes = notAllowed
model.sectionPart.neumes_alternation = notAllowed
model.sectionPart.neumes_sequence = empty
model.sectionPart.neumes_sequenceOptional = empty
model.sectionPart.neumes_sequenceOptionalRepeatable = empty
model.sectionPart.neumes_sequenceRepeatable = notAllowed
model.staffPart.neumes = notAllowed
model.staffPart.neumes_alternation = notAllowed
model.staffPart.neumes_sequence = empty
model.staffPart.neumes_sequenceOptional = empty
model.staffPart.neumes_sequenceOptionalRepeatable = empty
model.staffPart.neumes_sequenceRepeatable = notAllowed
model.syllableLike = syllable
model.syllableLike_alternation = syllable
model.syllableLike_sequence = syllable
model.syllableLike_sequenceOptional = syllable?
model.syllableLike_sequenceOptionalRepeatable = syllable*
model.syllableLike_sequenceRepeatable = syllable+
model.syllablePart =
  model.controleventLike
  | model.eventLike
  | model.noteModifierLike
  | model.eventLike.neumes
  | model.lyricsLike
  | model.sylLike
  | model.verseLike
  | model.midiLike
ineume =
  
  ## (interrupted neume)  a graphically interrupted neume; that is, a neume which is logically a single entity but is written using multiple signs. 
  element ineume {
    (model.eventLike
     | model.eventLike.neumes
     | macro.neumeModifierLike
     | model.appLike
     | model.editLike
     | model.transcriptionLike
     | model.verseLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.typed.attributes,
    att.ineume.log.attributes,
    att.ineume.vis.attributes,
    att.ineume.ges.attributes,
    att.ineume.anl.attributes,
    empty
  }
syllable =
  
  ## Neume notation can be thought of as "neumed text". Therefore, the syllable element provides high-level organization in this repertoire.
  element syllable {
    (model.appLike
     | model.divLike
     | model.milestoneLike.music
     | model.scoreDefLike
     | model.staffDefLike
     | model.staffGrpLike
     | model.annotLike
     | model.graphicprimitiveLike
     | model.editLike
     | model.transcriptionLike
     | model.syllablePart)*,
    att.common.attributes,
    empty
  }
uneume =
  
  ## (uninterrupted neume)  A graphically-uninterrupted neume sign. 
  element uneume {
    (model.eventLike
     | macro.neumeModifierLike
     | model.appLike
     | model.editLike
     | model.transcriptionLike
     | model.verseLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.typed.attributes,
    att.uneume.log.attributes,
    att.uneume.vis.attributes,
    att.uneume.ges.attributes,
    att.uneume.anl.attributes,
    empty
  }
att.common.anl.attributes =
  att.alignment.attributes,
  att.common.anl.attribute.copyof,
  att.common.anl.attribute.corresp,
  att.common.anl.attribute.next,
  att.common.anl.attribute.prev,
  att.common.anl.attribute.sameas,
  att.common.anl.attribute.synch
att.common.anl.attribute.copyof =
  
  ## points to an element of which the current element is a copy.
  attribute copyof { data.URI }?
sch:pattern [
  id =
    "mei-att.common.anl-copyof-When_copyof_element_empy-constraint-47"
  "\x{a}" ~
  "    "
  sch:rule [
    context = "mei:*[@copyof]"
    "\x{a}" ~
    "      "
    sch:assert [
      test = "count(child::node()) = 0"
      "An element with a copyof attribute\x{a}" ~
      "                  cannot have content."
    ]
    "\x{a}" ~
    "    "
  ]
  "\x{a}" ~
  "  "
]
att.common.anl.attribute.corresp =
  
  ## used to point to other elements that correspond to this one in a generic fashion.
  attribute corresp { data.URIS }?
att.common.anl.attribute.next =
  
  ## used to point to the next event(s) in a user-defined collection.
  attribute next { data.URIS }?
att.common.anl.attribute.prev =
  
  ## points to the previous event(s) in a user-defined collection.
  attribute prev { data.URIS }?
att.common.anl.attribute.sameas =
  
  ## points to an element that is the same as the current element but is not a literal copy of the current element.
  attribute sameas { data.URIS }?
att.common.anl.attribute.synch =
  
  ## points to elements that are synchronous with the current element.
  attribute synch { data.URIS }?
att.harmonicfunction.attributes = att.harmonicfunction.attribute.deg
att.harmonicfunction.attribute.deg =
  
  ## captures relative scale degree information using Humdrum **deg syntax -- an optional indicator of melodic approach (^ = ascending approach, v = descending approach), a scale degree value (1 = tonic ... 7 = leading tone), and an optional indication of chromatic alteration. The amount of chromatic alternation is not indicated.
  attribute deg { data.SCALEDEGREE }?
att.intervalharmonic.attributes = att.intervalharmonic.attribute.inth
att.intervalharmonic.attribute.inth =
  
  ## encodes the harmonic interval between this note and other pitches occurring at the same time.
  attribute inth { xsd:NMTOKENS }?
att.intervallicdesc.attributes =
  att.intervalharmonic.attributes, att.intervallicdesc.attribute.intm
att.intervallicdesc.attribute.intm =
  
  ## encodes the melodic interval from the previous pitch. The value may be a general directional indication (u, d, s), an indication of diatonic interval direction, quality, and size, or a precise numeric value in half steps.
  attribute intm { data.INTERVAL.AMOUNT }?
att.melodicfunction.attributes = att.melodicfunction.attribute.mfunc
att.melodicfunction.attribute.mfunc =
  
  ## describes melodic function using Humdrum **embel syntax.
  attribute mfunc { data.MELODICFUNCTION }?
att.pitchclass.attributes = att.pitchclass.attribute.pclass
att.pitchclass.attribute.pclass =
  
  ## holds pitch class information.
  attribute pclass { data.PITCHCLASS }?
att.solfa.attributes = att.solfa.attribute.psolfa
att.solfa.attribute.psolfa =
  
  ## contains sol-fa designation, e.g., do, re, mi, etc., in either a fixed or movable Do system.
  attribute psolfa { text }?
att.mordent.anl.attributes = att.common.anl.attributes
att.mordent.ges.attributes = empty
att.mordent.log.attributes =
  att.controlevent.attributes,
  att.startendid.attributes,
  att.ornamentaccid.attributes,
  att.mordent.log.attribute.form,
  att.mordent.log.attribute.long
att.mordent.log.attribute.form =
  
  ## Traditionally, the 'normal' mordent is written as a short wavy line with a vertical line through it and the inverted mordent is written without the vertical line. However, the meaning of these signs is sometimes reversed. See Read, p. 245-246. Another attribute in the visual domain would be necessary in order to be completely explicit about which visual symbol is actually to be rendered.
  attribute form {
    
    ## inverted mordent, e.g., performed as the principal note, followed by its upper neighbor, with a return to the principal note.
    "inv"
    | 
      ## "normal" mordent, e.g., performed as the written note, followed by its lower neighbor, with a return to the written note.
      "norm"
  }?
att.mordent.log.attribute.long =
  
  ## When the long attribute is set to 'yes', a double or long mordent, consisting of 5 notes, is indicated.
  attribute long { data.BOOLEAN }?
att.mordent.vis.attributes =
  att.color.attributes,
  att.placement.attributes,
  att.visualoffset.attributes
att.ornam.attributes = att.ornam.attribute.ornam
att.ornam.attribute.ornam =
  
  ## indicates that this element has an attached ornament. If visual information about the ornament is needed, then one of the elements that represents an ornament (mordent, trill, or turn) should be employed.
  attribute ornam { data.ORNAMS.cmn }?
att.ornamentaccid.attributes =
  att.ornamentaccid.attribute.accidupper,
  att.ornamentaccid.attribute.accidlower
att.ornamentaccid.attribute.accidupper =
  
  ## records the written accidental associated with an upper neighboring note.
  attribute accidupper { data.ACCIDENTAL.EXPLICIT }?
att.ornamentaccid.attribute.accidlower =
  
  ## records the written accidental associated with a lower neighboring note.
  attribute accidlower { data.ACCIDENTAL.EXPLICIT }?
att.trill.anl.attributes = att.common.anl.attributes
att.trill.ges.attributes = att.duration.performed.attributes
att.trill.log.attributes =
  att.controlevent.attributes,
  att.augmentdots.attributes,
  att.duration.additive.attributes,
  att.ornamentaccid.attributes,
  att.startendid.attributes,
  att.timestamp2.musical.attributes
att.trill.vis.attributes =
  att.color.attributes,
  att.placement.attributes,
  att.visualoffset.attributes,
  att.visualoffset2.ho.attributes,
  att.visualoffset2.to.attributes,
  att.xy.attributes
att.turn.anl.attributes = att.common.anl.attributes
att.turn.ges.attributes = empty
att.turn.log.attributes =
  att.controlevent.attributes,
  att.ornamentaccid.attributes,
  att.startid.attributes,
  att.turn.log.attribute.delayed,
  att.turn.log.attribute.form
att.turn.log.attribute.delayed =
  
  ## When the delayed attribute is set to 'true', the turn begins on the second half of the beat. See Read, p. 246.
  attribute delayed { data.BOOLEAN }?
att.turn.log.attribute.form =
  
  ## indicates the style of the turn.
  attribute form {
    
    ## inverted turn, e.g., begins on the note below the written note.
    "inv"
    | 
      ## "normal" turn, e.g., begins on the note above the written note.
      "norm"
  }?
att.turn.vis.attributes =
  att.color.attributes,
  att.placement.attributes,
  att.visualoffset.attributes,
  att.xy.attributes
model.ornamentLike.cmn = mordent | trill | turn
model.ornamentLike.cmn_alternation = mordent | trill | turn
model.ornamentLike.cmn_sequence = mordent, trill, turn
model.ornamentLike.cmn_sequenceOptional = mordent?, trill?, turn?
model.ornamentLike.cmn_sequenceOptionalRepeatable =
  mordent*, trill*, turn*
model.ornamentLike.cmn_sequenceRepeatable = mordent+, trill+, turn+
mordent =
  
  ## An ornament indicating rapid alternation of the main note with a secondary note, usually a step below, but sometimes a step above. 
  element mordent {
    empty
    >> sch:pattern [
         id =
           "mei-mordent-mordent_start-type_attributes_required-constraint-48"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:mordent"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             " Must have one of\x{a}" ~
             "              the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.mordent.log.attributes,
    att.mordent.vis.attributes,
    att.mordent.ges.attributes,
    att.mordent.anl.attributes,
    empty
  }
trill =
  
  ## Rapid alternation of a note with one (usually at the interval of a second) above. 
  element trill {
    empty
    >> sch:pattern [
         id =
           "mei-trill-trill_start-type_attributes_required-constraint-49"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:trill"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             " Must have one of\x{a}" ~
             "              the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.trill.log.attributes,
    att.trill.vis.attributes,
    att.trill.ges.attributes,
    att.trill.anl.attributes,
    empty
  }
turn =
  
  ## An ornament consisting of four notes  the upper neighbor of the written note, the written note, the lower neighbor, and the written note. 
  element turn {
    empty
    >> sch:pattern [
         id =
           "mei-turn-turn_start-type_attributes_required-constraint-50"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:turn"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of\x{a}" ~
             "              the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.turn.log.attributes,
    att.turn.vis.attributes,
    att.turn.ges.attributes,
    att.turn.anl.attributes,
    empty
  }
meiCorpus =
  
  ## (MEI corpus)  A group of related MEI documents, consisting of a header for the group, and one or more <mei> elements, each with its own complete header. 
  element meiCorpus {
    meiHead,
    mei*,
    att.common.attributes,
    att.meiversion.attributes,
    empty
  }
att.crit.attributes =
  att.handident.attributes,
  att.responsibility.attributes,
  att.sequence.attributes,
  att.source.attributes,
  att.crit.attribute.cause
att.crit.attribute.cause =
  
  ## classifies the cause for the variant reading, according to any appropriate typology of possible origins.
  attribute cause { xsd:NMTOKEN }?
att.rdg.anl.attributes = att.common.anl.attributes
att.rdg.ges.attributes = empty
att.rdg.log.attributes = empty
att.rdg.vis.attributes = empty
att.source.attributes = att.source.attribute.source
att.source.attribute.source =
  
  ## contains a list of one or more pointers indicating the sources which attest to a given reading. Each value should correspond to the ID of a <source> element located in the document header.
  attribute source { data.URIS }?
model.appLike = app
model.rdgPart.critapp =
  model.controleventLike
  | model.eventLike
  | model.layerLike
  | model.noteModifierLike
  | model.eventLike.measureFilling
  | model.eventLike.neumes
  | model.syllableLike
  | model.lyricsLike
  | model.sylLike
  | model.verseLike
  | model.midiLike
app =
  
  ## (apparatus)  Contains one or more alternative encodings. 
  element app {
    lem?, rdg, rdg*, att.common.attributes, att.typed.attributes, empty
  }
lem =
  
  ## (lemma)  Contains the lemma, or base text, of a textual variation. 
  element lem {
    expansion*,
    (model.appLike
     | model.divLike
     | model.milestoneLike.music
     | model.staffGrpLike
     | model.annotLike
     | model.graphicprimitiveLike
     | model.editLike
     | model.transcriptionLike
     | model.rdgPart.critapp
     | model.sectionPart)*,
    att.common.attributes,
    att.crit.attributes,
    att.typed.attributes,
    att.pointing.attributes,
    att.rdg.anl.attributes,
    att.rdg.ges.attributes,
    att.rdg.log.attributes,
    att.rdg.vis.attributes,
    empty
  }
rdg =
  
  ## (reading)  Contains a single reading within a textual variation. 
  element rdg {
    expansion*,
    (model.appLike
     | model.divLike
     | model.milestoneLike.music
     | model.staffGrpLike
     | model.annotLike
     | model.graphicprimitiveLike
     | model.editLike
     | model.transcriptionLike
     | model.rdgPart.critapp
     | model.sectionPart)*,
    att.common.attributes,
    att.crit.attributes,
    att.typed.attributes,
    att.pointing.attributes,
    att.rdg.anl.attributes,
    att.rdg.ges.attributes,
    att.rdg.log.attributes,
    att.rdg.vis.attributes,
    empty
  }
att.agentident.attributes = att.agentident.attribute.agent
att.agentident.attribute.agent =
  
  ## signifies the causative agent of damage, illegibility, or other loss of original text.
  attribute agent { text }?
att.edit.attributes =
  att.responsibility.attributes,
  att.source.attributes,
  att.edit.attribute.cert,
  att.edit.attribute.evidence
att.edit.attribute.cert =
  
  ## signifies the degree of certainty or precision associated with a feature.
  attribute cert { data.CERTAINTY }?
att.edit.attribute.evidence =
  
  ## indicates the nature of the evidence supporting the reliability or accuracy of the intervention or interpretation. Suggested values include: 'internal', 'external', 'conjecture'.
  attribute evidence { xsd:NMTOKEN }?
att.extent.attributes = att.extent.attribute.extent
att.extent.attribute.extent =
  
  ## indicates the extent of damage or omission.
  attribute extent { text }?
att.reasonident.attributes = att.reasonident.attribute.reason
att.reasonident.attribute.reason =
  
  ## holds a short phrase describing the reason for missing textual material (gap), why material is supplied (supplied), or why transcription is difficult (unclear).
  attribute reason { text }?
att.trans.attributes = att.handident.attributes, att.sequence.attributes
model.choicePart =
  model.editorialLike
  | model.editLike
  | corr
  | orig
  | reg
  | sic
  | unclear
model.editLike = choice | subst | instrName | instrConfig
model.transcriptionLike =
  add
  | corr
  | damage
  | del
  | gap
  | handShift
  | orig
  | reg
  | restore
  | sic
  | supplied
  | unclear
abbr =
  
  ## (abbreviation)  A generic element for 1) a shortened form of a word, including an acronym or 2) a shorthand notation.
  element abbr {
    (text
     | model.textphraseLike
     | model.eventLike
     | model.eventLike.neumes
     | model.controleventLike
     | model.lyricsLike
     | model.midiLike
     | model.editLike
     | model.transcriptionLike
     | model.eventLike.measureFilling
     | model.noteModifierLike
     | model.sectionLike
     | model.measureLike
     | model.staffLike
     | model.layerLike
     | model.graphicprimitiveLike
     | model.fLike)*,
    att.common.attributes,
    att.edit.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.trans.attributes,
    att.typed.attributes,
    
    ## records the expansion of a text abbreviation.
    attribute expan { text }?,
    empty
  }
add =
  
  ## (addition)  Marks an addition to the text. 
  element add {
    (text
     | model.textphraseLike
     | model.eventLike
     | model.eventLike.neumes
     | model.controleventLike
     | model.lyricsLike
     | model.midiLike
     | model.editLike
     | model.transcriptionLike
     | model.eventLike.measureFilling
     | model.noteModifierLike
     | model.sectionLike
     | model.measureLike
     | model.staffLike
     | model.layerLike
     | model.graphicprimitiveLike
     | model.fLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.edit.attributes,
    att.trans.attributes,
    empty
  }
choice =
  
  ## Groups a number of alternative encodings for the same point in a text. 
  element choice { model.choicePart*, att.common.attributes, empty }
corr =
  
  ## (correction)  Contains the correct form of an apparent erroneous passage. 
  element corr {
    (text
     | model.textphraseLike
     | model.eventLike
     | model.eventLike.neumes
     | model.controleventLike
     | model.lyricsLike
     | model.midiLike
     | model.editLike
     | model.transcriptionLike
     | model.eventLike.measureFilling
     | model.noteModifierLike
     | model.sectionLike
     | model.measureLike
     | model.staffLike
     | model.layerLike
     | model.graphicprimitiveLike
     | model.fLike)*,
    att.common.attributes,
    att.edit.attributes,
    att.trans.attributes,
    empty
  }
damage =
  
  ## Contains an area of damage to the physical medium.
  element damage {
    (text
     | model.textphraseLike
     | model.eventLike
     | model.eventLike.neumes
     | model.controleventLike
     | model.lyricsLike
     | model.midiLike
     | model.editLike
     | model.transcriptionLike
     | model.eventLike.measureFilling
     | model.noteModifierLike
     | model.sectionLike
     | model.measureLike
     | model.staffLike
     | model.layerLike
     | model.graphicprimitiveLike
     | model.fLike)*,
    att.agentident.attributes,
    att.common.attributes,
    att.extent.attributes,
    att.facsimile.attributes,
    att.handident.attributes,
    att.typed.attributes,
    
    ## records the degree of damage.
    attribute degree { text }?,
    empty
  }
del =
  
  ## (deletion)  Contains information deleted, marked as deleted, or otherwise indicated as superfluous or spurious in the copy text by an author, scribe, annotator, or corrector. 
  element del {
    (text
     | model.textphraseLike
     | model.eventLike
     | model.eventLike.neumes
     | model.controleventLike
     | model.lyricsLike
     | model.midiLike
     | model.editLike
     | model.transcriptionLike
     | model.eventLike.measureFilling
     | model.noteModifierLike
     | model.sectionLike
     | model.measureLike
     | model.staffLike
     | model.layerLike
     | model.graphicprimitiveLike
     | model.fLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.trans.attributes,
    
    ## contains an indication of how the deletion should be rendered.
    attribute rend { text }?,
    empty
  }
expan =
  
  ## (expansion)  Contains the expansion of an abbreviation.
  element expan {
    (text
     | model.textphraseLike
     | model.eventLike
     | model.eventLike.neumes
     | model.controleventLike
     | model.lyricsLike
     | model.midiLike
     | model.editLike
     | model.transcriptionLike
     | model.eventLike.measureFilling
     | model.noteModifierLike
     | model.sectionLike
     | model.measureLike
     | model.staffLike
     | model.layerLike
     | model.graphicprimitiveLike
     | model.fLike)*,
    att.common.attributes,
    att.edit.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.trans.attributes,
    att.typed.attributes,
    
    ## captures the unabbreviated form of the text.
    attribute abbr { text }?,
    empty
  }
gap =
  
  ## Indicates a point where material has been omitted in a transcription, whether as part of sampling practice or for editorial reasons described in the MEI header. 
  element gap {
    empty,
    att.common.attributes,
    att.edit.attributes,
    att.extent.attributes,
    att.handident.attributes,
    att.reasonident.attributes,
    att.measurement.attributes,
    empty
  }
handShift =
  
  ## Marks the beginning of a passage written in a new hand, or of a change in the scribe, writing style, ink or character of the document hand. 
  element handShift {
    empty,
    att.common.attributes,
    att.edit.attributes,
    att.facsimile.attributes,
    att.medium.attributes,
    
    ## describes the character of the new hand.
    attribute character { text }?,
    
    ## identifies the new hand. The value must contain the ID of a hand element given elsewhere in the document.
    attribute new { data.URI }?,
    
    ## identifies the old hand. The value must contain the ID of a hand element given elsewhere in the document.
    attribute old { data.URI }?,
    empty
  }
orig =
  
  ## (original)  Contains material which is marked as following the original, rather than being normalized or corrected. 
  element orig {
    (text
     | model.textphraseLike
     | model.eventLike
     | model.eventLike.neumes
     | model.controleventLike
     | model.lyricsLike
     | model.midiLike
     | model.editLike
     | model.transcriptionLike
     | model.eventLike.measureFilling
     | model.noteModifierLike
     | model.sectionLike
     | model.measureLike
     | model.staffLike
     | model.layerLike
     | model.graphicprimitiveLike
     | model.fLike)*,
    att.common.attributes,
    att.edit.attributes,
    att.facsimile.attributes,
    att.typed.attributes,
    empty
  }
reg =
  
  ## (regularization)  Contains material which has been regularized or normalized in some sense. 
  element reg {
    (text
     | model.textphraseLike
     | model.eventLike
     | model.eventLike.neumes
     | model.controleventLike
     | model.lyricsLike
     | model.midiLike
     | model.editLike
     | model.transcriptionLike
     | model.eventLike.measureFilling
     | model.noteModifierLike
     | model.sectionLike
     | model.measureLike
     | model.staffLike
     | model.layerLike
     | model.graphicprimitiveLike
     | model.fLike)*,
    att.common.attributes,
    att.authorized.attributes,
    att.edit.attributes,
    empty
  }
restore =
  
  ## Indicates restoration of material to an earlier state by cancellation of an editorial or authorial marking or instruction. 
  element restore {
    (text
     | model.textphraseLike
     | model.eventLike
     | model.eventLike.neumes
     | model.controleventLike
     | model.lyricsLike
     | model.midiLike
     | model.editLike
     | model.transcriptionLike
     | model.eventLike.measureFilling
     | model.noteModifierLike
     | model.sectionLike
     | model.measureLike
     | model.staffLike
     | model.layerLike
     | model.graphicprimitiveLike
     | model.fLike)*,
    att.common.attributes,
    att.edit.attributes,
    att.facsimile.attributes,
    att.trans.attributes,
    att.typed.attributes,
    
    ## provides a description of the means of restoration.
    attribute desc { text }?,
    empty
  }
sic =
  
  ## Contains apparently incorrect or inaccurate material. 
  element sic {
    (text
     | model.textphraseLike
     | model.eventLike
     | model.eventLike.neumes
     | model.controleventLike
     | model.lyricsLike
     | model.midiLike
     | model.editLike
     | model.transcriptionLike
     | model.eventLike.measureFilling
     | model.noteModifierLike
     | model.sectionLike
     | model.measureLike
     | model.staffLike
     | model.layerLike
     | model.graphicprimitiveLike
     | model.fLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    empty
  }
subst =
  
  ## (substitution)  Groups transcriptional elements when the combination is to be regarded as a single intervention in the text. 
  element subst {
    model.transcriptionLike,
    model.transcriptionLike+,
    att.common.attributes,
    att.edit.attributes,
    att.trans.attributes,
    empty
  }
supplied =
  
  ## Contains material supplied by the transcriber or editor in place of text which cannot be read, either because of physical damage or loss in the original or because it is illegible for any reason. 
  element supplied {
    (text
     | model.textphraseLike
     | model.eventLike
     | model.eventLike.neumes
     | model.controleventLike
     | model.lyricsLike
     | model.midiLike
     | model.editLike
     | model.transcriptionLike
     | model.eventLike.measureFilling
     | model.noteModifierLike
     | model.sectionLike
     | model.measureLike
     | model.staffLike
     | model.layerLike
     | model.graphicprimitiveLike
     | model.fLike)*,
    att.agentident.attributes,
    att.common.attributes,
    att.edit.attributes,
    att.facsimile.attributes,
    att.reasonident.attributes,
    empty
  }
unclear =
  
  ## Contains material that cannot be transcribed with certainty because it is illegible or inaudible in the source. 
  element unclear {
    (text
     | model.textphraseLike
     | model.eventLike
     | model.eventLike.neumes
     | model.controleventLike
     | model.lyricsLike
     | model.midiLike
     | model.editLike
     | model.transcriptionLike
     | model.eventLike.measureFilling
     | model.noteModifierLike
     | model.sectionLike
     | model.measureLike
     | model.staffLike
     | model.layerLike
     | model.graphicprimitiveLike
     | model.fLike)*,
    att.agentident.attributes,
    att.common.attributes,
    att.edit.attributes,
    att.facsimile.attributes,
    att.handident.attributes,
    att.reasonident.attributes,
    empty
  }
att.facsimile.attributes = att.facsimile.attribute.facs
att.facsimile.attribute.facs =
  
  ## permits the current element to reference a facsimile image or image zone which corresponds to it.
  attribute facs { data.URIS }?
facsimile =
  
  ## Contains a representation of some written source in the form of a set of images rather than as transcribed or encoded text. 
  element facsimile {
    surface*, att.common.attributes, att.declaring.attributes, empty
  }
surface =
  
  ## Defines a writing surface in terms of a rectangular coordinate space, optionally grouping one or more graphic representations of that space, and rectangular zones of interest within it. 
  element surface {
    model.figDescLike*,
    model.graphicLike*,
    zone*,
    att.common.attributes,
    att.coordinated.attributes,
    att.datapointing.attributes,
    att.declaring.attributes,
    att.startid.attributes,
    empty
  }
zone =
  
  ## Defines an area of interest within a surface or graphic file. 
  element zone {
    model.figDescLike*,
    model.graphicLike*,
    att.common.attributes,
    att.coordinated.attributes,
    att.datapointing.attributes,
    att.typed.attributes,
    empty
  }
att.tabular.attributes =
  att.tabular.attribute.colspan, att.tabular.attribute.rowspan
att.tabular.attribute.colspan =
  
  ## the number of columns spanned by this cell.
  attribute colspan { xsd:positiveInteger }?
att.tabular.attribute.rowspan =
  
  ## the number of rows spanned by this cell.
  attribute rowspan { xsd:positiveInteger }?
model.figDescLike = figDesc
model.figureLike = fig
model.figureLike_alternation = fig
model.figureLike_sequence = fig
model.figureLike_sequenceOptional = fig?
model.figureLike_sequenceOptionalRepeatable = fig*
model.figureLike_sequenceRepeatable = fig+
model.graphicLike = graphic
model.tableLike = table
fig =
  
  ## (figure)  groups elements representing or containing graphic information such as an illustration or figure. 
  element fig {
    (model.captionLike | figDesc | model.graphicLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.xy.attributes,
    empty
  }
figDesc =
  
  ## (figure description)  Contains a brief prose description of the appearance or content of a graphic figure, for use when documenting an image without displaying it. 
  element figDesc {
    (text
     | model.graphicprimitiveLike
     | model.textcomponentLike
     | model.annotLike)*,
    att.common.attributes,
    att.lang.attributes,
    empty
  }
graphic =
  
  ## Indicates the location of an inline graphic, illustration, or figure. 
  element graphic {
    (zone*)
    >> sch:pattern [
         id = "mei-graphic-graphic_child_of_zone-constraint-51"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:zone/mei:graphic"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "count(mei:*) = 0"
             "graphic child of zone cannot have\x{a}" ~
             "              children"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.declaring.attributes,
    att.internetmedia.attributes,
    att.facsimile.attributes,
    att.pointing.attributes,
    att.measurement.attributes,
    att.typed.attributes,
    att.width.attributes,
    
    ## measurement of the vertical dimension of an image.
    attribute height { xsd:positiveInteger }?,
    empty
  }
table =
  
  ## Contains text displayed in tabular form. 
  element table {
    model.captionLike?,
    tr+,
    model.captionLike?,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.xy.attributes,
    empty
  }
td =
  
  ## (table data)  Designates a table cell that contains data as opposed to a cell that contains column or row heading information. 
  element td {
    (text
     | model.textcomponentLike
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.xy.attributes,
    att.tabular.attributes,
    empty
  }
th =
  
  ## (table header)  Designates a table cell containing column or row heading information as opposed to one containing data. 
  element th {
    (text
     | model.textcomponentLike
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.xy.attributes,
    att.tabular.attributes,
    empty
  }
tr =
  
  ## (table row)  A formatting element that contains one or more cells (intersection of a row and a column) in a <table>. 
  element tr {
    (th | td)+,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.xy.attributes,
    empty
  }
att.rel.attributes = att.rel.attribute.rel
att.rel.attribute.rel =
  
  ## Describes the relationship between the element's parent (subject) and the object pointed at. The values follow FRBR (see http://www.ifla.org/files/cataloguing/frbr/frbr_2008.pdf).
  attribute rel {
    
    ##
    "hasSuccessor"
    | 
      ##
      "isSuccessorOf"
    | 
      ##
      "hasSupplement"
    | 
      ##
      "isSupplementOf"
    | 
      ##
      "hasComplement"
    | 
      ##
      "isComplementOf"
    | 
      ##
      "hasSummarization"
    | 
      ##
      "isSummarizationOf"
    | 
      ##
      "hasAdaptation"
    | 
      ##
      "isAdaptationOf"
    | 
      ##
      "hasTransformation"
    | 
      ##
      "isTransformationOf"
    | 
      ##
      "hasImitation"
    | 
      ##
      "isImitationOf"
    | 
      ##
      "hasPart"
    | 
      ##
      "isPartOf"
    | 
      ##
      "hasReproduction"
    | 
      ##
      "isReproductionOf"
    | 
      ##
      "hasAbridgement"
    | 
      ##
      "isAbridgementOf"
    | 
      ##
      "hasRevision"
    | 
      ##
      "isRevisionOf"
    | 
      ##
      "hasTranslation"
    | 
      ##
      "isTranslationOf"
    | 
      ##
      "hasArrangement"
    | 
      ##
      "isArrangementOf"
    | 
      ##
      "hasAlternate"
    | 
      ##
      "isAlternateOf"
    | 
      ##
      "hasReconfiguration"
    | 
      ##
      "isReconfigurationOf"
    | 
      ##
      "hasRealization"
    | 
      ##
      "isRealizationOf"
    | 
      ##
      "hasEmbodiment"
    | 
      ##
      "isEmbodimentOf"
    | 
      ##
      "hasExemplar"
    | 
      ##
      "isExemplarOf"
  }
model.expressionLike = expression
model.itemLike = item
model.manifestationLike = source
model.relationLike = relation
componentGrp =
  
  ## (component group)  The child elements of this element are treated as parts of the elements header. Although this is an implicit way of expressing FRBR's hasPart / isPartOf -relationships, it avoids this terminology in order to prevent confusion with musical terminology. All children of a component must be the same type as its parent: works within work, items in item, etc.
  element componentGrp {
    (model.workLike*
     | model.expressionLike*
     | model.manifestationLike*
     | model.itemLike*)
    >> sch:pattern [
         id = "mei-componentGrp-checkComponentGrp-constraint-52"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:componentGrp"
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "every $i in ./child::mei:* satisfies $i/local-name() eq               ./parent::mei:*/local-name()"
             " Only child elements of the same name as the parent of\x{a}" ~
             "              the componentGrp-element are allowed. "
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    empty
  }
expression =
  
  ## Intellectual or artistic realization of a work.
  element expression {
    model.identifierLike*,
    titleStmt?,
    model.workIdent*,
    otherChar?,
    history?,
    langUsage?,
    perfMedium?,
    extent?,
    scoreFormat?,
    contents?,
    context?,
    biblList*,
    notesStmt?,
    classification?,
    componentGrp?,
    relationList?,
    att.datapointing.attributes,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
expressionList =
  
  ## Gathers bibliographic expression entities.
  element expressionList {
    model.expressionLike*, att.common.attributes, empty
  }
item =
  
  ## Single instance or exemplar of a source/manifestation.
  element item {
    model.identifierLike*,
    macro.availabilityPart?,
    physDesc?,
    physLoc?,
    notesStmt?,
    classification?,
    componentGrp?,
    relationList?,
    att.datapointing.attributes,
    att.common.attributes,
    att.bibl.attributes,
    att.pointing.attributes,
    empty
  }
itemList =
  
  ## Gathers bibliographic item entities.
  element itemList { model.itemLike*, att.common.attributes, empty }
relation =
  
  ## A relation element describes the relationship between its parent and the object referenced by the relation element's target attribute. 
  element relation {
    empty,
    att.pointing.attributes,
    att.edit.attributes,
    att.rel.attributes,
    att.common.attributes,
    empty
  }
relationList =
  
  ## Gathers bibliographic relation elements.
  element relationList {
    model.relationLike*, att.common.attributes, empty
  }
att.fretlocation.attributes = att.fretlocation.attribute.fret
att.fretlocation.attribute.fret =
  
  ## records the location at which a string should be stopped against a fret.
  attribute fret { data.FRET }?
att.harm.anl.attributes = att.common.anl.attributes
att.harm.ges.attributes = att.duration.performed.attributes
att.harm.log.attributes =
  att.controlevent.attributes,
  att.augmentdots.attributes,
  att.duration.additive.attributes,
  att.startendid.attributes,
  att.timestamp2.musical.attributes,
  att.harm.log.attribute.chordref
att.harm.log.attribute.chordref =
  
  ## contains a reference to a <chordDef> element elsewhere in the document.
  attribute chordref { data.URI }?
att.harm.vis.attributes =
  att.placement.attributes,
  att.visualoffset.attributes,
  att.visualoffset2.ho.attributes,
  att.visualoffset2.to.attributes,
  att.xy.attributes,
  att.harm.vis.attribute.extender,
  att.harm.vis.attribute.rendgrid
att.harm.vis.attribute.extender =
  
  ## indicates the presence of an extension symbol, typically a dash or underscore, drawn from the end of the harmonic indication to the point indicated by the dur attribute.
  attribute extender { data.BOOLEAN }?
att.harm.vis.attribute.rendgrid =
  
  ## describes how the harmonic indication should be rendered.
  attribute rendgrid {
    
    ## chord tablature grid.
    "grid"
    | 
      ## chord tablature grid and the element's textual content.
      "gridtext"
    | 
      ## textual content of the element.
      "text"
  }?
model.chordTableLike = chordTable
model.controleventLike.harmony = model.harmLike
model.controleventLike.harmony_alternation = model.harmLike_alternation
model.controleventLike.harmony_sequence = model.harmLike_sequence
model.controleventLike.harmony_sequenceOptional =
  model.harmLike_sequenceOptional?
model.controleventLike.harmony_sequenceOptionalRepeatable =
  model.harmLike_sequenceOptionalRepeatable*
model.controleventLike.harmony_sequenceRepeatable =
  model.harmLike_sequenceRepeatable+
model.figbassLike = fb
model.fLike = f
model.harmLike = harm
model.harmLike_alternation = harm
model.harmLike_sequence = harm
model.harmLike_sequenceOptional = harm?
model.harmLike_sequenceOptionalRepeatable = harm*
model.harmLike_sequenceRepeatable = harm+
barre =
  
  ## An indication of fingering in a chord tablature grid. 
  element barre {
    empty,
    att.common.attributes,
    att.fretlocation.attributes,
    att.startendid.attributes,
    empty
  }
chordDef =
  
  ## (chord definition)  Chord tablature definition. 
  element chordDef {
    chordMember*,
    barre*,
    att.common.attributes,
    
    ## records the fret position at which the chord tablature is to be played.
    attribute pos { xsd:positiveInteger }?,
    empty
  }
chordMember =
  
  ## An individual pitch in a chord defined by a <chordDef> element. 
  element chordMember {
    empty,
    att.common.attributes,
    att.accidental.performed.attributes,
    att.fretlocation.attributes,
    att.intervalharmonic.attributes,
    att.pitched.attributes,
    
    ## indicates which finger, if any, should be used to play an individual string. The index, middle, ring, and little fingers are represented by the values 1-4, while 't' is for the thumb. The values 'x' and 'o' indicate muffled and open strings, respectively.
    attribute fing { data.FINGER.FRET }?,
    empty
  }
chordTable =
  
  ## Chord/tablature look-up table. 
  element chordTable { chordDef+, att.common.attributes, empty }
f =
  
  ## (figure)  Single element of a figured bass indication.
  element f {
    (text
     | model.textphraseLike.limited
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.common.anl.attributes,
    att.altsym.attributes,
    att.facsimile.attributes,
    
    ## indicates the presence of an extension symbol, typically a dash or underscore, drawn from the end of the harmonic indication to the point indicated by the dur attribute.
    attribute extender { data.BOOLEAN }?,
    empty
  }
fb =
  
  ## (figured bass)  Symbols added to a bass line that indicate harmony. Used to improvise a chordal accompaniment. Sometimes called Generalbass, thoroughbass, or basso continuo.
  element fb {
    (model.fLike | model.editLike | model.transcriptionLike)*,
    att.common.attributes,
    att.common.anl.attributes,
    att.facsimile.attributes,
    empty
  }
harm =
  
  ## (harmony)  An indication of harmony, e.g., chord names, tablature grids, harmonic analysis, figured bass.
  element harm {
    ((text
      | model.textphraseLike.limited
      | model.graphicprimitiveLike
      | model.editLike
      | model.transcriptionLike
      | model.figbassLike)*)
    >> sch:pattern [
         id =
           "mei-harm-harm_start-type_attributes_required-constraint-53"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:harm"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             " Must have one of\x{a}" ~
             "              the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.harm.log.attributes,
    att.harm.vis.attributes,
    att.harm.ges.attributes,
    att.harm.anl.attributes,
    empty
  }
att.alignment.attributes = att.alignment.attribute.when
att.alignment.attribute.when =
  
  ## indicates the point of occurrence of this feature along a time line. Its value must be the ID of a <when> element elsewhere in the document.
  attribute when { data.URI }?
model.alignLike = timeline
timeline =
  
  ## Provides a set of ordered points in time to which musical elements can be linked in order to create a temporal alignment of those elements. 
  element timeline {
    when*,
    att.common.attributes,
    
    ## holds the identifier of an <avFile> element that references an external digital media file.
    attribute avref { data.URI }?,
    
    ## designates the origin of the timeline, i.e. the <when> element associated with the beginning of the timeline.
    attribute origin { data.URI },
    empty
  }
when =
  
  ## Indicates a point in time either absolutely (using the absolute attribute), or relative to other elements in the same timeline element (using the interval and since attributes). 
  element when {
    empty,
    att.common.attributes,
    att.datapointing.attributes,
    
    ## provides an absolute value for the time associated with a point on a timeline. This attribute is required for the element designated as the origin by the parent timeline.
    attribute absolute { data.ISOTIME }?,
    
    ## specifies the time interval between this time point and the one designated by the since attribute. This attribute can only be interpreted meaningfully in conjunction with the inttype attribute.
    attribute interval { text }?,
    
    ## specifies the kind of values used in the interval attribute.
    attribute inttype {
      
      ## byte value.
      "byte"
      | 
        ## Synchronized Multimedia Integration Language.
        "smil"
      | 
        ## MIDI time code.
        "midi"
      | 
        ## SMPTE 25 EBU.
        "smpte-25"
      | 
        ## SMPTE 24 Film Sync.
        "smpte-24"
      | 
        ## SMPTE 30 Drop.
        "smpte-df30"
      | 
        ## SMPTE 30 Non-Drop.
        "smpte-ndf30"
      | 
        ## SMPTE 29.97 Drop.
        "smpte-df29.97"
      | 
        ## SMPTE 29.97 Non-Drop.
        "smpte-ndf29.97"
      | 
        ## AES Time-code character format.
        "tcf"
      | 
        ## ISO 24-hour time format: HH:MM:SS.ss.
        "time"
    }?,
    
    ## identifies the reference point for determining the time of the current when element, which is obtained by adding the interval to the time of the reference point. The value should be the ID of another when element in the same timeline. If the since attribute is omitted and the absolute attribute is not specified, then the reference point is understood to be the immediately preceding when element.
    attribute since { data.URI }?,
    empty
  }
att.lyrics.anl.attributes = att.common.anl.attributes
att.lyrics.ges.attributes = empty
att.lyrics.log.attributes =
  att.staffident.attributes, att.layerident.attributes
att.lyrics.vis.attributes =
  att.placement.attributes, att.typography.attributes
att.verse.anl.attributes = att.common.anl.attributes
att.verse.ges.attributes = empty
att.verse.log.attributes =
  att.verse.log.attribute.refrain, att.verse.log.attribute.rhythm
att.verse.log.attribute.refrain =
  
  ## used to indicate a common, usually centered, refrain (Mup User's Guide, p. 44).
  attribute refrain { data.BOOLEAN }?
att.verse.log.attribute.rhythm =
  
  ## used to specify a rhythm for the lyric syllables that differs from that of the notes on the staff, e.g. '4,4,4,4' when the rhythm of the notes is '4.,8,4.,8'.
  attribute rhythm { text }?
att.verse.vis.attributes =
  att.typography.attributes,
  att.visualoffset.to.attributes,
  att.visualoffset.vo.attributes,
  att.xy.attributes
model.lyricsLike = lyrics
model.lyricsLike_alternation = lyrics
model.lyricsLike_sequence = lyrics
model.lyricsLike_sequenceOptional = lyrics?
model.lyricsLike_sequenceOptionalRepeatable = lyrics*
model.lyricsLike_sequenceRepeatable = lyrics+
model.sylLike = syl
model.verseLike = verse
lyrics =
  
  ## Vocally performed 'text' of a musical composition, such as a song or opera. 
  element lyrics {
    model.verseLike+,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.lyrics.log.attributes,
    att.lyrics.vis.attributes,
    att.lyrics.ges.attributes,
    att.lyrics.anl.attributes,
    empty
  }
verse =
  
  ## Lyric verse. 
  element verse {
    (dir | dynam | tempo | space)*,
    model.sylLike+,
    model.lbLike*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.verse.log.attributes,
    att.verse.vis.attributes,
    att.verse.ges.attributes,
    att.verse.anl.attributes,
    empty
  }
att.channelized.attributes =
  att.channelized.attribute.midi.channel,
  att.channelized.attribute.midi.duty,
  att.channelized.attribute.midi.port,
  att.channelized.attribute.midi.track
att.channelized.attribute.midi.channel =
  
  ## records a MIDI channel value.
  attribute midi.channel { data.MIDICHANNEL }?
att.channelized.attribute.midi.duty =
  
  ## specifies the 'on' part of the duty cycle as a percentage of a note's duration.
  attribute midi.duty { data.PERCENT }?
att.channelized.attribute.midi.port =
  
  ## sets the MIDI port value.
  attribute midi.port { data.MIDIVALUE }?
att.channelized.attribute.midi.track =
  
  ## sets the MIDI track.
  attribute midi.track { xsd:positiveInteger }?
att.midi.anl.attributes = att.common.anl.attributes
att.midi.event.attributes =
  att.staffident.attributes,
  att.layerident.attributes,
  att.timestamp.musical.attributes
att.midi.ges.attributes = empty
att.midi.log.attributes =
  att.staffident.attributes, att.layerident.attributes
att.midi.vis.attributes = empty
att.midiinstrument.attributes =
  att.midiinstrument.attribute.midi.instrnum,
  att.midiinstrument.attribute.midi.instrname,
  att.midiinstrument.attribute.midi.pan,
  att.midiinstrument.attribute.midi.volume
att.midiinstrument.attribute.midi.instrnum =
  
  ## sets the MIDI instrument number.
  attribute midi.instrnum { data.MIDIVALUE }?
att.midiinstrument.attribute.midi.instrname =
  
  ## provides a General MIDI label for the MIDI instrument.
  attribute midi.instrname { data.MIDINAMES }?
att.midiinstrument.attribute.midi.pan =
  
  ## sets the instrument's position in a stereo field. Values of 0 and 1 both pan left, 127 pans right, and 64 pans to the center.
  attribute midi.pan { data.MIDIVALUE }?
att.midiinstrument.attribute.midi.volume =
  
  ## sets the instrument's volume.
  attribute midi.volume { data.MIDIVALUE }?
att.midinumber.attributes = att.midinumber.attribute.num
att.midinumber.attribute.num =
  
  ## MIDI number in the range set by data.MIDIVALUE.
  attribute num { data.MIDIVALUE }
att.miditempo.attributes = att.miditempo.attribute.midi.tempo
att.miditempo.attribute.midi.tempo =
  
  ## contains a MIDI value, that is, the number of quarter notes per minute in the range from 10 to 1000.
  attribute midi.tempo { data.MIDITEMPO }?
att.midivalue.attributes = att.midivalue.attribute.val
att.midivalue.attribute.val =
  
  ## MIDI number.
  attribute val { data.MIDIVALUE }?
att.timebase.attributes = att.timebase.attribute.ppq
att.timebase.attribute.ppq =
  
  ## indicates the number of pulses (sometimes referred to as ticks or divisions) per quarter note. Unlike MIDI, MEI permits different values for a score and individual staves.
  attribute ppq { xsd:positiveInteger }?
model.midiLike = midi
model.midiLike_alternation = midi
model.midiLike_sequence = midi
model.midiLike_sequenceOptional = midi?
model.midiLike_sequenceOptionalRepeatable = midi*
model.midiLike_sequenceRepeatable = midi+
cc =
  
  ## (control change)  MIDI parameter/control change. 
  element cc {
    empty,
    att.common.anl.attributes,
    att.common.attributes,
    att.midi.event.attributes,
    att.midinumber.attributes,
    att.midivalue.attributes,
    empty
  }
chan =
  
  ## (channel)  MIDI channel assignment.
  element chan {
    empty,
    att.common.anl.attributes,
    att.common.attributes,
    att.midi.event.attributes,
    
    ## MIDI number in the range set by data.MIDICHANNEL.
    attribute num { data.MIDICHANNEL },
    empty
  }
chanPr =
  
  ## (channel pressure)  MIDI channel pressure/after touch. 
  element chanPr {
    empty,
    att.common.anl.attributes,
    att.common.attributes,
    att.midi.event.attributes,
    att.midinumber.attributes,
    empty
  }
cue =
  
  ## MIDI cue point.
  element cue {
    text,
    att.common.anl.attributes,
    att.common.attributes,
    att.midi.event.attributes,
    empty
  }
hex =
  
  ## Arbitrary MIDI data in hexadecimal form. 
  element hex {
    text,
    att.common.anl.attributes,
    att.common.attributes,
    att.midi.event.attributes,
    empty
  }
instrDef =
  
  ## (instrument definition)  MIDI instrument declaration. 
  element instrDef {
    empty,
    att.common.attributes,
    att.channelized.attributes,
    att.midiinstrument.attributes,
    empty
  }
instrGrp =
  
  ## (instrument group)  Collects MIDI instrument definitions.
  element instrGrp { model.instrDefLike+, att.common.attributes, empty }
marker =
  
  ## MIDI marker meta-event.
  element marker {
    text,
    att.common.anl.attributes,
    att.common.attributes,
    att.midi.event.attributes,
    empty
  }
metaText =
  
  ## MIDI text meta-event.
  element metaText {
    text,
    att.common.anl.attributes,
    att.common.attributes,
    att.midi.event.attributes,
    empty
  }
midi =
  
  ## Container for elements that contain information useful when generating MIDI output. 
  element midi {
    (cc
     | chan
     | chanPr
     | cue
     | hex
     | marker
     | metaText
     | noteOff
     | noteOn
     | port
     | prog
     | seqNum
     | trkName
     | vel)*,
    att.common.attributes,
    att.midi.log.attributes,
    att.midi.vis.attributes,
    att.midi.ges.attributes,
    att.midi.anl.attributes,
    empty
  }
noteOff =
  
  ## MIDI note-off event.
  element noteOff {
    empty,
    att.common.anl.attributes,
    att.common.attributes,
    att.midi.event.attributes,
    att.midinumber.attributes,
    empty
  }
noteOn =
  
  ## MIDI note-on event.
  element noteOn {
    empty,
    att.common.anl.attributes,
    att.common.attributes,
    att.midi.event.attributes,
    att.midinumber.attributes,
    empty
  }
port =
  
  ## MIDI port. 
  element port {
    empty,
    att.common.anl.attributes,
    att.common.attributes,
    att.midi.event.attributes,
    att.midinumber.attributes,
    empty
  }
prog =
  
  ## (program)  MIDI program change. 
  element prog {
    empty,
    att.common.anl.attributes,
    att.common.attributes,
    att.midi.event.attributes,
    att.midinumber.attributes,
    empty
  }
seqNum =
  
  ## (sequence number)  MIDI sequence number.
  element seqNum {
    empty,
    att.common.anl.attributes,
    att.common.attributes,
    att.midi.event.attributes,
    
    ## number in the range 0-65535.
    attribute num {
      xsd:nonNegativeInteger { maxInclusive = "65535" }
    },
    empty
  }
trkName =
  
  ## (track name)  MIDI track/sequence name.
  element trkName {
    text,
    att.common.anl.attributes,
    att.common.attributes,
    att.midi.event.attributes,
    empty
  }
vel =
  
  ## (velocity)  MIDI Note-on/off velocity. 
  element vel {
    empty,
    att.common.anl.attributes,
    att.common.attributes,
    att.midi.event.attributes,
    att.midinumber.attributes,
    
    ## indicates whether this is note-on or note-off velocity data.
    attribute form {
      
      ##
      "on"
      | 
        ##
        "off"
    },
    empty
  }
model.nameLike.agent = corpName | persName
model.nameLike.agent_alternation = corpName | persName
model.nameLike.agent_sequence = corpName, persName
model.nameLike.agent_sequenceOptional = corpName?, persName?
model.nameLike.agent_sequenceOptionalRepeatable = corpName*, persName*
model.nameLike.agent_sequenceRepeatable = corpName+, persName+
model.nameLike.geogName = geogName
model.nameLike.geogName_alternation = geogName
model.nameLike.geogName_sequence = geogName
model.nameLike.geogName_sequenceOptional = geogName?
model.nameLike.geogName_sequenceOptionalRepeatable = geogName*
model.nameLike.geogName_sequenceRepeatable = geogName+
model.nameLike.label = periodName | styleName
model.nameLike.label_alternation = periodName | styleName
model.nameLike.label_sequence = periodName, styleName
model.nameLike.label_sequenceOptional = periodName?, styleName?
model.nameLike.label_sequenceOptionalRepeatable =
  periodName*, styleName*
model.nameLike.label_sequenceRepeatable = periodName+, styleName+
model.nameLike.place = model.repositoryLike | model.nameLike.geogName
model.nameLike.place_alternation =
  model.repositoryLike_alternation | model.nameLike.geogName_alternation
model.nameLike.place_sequence =
  model.repositoryLike_sequence, model.nameLike.geogName_sequence
model.nameLike.place_sequenceOptional =
  model.repositoryLike_sequenceOptional?,
  model.nameLike.geogName_sequenceOptional?
model.nameLike.place_sequenceOptionalRepeatable =
  model.repositoryLike_sequenceOptionalRepeatable*,
  model.nameLike.geogName_sequenceOptionalRepeatable*
model.nameLike.place_sequenceRepeatable =
  model.repositoryLike_sequenceRepeatable+,
  model.nameLike.geogName_sequenceRepeatable+
corpName =
  
  ## (corporate name)  Identifies an organization or group of people that acts as a single entity. 
  element corpName {
    (text
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.bibl.attributes,
    att.common.attributes,
    att.datable.attributes,
    att.edit.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.name.attributes,
    att.typed.attributes,
    empty
  }
geogName =
  
  ## (geographic name)  The proper noun designation for a place, natural feature, or political jurisdiction. 
  element geogName {
    (text
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.bibl.attributes,
    att.common.attributes,
    att.edit.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.name.attributes,
    att.typed.attributes,
    empty
  }
periodName =
  
  ## (period name)  A label that describes a period of time, such as 'Baroque' or '3rd Style period'. 
  element periodName {
    (text
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.bibl.attributes,
    att.common.attributes,
    att.datable.attributes,
    att.edit.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.name.attributes,
    att.typed.attributes,
    empty
  }
persName =
  
  ## (personal name)  Designation for an individual, including any or all of that individual's forenames, surnames, honorific titles, and added names 
  element persName {
    (text
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.bibl.attributes,
    att.common.attributes,
    att.datable.attributes,
    att.edit.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.name.attributes,
    att.typed.attributes,
    empty
  }
styleName =
  
  ## (style name)  A label for a characteristic style of writing or performance, such as 'bebop' or 'rock-n-roll'. 
  element styleName {
    (text
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.bibl.attributes,
    att.common.attributes,
    att.edit.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.name.attributes,
    att.typed.attributes,
    empty
  }
avFile =
  
  ## (audio/video file)  References an external digital audio or video file. 
  element avFile {
    (clip*)
    >> sch:pattern [
         id = "mei-avFile-avFile_child_of_clip-constraint-54"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:clip/mei:avFile"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "count(mei:*) = 0"
             "avFile child of clip cannot have\x{a}" ~
             "              children"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.declaring.attributes,
    att.internetmedia.attributes,
    att.facsimile.attributes,
    att.pointing.attributes,
    att.typed.attributes,
    empty
  }
clip =
  
  ## Defines a time segment of interest within a recording or within a digital audio or video file. 
  element clip {
    avFile*,
    att.common.attributes,
    att.declaring.attributes,
    att.mediabounds.attributes,
    att.startid.attributes,
    empty
  }
performance =
  
  ## A presentation of one or more musical works. 
  element performance {
    recording*, att.common.attributes, att.declaring.attributes, empty
  }
recording =
  
  ## A recorded performance. 
  element recording {
    avFile*,
    clip*,
    att.common.attributes,
    att.declaring.attributes,
    att.mediabounds.attributes,
    att.startid.attributes,
    empty
  }
model.locrefLike = ptr | ref
model.locrefLike_alternation = ptr | ref
model.locrefLike_sequence = ptr, ref
model.locrefLike_sequenceOptional = ptr?, ref?
model.locrefLike_sequenceOptionalRepeatable = ptr*, ref*
model.locrefLike_sequenceRepeatable = ptr+, ref+
ptr =
  
  ## (pointer)  Defines a pointer to another location, using only attributes to describe the destination. 
  element ptr {
    empty,
    att.common.attributes,
    att.internetmedia.attributes,
    att.pointing.attributes,
    empty
  }
ref =
  
  ## (reference)  Defines a reference to another location that may contain text and sub-elements to describe the destination. 
  element ref {
    (text | model.textphraseLike)*,
    att.common.attributes,
    att.internetmedia.attributes,
    att.lang.attributes,
    att.pointing.attributes,
    empty
  }
att.note.ges.tablature.attributes =
  att.note.ges.tablature.attribute.tab.fret,
  att.note.ges.tablature.attribute.tab.string
att.note.ges.tablature.attribute.tab.fret =
  
  ## records the fret at which a string should be stopped.
  attribute tab.fret { data.FRETNUMBER }?
att.note.ges.tablature.attribute.tab.string =
  
  ## records which string is to be played.
  attribute tab.string { data.STRINGNUMBER }?
att.staffDef.ges.tablature.attributes =
  att.staffDef.ges.tablature.attribute.tab.strings
att.staffDef.ges.tablature.attribute.tab.strings =
  
  ## provides a *written* pitch and octave for each open string.
  attribute tab.strings {
    list {
      xsd:token { pattern = "[a-g][\-#fs]?[0-9]" }+
    }
  }?
model.backLike = back
model.divLike = \div
model.frontLike = front
model.headLike = head
model.lgLike = lg
model.listLike = biblList | castList | \list
model.lLike = l
model.quoteLike = quote
back =
  
  ## (back matter)  Contains any appendixes, advertisements, indexes, etc. following the main body of a musical text. 
  element back {
    model.milestoneLike.text*,
    (model.divLike | model.frontPart)+,
    model.milestoneLike.text*,
    att.common.attributes,
    att.declaring.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
\div =
  
  ## (division)  Major structural division of text, such as a preface, chapter or section. 
  element div {
    model.milestoneLike.text*,
    model.headLike?,
    (model.divLike | model.textcomponentLike)+,
    model.milestoneLike.text*,
    att.common.attributes,
    att.declaring.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.typed.attributes,
    empty
  }
front =
  
  ## (front matter)  Bundles prefatory text found before the start of the musical text. 
  element front {
    model.milestoneLike.text*,
    (model.divLike | model.frontPart)+,
    model.milestoneLike.text*,
    att.common.attributes,
    att.declaring.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
head =
  
  ## (heading)  Contains any heading, for example, the title of a section of text, or the heading of a list. 
  element head {
    (text
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.xy.attributes,
    empty
  }
l =
  
  ## (line of text)  Contains a single line of text within a line group. 
  element l {
    (text
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
lg =
  
  ## (line group)  May be used for any section of text that is organized as a group of lines; however, it is most often used for a group of verse lines functioning as a formal unit, e.g. a stanza, refrain, verse paragraph, etc. 
  element lg {
    model.headLike?,
    (model.lLike | model.lgLike),
    (model.lLike | model.lgLike)*,
    att.common.attributes,
    att.declaring.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.xy.attributes,
    empty
  }
li =
  
  ## (list item)  Single item in a <list>. 
  element li {
    (text
     | model.textcomponentLike
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    empty
  }
\list =
  
  ## A formatting element that contains a series of items separated from one another and arranged in a linear, often vertical, sequence. 
  element list {
    model.headLike?,
    li+,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.typed.attributes,
    att.xy.attributes,
    
    ## used to identify and format a list. In a "simple" list, <item>s are not numbered or bulleted. In a "marked" list, the sequence of the list items is not critical, and a bullet, box, dash, or other character is displayed at the start of each <item>. In an "ordered" list, the sequence of the items is important, and each <item> is lettered or numbered. Style sheet functions should be used to specify the mark or numeration system for each <item>.
    attribute form {
      
      ## items are not numbered or bulleted
      "simple"
      | 
        ## bullet, box, dash, or other character is displayed before each item
        "marked"
      | 
        ## each item is numbered or lettered
        "ordered"
    }?,
    empty
  }
quote =
  
  ## (block quote)  A formatting element that designates an extended quotation; that is, a passage attributed to a source external to the text and normally set off from the text by spacing or other typographic distinction. 
  element quote {
    (text | model.paracontentPart | p)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.xy.attributes,
    empty
  }
model.graphicprimitiveLike = anchoredText | curve | line | symbol
model.symbolTableLike = symbolTable
anchoredText =
  
  ## Container for text that is fixed to a particular location, regardless of changes made to the layout of the measures around it. 
  element anchoredText {
    (text
     | model.textphraseLike.limited
     | model.editLike
     | model.transcriptionLike)*,
    att.common.anl.attributes,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.startid.attributes,
    att.typed.attributes,
    att.visualoffset.attributes,
    att.xy.attributes,
    empty
  }
curve =
  
  ## A curved line that cannot be represented by a more specific element, such as a <slur>. 
  element curve {
    empty,
    att.common.anl.attributes,
    att.color.attributes,
    att.common.attributes,
    att.facsimile.attributes,
    att.startendid.attributes,
    att.typed.attributes,
    att.visualoffset.attributes,
    att.visualoffset2.attributes,
    att.xy.attributes,
    att.xy2.attributes,
    att.curvature.attributes,
    att.curverend.attributes,
    empty
  }
line =
  
  ## A line that cannot be represented by a more specific element. 
  element line {
    (text | model.textphraseLike.limited)*,
    att.common.anl.attributes,
    att.color.attributes,
    att.common.attributes,
    att.facsimile.attributes,
    att.startendid.attributes,
    att.typed.attributes,
    att.visualoffset.attributes,
    att.visualoffset2.attributes,
    att.xy.attributes,
    att.xy2.attributes,
    att.linerend.attributes,
    empty
  }
symbol =
  
  ## A reference to a previously defined symbol. 
  element symbol {
    empty,
    att.common.anl.attributes,
    att.color.attributes,
    att.common.attributes,
    att.facsimile.attributes,
    att.scalable.attributes,
    att.startid.attributes,
    att.typed.attributes,
    att.visualoffset.attributes,
    att.xy.attributes,
    
    ## contains a reference to a previously-declared user-defined symbol.
    attribute ref { data.URI },
    empty
  }
symbolDef =
  
  ## (symbol definition)  Declaration of an individual symbol in a symbolTable.
  element symbolDef {
    model.graphicprimitiveLike+,
    att.common.attributes,
    att.coordinated.attributes,
    empty
  }
symbolTable =
  
  ## Contains individual, user-defined symbols. 
  element symbolTable { symbolDef+, att.common.attributes, empty }
model.instrvoicePart = instrVoice | instrDesc | instrConfig
model.instrdescPart = instrName | courseCount
instrDesc =
  
  ## (description of an instrument) A detailed and structured description of an instrument.
  element instrDesc {
    (text | model.instrdescPart)*,
    att.common.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    att.pointing.attributes,
    empty
  }
att.instrdesc.attributes =
  att.typed.attributes, att.instrdesc.attribute.family
att.instrdesc.attribute.family =
  
  ## The instrument family of this instrument
  attribute family { text }?
instrName =
  
  ## (instrument name) The name of an instrument
  element instrName {
    text, att.common.attributes, att.instrdesc.attributes, empty
  }
model.instrconfigPart = courseTuning
instrConfig =
  
  ## (instrument configuration) Specifies how an instrument is required to be configured by this score.
  element instrConfig {
    (text | model.instrconfigPart)*, att.common.attributes, empty
  }
att.fingering.attributes =
  att.fingering.attribute.playingHand,
  att.fingering.attribute.playingFinger,
  att.fingering.attribute.symbol
att.fingering.attribute.playingHand =
  
  ## The hand (left, right, or both) prescribed by the fingering marking.
  attribute playingHand {
    
    ## Left hand
    "left"
    | 
      ## Right hand
      "right"
    | 
      ## Both left and right hands
      "both"
  }?
att.fingering.attribute.playingFinger =
  
  ## The finger prescribed by the fingering marking.
  attribute playingFinger { data.FINGER.FRET }?
att.fingering.attribute.symbol =
  
  ## The symbol employed in the fingering marking.
  attribute symbol { text }?
fingering =
  
  ## (instrument fingering) Indicates an instrument fingering marking.
  element fingering {
    empty,
    att.fingering.attributes,
    att.common.attributes,
    att.authorized.attributes,
    att.edit.attributes,
    att.pointing.attributes,
    empty
  }
tabChord =
  
  ## (tablature chord) Simultaneously played tablature notes, all sharing a (possibly implied) rhythm sign, but requiring an explicit duration attribute.
  element tabChord {
    model.tabchordPart*,
    att.common.attributes,
    att.duration.additive.attributes,
    empty
  }
model.tabchordPart =
  tabNote
  | rhythmGlyph
  | abzug
  | tabBarre
  | ensembleLine
  | separee
  | fingering
tabNote =
  
  ## (tablature note) A indication of the string and fret position within a tablature chord.
  element tabNote {
    model.fretGlyphLike,
    att.common.attributes,
    
    ## The course on which the note is played.
    attribute course { xsd:integer },
    
    ## The fret on which the note is played.
    attribute fret { xsd:integer },
    empty
  }
model.fretGlyphLike = fretGlyph
fretGlyph =
  
  ## (tablature note glyph) Encodes the actual symbol found in the tablature source for a particular note. These are often simple numerals or letters, but may also (in German tablature) be characters such as  or  or letters with a bar such as .
  element fretGlyph { text, att.facsimile.attributes, empty }
rhythmGlyph =
  
  ## (tablature rhythm sign) The durational sign associated with a tablature chord. The intended use of <rhythmGlyph> is to encode the rhythmic sign found in the source (if any) while the actual duration of the associated tablature chord is encoded using the <tabChord>'s @dur attribute.
  element rhythmGlyph {
    text,
    att.common.attributes,
    att.facsimile.attributes,
    
    ## The Tabcode duration symbol.
    attribute tabcode { data.DURATION.tabcode }?,
    
    ## Indicates whether the rhythm sign has a note head.
    [ a:defaultValue = "false" ] attribute headed { data.BOOLEAN }?,
    (
     ## The number of beams (or flags) on the rhythm sign.
     attribute beams { xsd:integer }?)
    >> sch:pattern [
         id = "mei-rhythmGlyph-beams-beamsNoFermata-constraint-67"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:rhythmGlyph/@beams"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@beams and (not(@fermata) or @fermata='false')"
             "The @fermata attribute may not be used with @beams on "
             sch:name [ ]
             "\x{a}" ~
             "               "
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    
    ## The number of dots on the rhythm sign.
    attribute dots { xsd:integer }?,
    (
     ## Indicates whether the rhythm sign is a fermata.
     attribute fermata { data.BOOLEAN }?)
    >> sch:assret [
         test = "@fermata='true' and not(@beams)"
         "The @beams attribute may not be used with @fermata on "
         sch:name [ ]
         "\x{a}" ~
         "         "
       ],
    empty
  }
abzug =
  
  ## (abzug marking) abzug marking
  element abzug {
    empty, att.common.attributes, att.startendid.attributes, empty
  }
tabBarre =
  
  ## (barr marking) barr marking
  element tabBarre {
    empty,
    att.common.attributes,
    att.startid.attributes,
    att.fretlocation.attributes,
    empty
  }
ensembleLine =
  
  ## (ensemble line) Indicates that two <tabNote>s are to be played simultaneously.
  element ensembleLine {
    empty, att.common.attributes, att.startendid.attributes, empty
  }
connectingLine =
  
  ## (connecting line) connecting line
  element connectingLine {
    empty, att.common.attributes, att.startendid.attributes, empty
  }
separee =
  
  ## (separe marking) Indicates that two <tabNote>s in a single <tabChord> should be played sequentially (rather than simultaneously).
  element separee {
    empty, att.common.attributes, att.startendid.attributes, empty
  }
courseCount =
  
  ## (number of courses) The number of courses on a lute.
  element courseCount { text, att.common.attributes, empty }
courseTuning =
  
  ## (tuning of courses) Child <course> elements should be used to indicate the tuning of each course on a lute.
  element courseTuning {
    course+, bassTuning*, att.common.attributes, empty
  }
course =
  
  ## (course tuning information) Describes the tuning of a course on a lute.
  element course {
    \string*, att.common.attributes, att.pitched.attributes, empty
  }
\string =
  
  ## (a string of a course) Describes the tuning of a single string of a course on a lute.
  element string {
    empty, att.common.attributes, att.pitched.attributes, empty
  }
bassTuning =
  
  ## (bass course tuning) Describes the tuning of the bass course of a lute.
  element bassTuning {
    empty, att.common.attributes, att.keySig.log.attributes, empty
  }
start = mei | meiHead | meiCorpus | music
